---
title: C++设计模式
date: 2021-02-22 10:25:20
tags:
categories:
---

# P1. 设计模式简介

- 设计模式：“每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动。"——Christopher Alexander

- 软件设计的金科玉律 ——复用

- 各种因素的变化造成软件设计十分复杂,常见做法有分解和抽象。

  - 分解: 将将大问题分解为多个小问题，将复杂问题分解为多个简单问题

  - 抽象: 忽视非本质细节，处理泛化和理想化的对象模型

  - 举例：假设需要实现一个画布，需要划出直线和矩形
    - 按照分解的思路，需要写出`Line`和`Rect`两个类，再在画布上进行绘制
    - 按照抽象的思路，`Line`和`Rect`两个类继承自抽象类`Shape`，通过override虚函数实现`draw()`自身的绘制，画布上`Shape`类的多态调用`draw()`即可。
  
  - 就现在的情况看，两种写法并没有什么差别，但当需要增加`Circle`类时，
    - 分解法不仅要新增`Circle`类，还要在画布上新增绘制函数
    - 抽象法只需新增`Circle`类即可
    - 分解法改动地方多，因此需要编译多个文件，抽象法只需编译新增的文件即可

# P2. 面向对象设计原则

## 重新认识面向对象

- 理解隔离变化
  - 从宏观层面来看，面向对象的构建方式更能适应软件的变化，能将变化所带来的影响减为最小
- 各司其职
  - 从微观层面来看，面向对象的方式更强调各个类的“责任”（多态中接口一致，实现不同）
  - 由于需求变化导致的新增类型不应该影响原来类型的实现——是所谓各负其责
- 对象是什么？
  - 从语言实现层面来看，对象封装了代码和数据。
  - 从规格层面讲，对象是一系列可被使用的公共接口。
  - 从概念层面讲，对象是某种拥有责任的抽象。

## 面向对象八大原则

- 依赖倒置原则（DIP）
  - 高层模块(稳定)不应该依赖于低层模块(变化)，二者都应该依赖于抽象(稳定) 。
  - 抽象(稳定)不应该依赖于实现细节(变化) ，实现细节应该依赖于抽象(稳定)。（实现变化的隔离）

- 开放封闭原则（OCP）
  - 对扩展开放，对更改封闭。
  - 类模块应该是可扩展的，但是不可修改（应该增加一些东西而不是对原来的东西进行修改）

- 单一职责原则（SRP）
  - 一个类应该仅有一个引起它变化的原因。
  - 变化的方向隐含着类的责任。(类中方法太多时候需要分割责任)

- Liskov 替换原则（LSP）
  - 子类必须能够替换它们的基类(IS-A)。（子类不应该否定父类的方法，否则不应该继承）
  - 继承表达类型抽象。

- 接口隔离原则（ISP）
  - 不应该强迫客户程序依赖它们不用的方法。
  - 接口应该小而完备。（开放给子类的用protected，仅自己用的protected，给别人的的才public，给别人用的接口要保持稳定）

- 优先使用对象组合，而不是类继承
  - 类继承通常为“白箱复用”，对象组合通常为“黑箱复用” 。
  - 继承在某种程度上破坏了封装性，子类父类耦合度高。
  - 而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。

- 封装变化点
  - 使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。

- 针对接口编程，而不是针对实现编程
  - 不将变量类型声明为某个特定的具体类，而是声明为某个接口。
  - 客户程序无需获知对象的具体类型，只需要知道对象所具有的接口。（抽象类和抽象类的调用函数）
  - 减少系统中各部分的依赖关系，从而实现“高内聚、松耦合”的类型设计方案。
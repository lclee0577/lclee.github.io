---
title: C++设计模式
date: 2021-02-22 10:25:20
tags:
categories:
---

# P1. 设计模式简介

- 设计模式：“每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动。"——Christopher Alexander

- 软件设计的金科玉律 ——复用

- 各种因素的变化造成软件设计十分复杂,常见做法有分解和抽象。

  - 分解: 将将大问题分解为多个小问题，将复杂问题分解为多个简单问题

  - 抽象: 忽视非本质细节，处理泛化和理想化的对象模型

  - 举例：假设需要实现一个画布，需要划出直线和矩形
    - 按照分解的思路，需要写出`Line`和`Rect`两个类，再在画布上进行绘制
    - 按照抽象的思路，`Line`和`Rect`两个类继承自抽象类`Shape`，通过override虚函数实现`draw()`自身的绘制，画布上`Shape`类的多态调用`draw()`即可。
  
  - 就现在的情况看，两种写法并没有什么差别，但当需要增加`Circle`类时，
    - 分解法不仅要新增`Circle`类，还要在画布上新增绘制函数
    - 抽象法只需新增`Circle`类即可
    - 分解法改动地方多，因此需要编译多个文件，抽象法只需编译新增的文件即可

# P2. 面向对象设计原则

## 重新认识面向对象

- 理解隔离变化
  - 从宏观层面来看，面向对象的构建方式更能适应软件的变化，能将变化所带来的影响减为最小
- 各司其职
  - 从微观层面来看，面向对象的方式更强调各个类的“责任”（多态中接口一致，实现不同）
  - 由于需求变化导致的新增类型不应该影响原来类型的实现——是所谓各负其责
- 对象是什么？
  - 从语言实现层面来看，对象封装了代码和数据。
  - 从规格层面讲，对象是一系列可被使用的公共接口。
  - 从概念层面讲，对象是某种拥有责任的抽象。

## 面向对象八大原则

- 依赖倒置原则（DIP）
  - 高层模块(稳定)不应该依赖于低层模块(变化)，二者都应该依赖于抽象(稳定) 。
  - 抽象(稳定)不应该依赖于实现细节(变化) ，实现细节应该依赖于抽象(稳定)。（实现变化的隔离）

- 开放封闭原则（OCP）
  - 对扩展开放，对更改封闭。
  - 类模块应该是可扩展的，但是不可修改（应该增加一些东西而不是对原来的东西进行修改）

- 单一职责原则（SRP）
  - 一个类应该仅有一个引起它变化的原因。
  - 变化的方向隐含着类的责任。(类中方法太多时候需要分割责任)

- Liskov 替换原则（LSP）
  - 子类必须能够替换它们的基类(IS-A)。（子类不应该否定父类的方法，否则不应该继承）
  - 继承表达类型抽象。

- 接口隔离原则（ISP）
  - 不应该强迫客户程序依赖它们不用的方法。
  - 接口应该小而完备。（开放给子类的用protected，仅自己用的protected，给别人的的才public，给别人用的接口要保持稳定）

- 优先使用对象组合，而不是类继承
  - 类继承通常为“白箱复用”，对象组合通常为“黑箱复用” 。
  - 继承在某种程度上破坏了封装性，子类父类耦合度高。
  - 而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。

- 封装变化点
  - 使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。

- 针对接口编程，而不是针对实现编程
  - 不将变量类型声明为某个特定的具体类，而是声明为某个接口。
  - 客户程序无需获知对象的具体类型，只需要知道对象所具有的接口。（抽象类和抽象类的调用函数）
  - 减少系统中各部分的依赖关系，从而实现“高内聚、松耦合”的类型设计方案。

# P3. 模板方法

## 重构获得模式 Refactoring to Patterns

- 现代软件设计的特征是“需求的频繁变化”。设计模式的要点是“寻找变化点，然后在变化点处应用设计模式，从而来更好地应对需求的变化”
- “什么时候、什么地点应用设计模式”比“理解设计模式结构本身”更为重要。

- 没有一步到位的设计模式。敏捷软件开发实践提倡的“Refactoring to Patterns”从重构到模式是目前普遍公认的最好的使用设计模式的方法。（分析现有程序违背那些设计原则，一步一步分析得到某种模式）

## 重构关键技法

- 静态 → 动态
- 早绑定  →  晚绑定
- 继承  →  组合
- 编译时依赖 →  运行时依赖
- 紧耦合  → 松耦合

## 模板方法模式

- 对于某一项任务，它常常有稳定的整体操作结构，但各个子步骤却有很多改变的需求，或者由于固有的原因（比如框架与应用之间的关系）而无法和任务的整体结构同时实现。

- 举例：需要顺序执行5个步骤，库开发人员完成了1,3,5，剩下2,4需要有具体业务而定
  - 结构化过程则为：app开发人员完成2,4，和软件主流程1-5的调用
  - 面向对象过程：库开发人员在类内`run()`中实现调用1-5步骤，app继承基类并override步骤2，4，调用`run()`即可（这里步骤2,4是纯虚函数）
  - 注意基类的结构函数应该是虚函数（）
- 晚绑定：父类调用子类的方法

- 定义一个操作中的算法的骨架 (**稳定**)（就是上面的run（）），而将一些步骤延迟(**变化**)到子类中。Template Method使得子类可以不改变(复用)一个算法的结构即可**重定义**(override 重写)该算法的某些特定步骤。

- 注意应用设计模式程序中必须有稳定的部分，若全稳定或全不稳定就不能应用设计模式，设计模式是找到稳定与不稳定之间的分离点

## 模板方法要点总结

- 最简洁的机制（虚函数的多态性）为很多应用程序框架提供了灵活的扩展点（继承和override），是代码复用方面的基本实现结构。

- 除了可以灵活应对子步骤的变化外，“不要调用我，让我来调用你”的反向控制结构是Template Method的典型应用（父类指针调用子类实现多态）。

- 在具体实现方面，被Template Method调用的虚方法可以具有实现，也可以没有任何实现（抽象方法、纯虚方法），但一般推荐将它们设置为protected方法（这些虚函数单独调用没有意义，客户只需调用调用这个流程`run()`）

# P4. 策略模式

- 与 模板方法模式一样属于组件协作模式

- 代码中出现大量 if-else 多情况分类处理（并且有可能出现更多情况）时，极大概率可以应用策略模式

- 定义：一系列算法，把它们一个个封装起来，并且使它们可互相替换（变化）。该模式使得算法可独立于使用它的客户程序(稳定)而变化（扩展，子类化）

- 举例：计算三个国家的税率
  - 分解法：客户类中先判断是哪个国家（多个if-else），再根据各个国家进行计算
  - 策略模式法：定义税率计算策略基类，其中定义虚函数计算税率，各个国家税率继承自这个基类，客户类中只需建立基类指针调用虚函数即可

- 可以看出分解法每新增一个国家税率都需要修改客户类，不符合我们的设计原则，二策略模式仅仅新增一个新的国家税率即可

## 策略模式要点总结

- 为组件提供了一系列可重用的算法，从而可以使得类型在运行时方便地根据需要在各个算法之间进行切换

- 提供了用条件判断语句以外的另一种选择，消除条件判断语句，就是在解耦合。含有许多条件判断语句的代码通常都需要Strategy模式


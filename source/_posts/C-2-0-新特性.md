---
title: C++ 2.0 新特性
date: 2021-02-03 14:19:42
tags:
categories: C++
---

# P1. 环境介绍

- 涵盖 c++11 和 c++14

- C++ 2.0 的新特性包含语言和标准库两部分

  - 头文件不再使用 `.h` 后缀，例如 `#include <vector>`

  - 新式的 c 头文件也不再带有 `.h`, 例如 `#include <cstdio>`，在之前的名称前面加一个 c

  - 旧式 c 头文件 带有 `.h`仍然可以使用，例如 `#include <stdio.h>`

  - 常用的数据类型都在 `std` 这里命名空间内，如`<type_traits>`, `< unordered_set>`，`<forward_list>` 等等

# P2. variadic templates 变参模板

- 可以处理任意类型，任意数量的参数

- 本质是将参数分成第一个和后边一包（pack），每次处理第一个，在递归调用。

- 注意需要写边界条件。

```cpp
void print(){}

template<typename T, typename... Types>
void print(const T& firstArg, const Types&... args){
    cout << firstArg << endl;
    print(args...);
}

print(123, "heool",bitset<16>(377),7.5);//就可以以此打印
```

- `...` 表示参数包，注意代码中 `...` 的位置

```cpp
template<typename... Types>
void print(const Types&... args){
    cout << "one type" << endl;
}
```

- 上面这段重载版本也可以与之前的共存，具体原来后面课程再讲，我认为应该是调用较为特化的版本,先留个坑讲解之后再来补充

- 还有两个计算hash值 和 tuple 的递归继承的范例在 {%post_link STL与泛型编程 STL与泛型编程 %} `P40`  `hash_val`函数 和 `P41` `tuple` 的定义

# P3. 一些细节知识

- `vector<list<int> >` 在c++11 之前两个尖括号必须分开，否则会被认为是 `>>` 操作符，c++11之后则不必

- 之前的版本一直是将 `NULL` 定义为 0，这与将指针赋值为 0 不太符合，新增关键字 `nullptr` 来代替 `NULL`。

- 自动类型推导 `auto`，用来处理变量名过长或者变量类型过于复杂。不可用来生命所有变量。

```cpp
vector<string> v;
...
auto pose = v.begin();//vector<string> ::iterator 类型太长
auto l = [](int x) -> bool{//匿名函数的类型过于复杂，匿名函数在后面会谈到
    ...
}

```

# P4. Uniform Initialization 一致初始化

- 接前一讲，`auto` 可以用来简化代码

```cpp
list<string> c;
...
list<string>::iterator ite;
ite = find(c.begin(),c.end(),target);

auto = find(c.begin(),c.end(),target); //省去提前生命变量

```

- 在之前的版本中会出现各种方法的初始化，小括号，中括号，大括号。在c++11之后，可以都使用大括号来初始化。

```cpp
int valuesp[] {10,20,30};
vector<int> v {2,3,5,4,6,4};
vector<string> cities {
    "Berlin","New York", "London"
};
complex<double> c{4.0,3.0}//相当于c(4.0,3.0) 
```

- 编译器看到 `{t1,t2,t3,...tn}`,便会做出一个 `initializer_list<T>`,关联到一个 `array<T,n>`,调用函数（如ctor）时这些元素被逐一拆解传给函数。

- 若函数有接受 `initializer_list<T>` 的特化版本，则直接传入

- 若函数没有接受 `initializer_list<T>` 的特化版本，则拆解传入

- 若函数仅有 `initializer_list<T>` 版本，则需要我们自己准备好一包来传入，之后会有更加详细的例子。

- 所有的容器都有接受 `initializer_list<T>`版本的ctor

- `complex<double>`并没有接受 `initializer_list<T>`的版本，`array<double,2>` 被拆解传给ctor

# P5. Initializer List 上

- 以 {} 初始化的变量有初值

```cpp
int i;      //i 未定义
int j{};    //i初始化为0
int* p；    //未定义指针
int* q{};   //q初始化为nullptr
```

- narrowing initializations 窄向初始化

```cpp
int x1(5.3);    //OK 但是为5
int x2 = 5.3；  //OK 但是为5
int x3{5.3}；   //error: narrowing conversion
char c1{7};     //OK 虽然7是int，但是可以转成char
char c2{99999}; //error: narrowing conversion
```

# P6. Initializer List 下

- 可以用来进行初始化，也可以用来处理一串数据 a list of valve

```cpp
void print(initializer_list<int> val){ //传入参数必须是initializer_list 或者{  }
    for (auto p = val.begin(); p != val.end(); ++p)
        cout << *p << endl;
}

print({1, 2, 3});
```

- initializer_list 的定义如下，简单来说编译器可以调用第17行的自由构造函数，实现变量初始化。

- 编译器在边缘过程中先准备好一个array，把指针地址和长度传给私有的构造函数实现初始化

```cpp{.line-numbers}

  template<class _E>
    class initializer_list
    {
    public:
      typedef _E            value_type;
      typedef const _E&     reference;
      typedef const _E&     const_reference;
      typedef size_t        size_type;
      typedef const _E*     iterator;
      typedef const _E*     const_iterator;

    private:
      iterator          _M_array;
      size_type         _M_len;

      // The compiler can call a private constructor.
      constexpr initializer_list(const_iterator __a, size_type __l)
      : _M_array(__a), _M_len(__l) { }

    public:
      constexpr initializer_list() noexcept
      : _M_array(0), _M_len(0) { }

      // Number of elements.
      constexpr size_type
      size() const noexcept { return _M_len; }

      // First element.
      constexpr const_iterator
      begin() const noexcept { return _M_array; }

      // One past the last element.
      constexpr const_iterator
      end() const noexcept { return begin() + size(); }
    };
```

- 由于initializer_list只是两个指针，对它的拷贝是危险的。

- `initializer_list` 在标准库中(几乎所有的容器和部分算法)广泛使用。

- 可以多个数值比大小

```cpp
#include <algorithm>
cout << max({54, 16, 30, 50，70 })<< endl;//使用initializer_list比较大小是先 #include <algorithm> 否则无法运行
```

# P7. explicit

- 作用于构造函数，取消隐式转换。极少数用于模板

```cpp {.line-numbers}
struct Complex
{
    int real, imag;
    /*explicit*/ Complex(int re,int im = 0):real(re),imag(im){}

    Complex operator+(const Complex& x){
        return Complex(real + x.real, imag + x.imag);
    }

    friend ostream& operator<<(ostream &out,const Complex &c){
                out<<"("<<c.real<<","<<c.imag<<")";
        return out;
    };
};

Complex c1(12, 5);
Complex c2 = c1 + 5;
```

- 当第 `4` 行没有 `explicit` 时，最会一行中的 5 会被隐式转换为 Complex 类型。

- 没有 `explicit` 修饰，且构造函数只有一个参数没有指定，编译器可以提供隐式转换。

- 当构造函数指明为 `explicit` 时，只能显式定义，否则将编译报错。

# P8. range-based for statement

- 简单的for循环写法 `for(decl:coll){ statement }`

- 取出 `coll` 中的每一个元素赋值到 `decl` 中括号

- 如果要修改容器中的内容需要取引用。若没有第二行取引用，则对i的修改不会改变容器

- 推荐取引用，减少赋值带来的开销

```cpp
    vector<int> coll{1, 2, 3, 4, 5, 6};
    for(auto &i :coll){
        i = i * 10;
        cout << i << " ";
    }
    cout << endl;

    ostream_iterator<int> out_iter(cout, " ");//#include<iterator>
    copy(coll.cbegin(), coll.cend(), out_iter);//打印容器内容
 
```

# P9. =defualt, =delete

- 一个类如果应定义了ctor，那么编译器就不在提供 default ctor

- 如果强制加上一个 =default，就可以重新获得 defualt ctor

- 在 default ctor 中编译器会来处理一些继承相关的工作

- =delete 就是删除这个函数

- 一般 = delete 和 =default 作用于 构造，拷贝构造，析构函数上

# P10. Alias Template

```cpp
template <typename T>
using Vec = std::vector<T,MyAlloc<T>>;//默认使用allocator

Vec<int> coll;
```

- 模板的化名明，使用typedef 和 #define 无法达到同样的效果

- 当使用化名之后就不能再对其使用特化或偏特化。


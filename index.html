<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Blog-lclee">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Blog-lclee">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="lclee">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Blog-lclee</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Blog-lclee</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/22/C-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lclee">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog-lclee">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/22/C-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">C++设计模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-02-22 10:25:20" itemprop="dateCreated datePublished" datetime="2021-02-22T10:25:20+08:00">2021-02-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-02-28 21:03:18" itemprop="dateModified" datetime="2021-02-28T21:03:18+08:00">2021-02-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="P1-设计模式简介"><a href="#P1-设计模式简介" class="headerlink" title="P1. 设计模式简介"></a>P1. 设计模式简介</h1><ul>
<li><p>设计模式：“每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动。”——Christopher Alexander</p>
</li>
<li><p>软件设计的金科玉律 ——复用</p>
</li>
<li><p>各种因素的变化造成软件设计十分复杂,常见做法有分解和抽象。</p>
<ul>
<li><p>分解: 将将大问题分解为多个小问题，将复杂问题分解为多个简单问题</p>
</li>
<li><p>抽象: 忽视非本质细节，处理泛化和理想化的对象模型</p>
</li>
<li><p>举例：假设需要实现一个画布，需要划出直线和矩形</p>
<ul>
<li>按照分解的思路，需要写出<code>Line</code>和<code>Rect</code>两个类，再在画布上进行绘制</li>
<li>按照抽象的思路，<code>Line</code>和<code>Rect</code>两个类继承自抽象类<code>Shape</code>，通过override虚函数实现<code>draw()</code>自身的绘制，画布上<code>Shape</code>类的多态调用<code>draw()</code>即可。</li>
</ul>
</li>
<li><p>就现在的情况看，两种写法并没有什么差别，但当需要增加<code>Circle</code>类时，</p>
<ul>
<li>分解法不仅要新增<code>Circle</code>类，还要在画布上新增绘制函数</li>
<li>抽象法只需新增<code>Circle</code>类即可</li>
<li>分解法改动地方多，因此需要编译多个文件，抽象法只需编译新增的文件即可</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="P2-面向对象设计原则"><a href="#P2-面向对象设计原则" class="headerlink" title="P2. 面向对象设计原则"></a>P2. 面向对象设计原则</h1><h2 id="重新认识面向对象"><a href="#重新认识面向对象" class="headerlink" title="重新认识面向对象"></a>重新认识面向对象</h2><ul>
<li>理解隔离变化<ul>
<li>从宏观层面来看，面向对象的构建方式更能适应软件的变化，能将变化所带来的影响减为最小</li>
</ul>
</li>
<li>各司其职<ul>
<li>从微观层面来看，面向对象的方式更强调各个类的“责任”（多态中接口一致，实现不同）</li>
<li>由于需求变化导致的新增类型不应该影响原来类型的实现——是所谓各负其责</li>
</ul>
</li>
<li>对象是什么？<ul>
<li>从语言实现层面来看，对象封装了代码和数据。</li>
<li>从规格层面讲，对象是一系列可被使用的公共接口。</li>
<li>从概念层面讲，对象是某种拥有责任的抽象。</li>
</ul>
</li>
</ul>
<h2 id="面向对象八大原则"><a href="#面向对象八大原则" class="headerlink" title="面向对象八大原则"></a>面向对象八大原则</h2><ul>
<li><p>依赖倒置原则（DIP）</p>
<ul>
<li>高层模块(稳定)不应该依赖于低层模块(变化)，二者都应该依赖于抽象(稳定) 。</li>
<li>抽象(稳定)不应该依赖于实现细节(变化) ，实现细节应该依赖于抽象(稳定)。（实现变化的隔离）</li>
</ul>
</li>
<li><p>开放封闭原则（OCP）</p>
<ul>
<li>对扩展开放，对更改封闭。</li>
<li>类模块应该是可扩展的，但是不可修改（应该增加一些东西而不是对原来的东西进行修改）</li>
</ul>
</li>
<li><p>单一职责原则（SRP）</p>
<ul>
<li>一个类应该仅有一个引起它变化的原因。</li>
<li>变化的方向隐含着类的责任。(类中方法太多时候需要分割责任)</li>
</ul>
</li>
<li><p>Liskov 替换原则（LSP）</p>
<ul>
<li>子类必须能够替换它们的基类(IS-A)。（子类不应该否定父类的方法，否则不应该继承）</li>
<li>继承表达类型抽象。</li>
</ul>
</li>
<li><p>接口隔离原则（ISP）</p>
<ul>
<li>不应该强迫客户程序依赖它们不用的方法。</li>
<li>接口应该小而完备。（开放给子类的用protected，仅自己用的protected，给别人的的才public，给别人用的接口要保持稳定）</li>
</ul>
</li>
<li><p>优先使用对象组合，而不是类继承</p>
<ul>
<li>类继承通常为“白箱复用”，对象组合通常为“黑箱复用” 。</li>
<li>继承在某种程度上破坏了封装性，子类父类耦合度高。</li>
<li>而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。</li>
</ul>
</li>
<li><p>封装变化点</p>
<ul>
<li>使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。</li>
</ul>
</li>
<li><p>针对接口编程，而不是针对实现编程</p>
<ul>
<li>不将变量类型声明为某个特定的具体类，而是声明为某个接口。</li>
<li>客户程序无需获知对象的具体类型，只需要知道对象所具有的接口。（抽象类和抽象类的调用函数）</li>
<li>减少系统中各部分的依赖关系，从而实现“高内聚、松耦合”的类型设计方案。</li>
</ul>
</li>
</ul>
<h1 id="P3-模板方法"><a href="#P3-模板方法" class="headerlink" title="P3. 模板方法"></a>P3. 模板方法</h1><h2 id="重构获得模式-Refactoring-to-Patterns"><a href="#重构获得模式-Refactoring-to-Patterns" class="headerlink" title="重构获得模式 Refactoring to Patterns"></a>重构获得模式 Refactoring to Patterns</h2><ul>
<li>现代软件设计的特征是“需求的频繁变化”。设计模式的要点是“寻找变化点，然后在变化点处应用设计模式，从而来更好地应对需求的变化”</li>
<li><p>“什么时候、什么地点应用设计模式”比“理解设计模式结构本身”更为重要。</p>
</li>
<li><p>没有一步到位的设计模式。敏捷软件开发实践提倡的“Refactoring to Patterns”从重构到模式是目前普遍公认的最好的使用设计模式的方法。（分析现有程序违背那些设计原则，一步一步分析得到某种模式）</p>
</li>
</ul>
<h2 id="重构关键技法"><a href="#重构关键技法" class="headerlink" title="重构关键技法"></a>重构关键技法</h2><ul>
<li>静态 → 动态</li>
<li>早绑定  →  晚绑定</li>
<li>继承  →  组合</li>
<li>编译时依赖 →  运行时依赖</li>
<li>紧耦合  → 松耦合</li>
</ul>
<h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><ul>
<li><p>对于某一项任务，它常常有稳定的整体操作结构，但各个子步骤却有很多改变的需求，或者由于固有的原因（比如框架与应用之间的关系）而无法和任务的整体结构同时实现。</p>
</li>
<li><p>举例：需要顺序执行5个步骤，库开发人员完成了1,3,5，剩下2,4需要有具体业务而定</p>
<ul>
<li>结构化过程则为：app开发人员完成2,4，和软件主流程1-5的调用</li>
<li>面向对象过程：库开发人员在类内<code>run()</code>中实现调用1-5步骤，app继承基类并override步骤2，4，调用<code>run()</code>即可（这里步骤2,4是纯虚函数）</li>
<li>注意基类的结构函数应该是虚函数（）</li>
</ul>
</li>
<li><p>晚绑定：父类调用子类的方法</p>
</li>
<li><p>定义一个操作中的算法的骨架 (<strong>稳定</strong>)（就是上面的run（）），而将一些步骤延迟(<strong>变化</strong>)到子类中。Template Method使得子类可以不改变(复用)一个算法的结构即可<strong>重定义</strong>(override 重写)该算法的某些特定步骤。</p>
</li>
<li><p>注意应用设计模式程序中必须有稳定的部分，若全稳定或全不稳定就不能应用设计模式，设计模式是找到稳定与不稳定之间的分离点</p>
</li>
</ul>
<h2 id="模板方法要点总结"><a href="#模板方法要点总结" class="headerlink" title="模板方法要点总结"></a>模板方法要点总结</h2><ul>
<li><p>最简洁的机制（虚函数的多态性）为很多应用程序框架提供了灵活的扩展点（继承和override），是代码复用方面的基本实现结构。</p>
</li>
<li><p>除了可以灵活应对子步骤的变化外，“不要调用我，让我来调用你”的反向控制结构是Template Method的典型应用（父类指针调用子类实现多态）。</p>
</li>
<li><p>在具体实现方面，被Template Method调用的虚方法可以具有实现，也可以没有任何实现（抽象方法、纯虚方法），但一般推荐将它们设置为protected方法（这些虚函数单独调用没有意义，客户只需调用调用这个流程<code>run()</code>）</p>
</li>
</ul>
<h1 id="P4-策略模式"><a href="#P4-策略模式" class="headerlink" title="P4. 策略模式"></a>P4. 策略模式</h1><ul>
<li><p>与 模板方法模式一样属于组件协作模式</p>
</li>
<li><p>代码中出现大量 if-else 多情况分类处理（并且有可能出现更多情况）时，极大概率可以应用策略模式</p>
</li>
<li><p>定义：一系列算法，把它们一个个封装起来，并且使它们可互相替换（变化）。该模式使得算法可独立于使用它的客户程序(稳定)而变化（扩展，子类化）</p>
</li>
<li><p>举例：计算三个国家的税率</p>
<ul>
<li>分解法：客户类中先判断是哪个国家（多个if-else），再根据各个国家进行计算</li>
<li>策略模式法：定义税率计算策略基类，其中定义虚函数计算税率，各个国家税率继承自这个基类，客户类中只需建立基类指针调用虚函数即可</li>
</ul>
</li>
<li><p>可以看出分解法每新增一个国家税率都需要修改客户类，不符合我们的设计原则，二策略模式仅仅新增一个新的国家税率即可</p>
</li>
</ul>
<h2 id="策略模式要点总结"><a href="#策略模式要点总结" class="headerlink" title="策略模式要点总结"></a>策略模式要点总结</h2><ul>
<li><p>为组件提供了一系列可重用的算法，从而可以使得类型在运行时方便地根据需要在各个算法之间进行切换</p>
</li>
<li><p>提供了用条件判断语句以外的另一种选择，消除条件判断语句，就是在解耦合。含有许多条件判断语句的代码通常都需要Strategy模式</p>
</li>
</ul>
<h1 id="P5-观察者模式"><a href="#P5-观察者模式" class="headerlink" title="P5. 观察者模式"></a>P5. 观察者模式</h1><ul>
<li>属于组件协作模式</li>
<li><p>当需要建立一种通知依赖关系，当一个对象状态发生改变时，所有的依赖（观察者对象）都将得到通知</p>
</li>
<li><p>设想如下场景： 在界面上显示任务的运行进度</p>
<ul>
<li>一般的做法是在任务内调用界面的绘图</li>
<li>但是这样做会使任务依赖于界面，根据设计原则两者都应该依赖于抽象</li>
<li>因此需要一个抽象通知基类，类内只含有接口。界面继承自该基类，任务类中含有该基类指针，使用指针调用接口函数进行绘图</li>
</ul>
</li>
<li><p>C++ 支持多继承，但是并不推荐继承多个类，这样会造成紧耦合，推荐的是继承一个类和多个接口，这里的通知类就是接口</p>
</li>
<li><p>当有多个观察者时，应在任务类内使用容器存储多个通知类指针，同时要在类内实现添加、删除观察者的成员函数。对容器进行迭代实现通知所有观察者。在界面类中添加多个观察者</p>
</li>
</ul>
<h2 id="观察者模式要点总结"><a href="#观察者模式要点总结" class="headerlink" title="观察者模式要点总结"></a>观察者模式要点总结</h2><ul>
<li><p>使用面向对象的抽象，Observer模式使得我们可以独立地改变目标与观察者，从而使二者之间的依赖关系达致松耦合。（可以任意增加或删去容器内观察者数量，改变任务类程序）</p>
</li>
<li><p>目标发送通知时，无需指定观察者，通知（可以携带通知信息作为参数）会自动传播。</p>
</li>
<li><p>观察者自己决定是否需要订阅通知，目标对象对此一无所知。（界面类中是否增加观察者）</p>
</li>
<li><p>Observer模式是基于事件的UI框架中非常常用的设计模式，也是MVC模式的一个重要组成部分。</p>
</li>
</ul>
<h1 id="P6-装饰模式"><a href="#P6-装饰模式" class="headerlink" title="P6. 装饰模式"></a>P6. 装饰模式</h1><ul>
<li><p>属于单一责任模式（并不是其他模式没有责任问题，而是这个模式在责任问题上特别明显）</p>
</li>
<li><p>过度的使用继承来拓展对象的功能会导致子类的膨胀，根据需求来动态实现子类拓展避免子类膨胀</p>
</li>
<li><p>模式定义：动态（组合）地给一个对象增加一些额外的职责。就增加功能而言，Decorator模式比生成子类（继承）更为灵活（消除重复代码 &amp; 减少子类个数）</p>
</li>
<li><p>举例：有一系列流如文件流、网络流、内存流，有一系列操作如加密、缓存。若使用继承来实现这些操作则需要定义很多次继承，如加密缓存文件流→缓存文件流→文件流→流。一旦操作的种类增加，将需要写出许多子类，而且包含大量重复代码（加密和缓存的手段相同）</p>
<ul>
<li>流的种类和操作并不是继承关系，应该是组合关系</li>
</ul>
</li>
</ul>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//业务操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stream</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">virtual</span> ~Stream()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主体类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileStream</span>:</span> <span class="keyword">public</span> Stream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//读文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定位文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//写文件流</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>版本一：可以看到加密流不仅继承父类，还包含一个指向父类的指针（这个可以认为是装饰模式的重要标志）</p>
</li>
<li><p>这里的继承是为了保持接口一致，父类指针时为了实现加密操作</p>
</li>
</ul>
<h2 id><a href="#" class="headerlink" title></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CryptoStream</span>:</span> <span class="keyword">public</span> Stream &#123;</span><br><span class="line"></span><br><span class="line">Stream* stream;<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">CryptoStream(Stream* stm):stream(stm)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//额外的加密操作...</span></span><br><span class="line">    stream-&gt;Read(number);<span class="comment">//读文件流</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/////使用方法</span></span><br><span class="line">FileStream* s1=<span class="keyword">new</span> FileStream();<span class="comment">//FileStream 继承自Stream</span></span><br><span class="line">CryptoStream* s2=<span class="keyword">new</span> CryptoStream(s1);</span><br></pre></td></tr></table></figure></h2><ul>
<li>版本二：虽然版本一已经实现了大部分功能，但是当操作种类增加时每类内包含的一个父类指针时固定的。因此可以将指针和装饰操作抽象为一个装饰类</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecoratorStream</span>:</span> <span class="keyword">public</span> Stream&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Stream* stream;<span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    DecoratorStream(Stream * stm):stream(stm)&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CryptoStream</span>:</span> <span class="keyword">public</span> DecoratorStream &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CryptoStream(Stream* stm):DecoratorStream(stm)&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        stream-&gt;Read(number);<span class="comment">//读文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="装饰模式要点总结"><a href="#装饰模式要点总结" class="headerlink" title="装饰模式要点总结"></a>装饰模式要点总结</h2><ul>
<li><p>通过采用组合而非继承的手法， Decorator模式实现了在运行时 动态扩展对象功能的能力而且可以根据需要扩展多个功能。避免 了使用继承带来的“灵活性差”和“多子类衍生问题”</p>
</li>
<li><p>Decorator类在接口上表现为is-a Component的继承关系，即 Decorator类继承了Component类所具有的接口。但在实现上又 表现为has-a Component的组合关系，即Decorator类又使用了另外一个Component类。（装饰类继承和组合了同一个类，这是十分少见的。继承是为了保持接口的一致，组合是为了对具体类新型包装增加新的功能）</p>
</li>
<li><p>Decorator模式的目的并非解决“多子类衍生的多继承”问题， Decorator模式应用的要点在于解决“主体类在多个方向上的扩展 功能”——是为“装饰”的含义。</p>
</li>
</ul>
<h1 id="P7-桥模式"><a href="#P7-桥模式" class="headerlink" title="P7. 桥模式"></a>P7. 桥模式</h1><ul>
<li><p>属于单一职责模式</p>
</li>
<li><p>模式定义：将抽象部分(业务功能)与实现部分(平台实现)分离，使它们都可以独立地变化。</p>
</li>
<li><p>例如：信息发送业务有移动和pc两个平台，精简版和完整版2个版本</p>
</li>
</ul>
<figure class="highlight cpp"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Messager</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Login</span><span class="params">(<span class="built_in">string</span> username, <span class="built_in">string</span> password)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(<span class="built_in">string</span> message)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PlaySound</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DrawShape</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">WriteText</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Connect</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">virtual</span> ~Messager()&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>若使用继承方法，就会有移动精简发送→移动发送→发送基类 等等这四种类，然而精简和完整版的流程与平台实现无关，因此需要将其剥离</p>
</li>
<li><p>与平台实现相关的成员函数为7-10行，因此需将其与实现相关部分变成一个子类,在运行时装配</p>
</li>
</ul>
<h2 id="-1"><a href="#-1" class="headerlink" title></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessagerImp</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PlaySound</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DrawShape</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">WriteText</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Connect</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">MessagerImp</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Messager</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">     MessagerImp* messagerImp;<span class="comment">//...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Login</span><span class="params">(<span class="built_in">string</span> username, <span class="built_in">string</span> password)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(<span class="built_in">string</span> message)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">virtual</span> ~Messager()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PCMessagerImp</span> :</span> <span class="keyword">public</span> MessagerImp&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PlaySound</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DrawShape</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">WriteText</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Connect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessagerLite</span> :</span><span class="keyword">public</span> Messager &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Login</span><span class="params">(<span class="built_in">string</span> username, <span class="built_in">string</span> password)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        messagerImp-&gt;Connect();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(<span class="built_in">string</span> message)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        messagerImp-&gt;WriteText();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        messagerImp-&gt;DrawShape();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Process</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//运行时装配</span></span><br><span class="line">    MessagerImp* mImp=<span class="keyword">new</span> PCMessagerImp();</span><br><span class="line">    Messager *m =<span class="keyword">new</span> Messager(mImp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="brige模式要点总结"><a href="#brige模式要点总结" class="headerlink" title="brige模式要点总结"></a>brige模式要点总结</h2><ul>
<li><p>Bridge模式使用“对象间的组合关系”解耦了抽象和实现之间固 有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自纬度的变化，即“子类化”它们。</p>
</li>
<li><p>Bridge模式有时候类似于多继承方案，但是多继承方案往往违背 单一职责原则（即一个类只有一个变化的原因），复用性比较差。Bridge模式是比多继承方案更好的解决方法。</p>
</li>
<li><p>Bridge模式的应用一般在“两个非常强的变化维度”，有时一个 类也有多于两个的变化维度，这时可以使用Bridge的扩展模式。</p>
</li>
</ul>
<h1 id="P8-工厂方法"><a href="#P8-工厂方法" class="headerlink" title="P8. 工厂方法"></a>P8. 工厂方法</h1><ul>
<li><p>属于对象创建模式，通过这个模式来避免<code>new</code>过程中所在造成的紧耦合（依赖于具体类）。它是接口抽象后的第一步工作</p>
</li>
<li><p>在软件系统中，经常面临着创建对象的工作；由于需求的变化，需要创建的对象的具体类型经常变化</p>
</li>
<li><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使得一个类的实例化延迟（目的：解耦，手段：虚函数）到子类</p>
</li>
<li><p>举例：创建多种不同类型的分割器</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainForm</span> :</span> <span class="keyword">public</span> Form</span><br><span class="line">&#123;</span><br><span class="line">    SplitterFactory*  factory;<span class="comment">//工厂</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MainForm(SplitterFactory*  factory)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;factory=factory;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Button1_Click</span><span class="params">()</span></span>&#123; </span><br><span class="line">        ISplitter * splitter=</span><br><span class="line">            factory-&gt;CreateSplitter(); <span class="comment">//多态new</span></span><br><span class="line">        splitter-&gt;split();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ISplitter</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~ISplitter()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//工厂基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SplitterFactory</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">CreateSplitter</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~SplitterFactory()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySplitter</span> :</span> <span class="keyword">public</span> ISplitter&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TxtSplitter</span>:</span> <span class="keyword">public</span> ISplitter&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySplitterFactory</span>:</span> <span class="keyword">public</span> SplitterFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">CreateSplitter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BinarySplitter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TxtSplitterFactory</span>:</span> <span class="keyword">public</span> SplitterFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">CreateSplitter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TxtSplitter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="工厂方法要点总结"><a href="#工厂方法要点总结" class="headerlink" title="工厂方法要点总结"></a>工厂方法要点总结</h2><ul>
<li><p>Factory Method模式用于隔离类对象的使用者和具体类型之间的 耦合关系。面对一个经常变化的具体类型，紧耦合关系(new)会导 致软件的脆弱</p>
</li>
<li><p>Factory Method模式通过面向对象的手法（多态），将所要创建的具体对象工作<strong>延迟</strong>到子类，从而实现一种扩展（而非更改）的策略，较好地解决了这种紧耦合关系（需要不同对象时只需新建不同类型工厂，并传递该工厂指针即可，对原有运行代码<code>MainForm</code>无需更改）</p>
</li>
<li><p>Factory Method模式解决“单个对象”的需求变化。缺点在于要求创建方法/参数相同。</p>
</li>
</ul>
<h1 id="P9-抽象工厂"><a href="#P9-抽象工厂" class="headerlink" title="P9. 抽象工厂"></a>P9. 抽象工厂</h1><ul>
<li><p>与工厂模式只有细微变化：一系列相互依赖的对象的创建工作</p>
</li>
<li><p>模式定义：提供一个接口，让该接口负责创建一系列“相关或者相互依赖的对象”，无需指定它们具体的类。</p>
</li>
<li><p>举例：有一系列数据库相关操作，连接、命令、设置连接、读取。同时需要支持不同的数据库</p>
<ul>
<li>按照之前工厂方法，需要操作、连接、读取的基类、工厂、和具体工厂 （这里会写出很多类）</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmployeeDAO</span>&#123;</span></span><br><span class="line"></span><br><span class="line">IDBConnectionFactory* dbConnectionFactory;</span><br><span class="line">IDBCommandFactory* dbCommandFactory;</span><br><span class="line">IDataReaderFactory* dataReaderFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;EmployeeDO&gt; <span class="title">GetEmployees</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IDBConnection* connection =</span><br><span class="line">        dbConnectionFactory-&gt;CreateDBConnection();</span><br><span class="line">    connection-&gt;ConnectionString(<span class="string">&quot;...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    IDBCommand* command =</span><br><span class="line">        dbCommandFactory-&gt;CreateDBCommand();</span><br><span class="line">    command-&gt;CommandText(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    command-&gt;SetConnection(connection); <span class="comment">//关联性</span></span><br><span class="line"></span><br><span class="line">    IDBDataReader* reader = command-&gt;ExecuteReader(); <span class="comment">//关联性</span></span><br><span class="line">    <span class="keyword">while</span> (reader-&gt;Read())&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>由于读取、命令、连接有很强的关联性，必须要使用同一种类型的数据库，因此这三个操作应该由同一个工厂产生（高内聚）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDBFactory</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDBConnection* <span class="title">CreateDBConnection</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDBCommand* <span class="title">CreateDBCommand</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDataReader* <span class="title">CreateDataReader</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqlDBFactory</span>:</span><span class="keyword">public</span> IDBFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDBConnection* <span class="title">CreateDBConnection</span><span class="params">()</span></span>&#123;<span class="comment">/*...*/</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDBCommand* <span class="title">CreateDBCommand</span><span class="params">()</span></span>&#123;<span class="comment">/*...*/</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDataReader* <span class="title">CreateDataReader</span><span class="params">()</span></span>&#123;<span class="comment">/*...*/</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmployeeDAO</span>&#123;</span></span><br><span class="line">    IDBFactory* dbFactory;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;EmployeeDO&gt; <span class="title">GetEmployees</span><span class="params">()</span></span>&#123;</span><br><span class="line">        IDBConnection* connection =</span><br><span class="line">            dbFactory-&gt;CreateDBConnection();</span><br><span class="line">        connection-&gt;ConnectionString(<span class="string">&quot;...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        IDBCommand* command =</span><br><span class="line">            dbFactory-&gt;CreateDBCommand();</span><br><span class="line">        command-&gt;CommandText(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">        command-&gt;SetConnection(connection); <span class="comment">//关联性</span></span><br><span class="line"></span><br><span class="line">        IDBDataReader* reader = command-&gt;ExecuteReader(); <span class="comment">//关联性</span></span><br><span class="line">        <span class="keyword">while</span> (reader-&gt;Read())&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="抽象工厂要点总结"><a href="#抽象工厂要点总结" class="headerlink" title="抽象工厂要点总结"></a>抽象工厂要点总结</h2><ul>
<li><p>抽象工厂更形象的解释是家族工厂，生产一系列相关的类，工厂方法可以看成抽象工厂中的一个特例</p>
</li>
<li><p>如果没有应对“多系列对象构建”的需求变化，则没有必要使用Abstract Factory模式，这时候使用简单的工厂完全可以。</p>
</li>
<li><p>“系列对象”指的是在某一特定系列下的对象之间有相互依赖、或作用的关系。不同系列的对象之间不能相互依赖。</p>
</li>
<li><p>Abstract Factory模式主要在于应对“新系列”的需求变动。其缺点在于难以应对“新对象”的需求变动。</p>
</li>
</ul>
<h1 id="P10-原型模式"><a href="#P10-原型模式" class="headerlink" title="P10. 原型模式"></a>P10. 原型模式</h1><ul>
<li><p>属于对象创建模式，相较于工厂模式简单一些，是工厂模式的一种变体（实际中用的不是特别多）</p>
</li>
<li><p>对象有很复杂的中间状态，从工厂生产出来的步骤过于复杂，使用原型模式直接进行拷贝。这些对象经常面临剧烈的变化，但是却拥有稳定一致的接口</p>
</li>
<li><p>模式定义：使用原型实例指定创建对象的种类，然后通过拷贝这些原型来创建新的对象</p>
</li>
<li><p>举例：具体实现上就是将抽象类与与工程合并，工厂创建变为克隆</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ISplitter</span>&#123;</span><span class="comment">//抽象类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">clone</span><span class="params">()</span></span>=<span class="number">0</span>; <span class="comment">//通过克隆自己来创建对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">virtual</span> ~ISplitter()&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySplitter</span> :</span> <span class="keyword">public</span> ISplitter&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BinarySplitter(*<span class="keyword">this</span>);<span class="comment">//调用拷贝构造函数克隆当前状态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainForm</span> :</span> <span class="keyword">public</span> Form</span><br><span class="line">&#123;</span><br><span class="line">    ISplitter*  prototype;<span class="comment">//原型对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    MainForm(ISplitter*  prototype)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;prototype=prototype;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Button1_Click</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        ISplitter * splitter=</span><br><span class="line">            prototype-&gt;clone(); <span class="comment">//克隆原型</span></span><br><span class="line">            <span class="comment">//prototype-&gt;split;    不能直接使用，原型对象是专门供你克隆的，真正使用的时候，我们要使用新的对象</span></span><br><span class="line">        </span><br><span class="line">        splitter-&gt;split();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="原型模式要点总结"><a href="#原型模式要点总结" class="headerlink" title="原型模式要点总结"></a>原型模式要点总结</h2><ul>
<li><p>Prototype模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系。它同样要求这些“易变类”拥有“稳定的接口”</p>
</li>
<li><p>Prototype模式对于“如何创建易变类的实体对象”采用“原型克隆”的方法来做，它使得我们可以非常灵活地动态创建“拥有某些稳定接口”的新对象——所需工作仅仅是注册一个新类的对象（即原型），然后在任何需要的地方克隆。</p>
</li>
<li><p>Prototype模式中的clone方法可以利用某些框架中的序列化来实现深拷贝</p>
</li>
</ul>
<h1 id="P11-构建器"><a href="#P11-构建器" class="headerlink" title="P11. 构建器"></a>P11. 构建器</h1><ul>
<li><p>属于对象创建模式，（不常用）</p>
</li>
<li><p>“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着<strong>剧烈的变化</strong>，但是将它们组合在一起的算法却<strong>相对稳定</strong> (与模板方法很像，但是这里是用来创建对象)</p>
</li>
</ul>
<hr>
<ul>
<li><p>举例：<code>House</code>的需要按照一定流程创建5个部分，这里创建流程和5个部分的创建都很复杂。</p>
<ul>
<li>首先将<code>House</code>类与他的创建过程分离</li>
<li>将5个部分的具体实现（<code>HouseBuilder</code> 第5行）与创建流程(<code>HouseDirector</code>第46行)分离（若创建流程和步骤不复杂放在一起也行）</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span>&#123;</span></span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HouseBuilder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">House* <span class="title">GetResult</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pHouse;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~HouseBuilder()&#123;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    </span><br><span class="line">    House* pHouse;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuildPart1</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuildPart2</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuildPart3</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuildPart4</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuildPart5</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StoneHouse</span>:</span> <span class="keyword">public</span> House&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StoneHouseBuilder</span>:</span> <span class="keyword">public</span> HouseBuilder&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuildPart1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//pHouse-&gt;Part1 = ...;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuildPart2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuildPart3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuildPart4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuildPart5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HouseDirector</span>&#123;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    HouseBuilder* pHouseBuilder;</span><br><span class="line">    </span><br><span class="line">    HouseDirector(HouseBuilder* pHouseBuilder)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;pHouseBuilder=pHouseBuilder;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">House* <span class="title">Construct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        pHouseBuilder-&gt;BuildPart1();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">            pHouseBuilder-&gt;BuildPart2();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">bool</span> flag=pHouseBuilder-&gt;BuildPart3();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            pHouseBuilder-&gt;BuildPart4();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        pHouseBuilder-&gt;BuildPart5();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> pHouseBuilder-&gt;GetResult();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Builder要点总结"><a href="#Builder要点总结" class="headerlink" title="Builder要点总结"></a>Builder要点总结</h2><ul>
<li><p>Builder 模式主要用于“分步骤构建一个复杂的对象”。在这其中“分步骤”是一个稳定的算法，而复杂对象的各个部分则经常变化。</p>
</li>
<li><p>变化点在哪里，封装哪里—— Builder模式主要在于应对“复杂对象各个部分”的频繁需求变动。其缺点在于难以应对“分步骤构建算法”的需求变动。</p>
</li>
<li><p>在Builder模式中，要注意不同语言中构造器内调用虚函数的差别（ C++ vs. C# )</p>
</li>
</ul>
<h1 id="P12-单件模式"><a href="#P12-单件模式" class="headerlink" title="P12. 单件模式"></a>P12. 单件模式</h1><ul>
<li><p>属于性能对象模式</p>
</li>
<li><p>面向对象很好地解决了”抽象”问题，但是不可避免的要付出一定代价。（通常继承和虚函数带来的影响可以忽略不计，但是大规模的应用可能会出现性能问题）</p>
</li>
<li><p>有些特殊的类，必须保证他们在系统效率中只存在一个实例，（如保证逻辑正确、良好的效率）。因此需要绕过常规的构造器，提供一种机制来保证一个类只有一个实例。这种功能应该由类的设计者来实现，而不是使用者的责任</p>
</li>
<li><p>模式定义：保证一个类仅有一个实例，并提供一个该实例的全局访问点</p>
</li>
<li><p>双检查锁由于内存读写reorder不安全。编译器出于优化的目的会先返回地址再进行构造，导致读到的内存里还没有完成构造，需要使用原子操作</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton();</span><br><span class="line">    Singleton(<span class="keyword">const</span> Singleton&amp; other);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">static</span> Singleton* m_instance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::m_instance=<span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程非安全版本 单线程可用</span></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        m_instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程安全版本，但锁的代价过高</span></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Lock lock;</span><br><span class="line">    <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        m_instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//双检查锁，但由于内存读写reorder不安全</span></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(m_instance==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        Lock lock;</span><br><span class="line">        <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            m_instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++ 11版本之后的跨平台实现 (volatile)</span></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;Singleton*&gt; Singleton::m_instance;</span><br><span class="line"><span class="built_in">std</span>::mutex Singleton::m_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Singleton* tmp = m_instance.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    <span class="built_in">std</span>::atomic_thread_fence(<span class="built_in">std</span>::memory_order_acquire);<span class="comment">//获取内存fence</span></span><br><span class="line">    <span class="keyword">if</span> (tmp == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        tmp = m_instance.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">        <span class="keyword">if</span> (tmp == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            tmp = <span class="keyword">new</span> Singleton;</span><br><span class="line">            <span class="built_in">std</span>::atomic_thread_fence(<span class="built_in">std</span>::memory_order_release);<span class="comment">//释放内存fence</span></span><br><span class="line">            m_instance.store(tmp, <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Singleton要点总结"><a href="#Singleton要点总结" class="headerlink" title="Singleton要点总结"></a>Singleton要点总结</h2><ul>
<li><p>Singleton 模式中的实例构造器可以设置为protected以允许子类派生</p>
</li>
<li><p>Singleton 模式一般不要支持拷贝构造函数和Clone接口，因为这有可能导致多个对象实例，与Singleton初衷违背</p>
</li>
<li><p>多线程环境下需要借助C++11 的原子模式实现</p>
</li>
</ul>
<h1 id="P13-享元模式"><a href="#P13-享元模式" class="headerlink" title="P13. 享元模式"></a>P13. 享元模式</h1><ul>
<li><p>纯粹对象方案的问题在于大量细粒度的对象会很快充斥在系统中</p>
</li>
<li><p>模式定义：运用共享技术有效的支持大量细粒度的对象</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Font</span> &#123;</span><span class="comment">//字体</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> key;<span class="comment">//字体唯一标识</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Font(<span class="keyword">const</span> <span class="built_in">string</span>&amp; key)&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>若为文章中的每个字符创建一个字体，导致大量的重复字体类存在，我们可以定义一个字体的池，当该字体的类对象已经存在于该池内就不用再创建该类对象，这类似于word中的操作</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FontFactory</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,Font* &gt; fontPool;<span class="comment">//字体池   </span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Font* <span class="title">GetFont</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; key)</span></span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>,Font*&gt;::iterator item=fontPool.find(key);</span><br><span class="line">          <span class="keyword">if</span>(item!=footPool.end())&#123;</span><br><span class="line">            <span class="keyword">return</span> fontPool[key];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Font* font = <span class="keyword">new</span> Font(key);</span><br><span class="line">            fontPool[key]= font;</span><br><span class="line">            <span class="keyword">return</span> font;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Flyweight要点总结"><a href="#Flyweight要点总结" class="headerlink" title="Flyweight要点总结"></a>Flyweight要点总结</h2><ul>
<li>面向对象很好的解决了抽象的问题，但是作为一个运行在 机器中的程序实体，我们需要考虑对象的代价问题。Flyweight主要解决面向对象的代价问题，一般不触及面向对象的抽象性问题。</li>
<li>Flyewight采用对象共享的做法来降低系统中对象的个数，从而降低细粒度对象给系统带来的内存压力。在具体实现方面，要注意对象状态的处理。（一般这些对象时只读的，否则可能出现共享出错）</li>
<li>对象的数量多少才算大？这需要我们仔细地根据具体应用情况进行评估，而不能凭空臆断（sizeof）</li>
</ul>
<h1 id="P14-门面模式"><a href="#P14-门面模式" class="headerlink" title="P14. 门面模式"></a>P14. 门面模式</h1><ul>
<li><p>属于接口隔离模式</p>
</li>
<li><p>在组件构建过程中，某些接口之间直接的依赖常常会带来很多问题、甚至无法实现。采用添加一层间接（稳定）接口，来隔离本来互相紧密关联的接口是一种常见的方案</p>
</li>
<li><p>模型定义：为子系统中的一组接口提供一个一致（稳定）的界面，Facade模式定了一个高层接口，这个接口使得这一子系统更加容易使用（复用）。</p>
</li>
<li><p>Facade模式并没有一种具体的代码结构，在现实中的表现差异可能非常大，它表述的是子系统与外界解耦合的思想</p>
</li>
</ul>
<h2 id="Facade要点总结"><a href="#Facade要点总结" class="headerlink" title="Facade要点总结"></a>Facade要点总结</h2><ul>
<li>从客户程序的角度来看，Facade模式简化了整个组件系统的接口，对于接口内部和外部客户程序来说，达到了一种”解耦“的效果——内部子系统的任何变化不会影响到Facade接口的变化。</li>
<li>Facade设计模式更注重从<strong>框架</strong>的层次去看整个系统，而不是单个类的层次。Facade很多时候更是一种框架设计模式。</li>
<li>Facade设计模式并非一个集装箱，可以任意地放进任何多个对象。Facade模型中的组件的内部应该是“相互耦合关系比较大的一系列组件”，而不是一个简单的功能集合。</li>
</ul>
<h1 id="P15-代理模式"><a href="#P15-代理模式" class="headerlink" title="P15. 代理模式"></a>P15. 代理模式</h1><ul>
<li><p>属于接口隔离模式</p>
</li>
<li><p>在面向对象系统中，有些对象由于某种原因(比如创建对象的开销很大，或者某些操作需要安全控制，需要进程外的访问)，直接访问会给使用者、或者系统结构带来很多麻烦。</p>
</li>
<li><p>如何在不失去透明操作对象的同时来管理/控制这些对象特有的复杂性？增加一层间接层是软件开发中常见的解决方式</p>
</li>
<li><p>模式定义: 为其他对象提供一种代理以控制（隔离，使用接口）对这个对象的访问</p>
</li>
</ul>
<h2 id="Proxy要点总结"><a href="#Proxy要点总结" class="headerlink" title="Proxy要点总结"></a>Proxy要点总结</h2><ul>
<li><p>“增加一层间接层”是软件系统中对许多复杂问题的一种常见解决方法。在面向对象系统中，直接使用某些对象会带来很多问题，作间接层的proxy对象便是解决这一问题的常用手段。</p>
</li>
<li><p>具体proxy设计模式的实现方法、实现粒度都相差很大，有些可能对单个对象做细粒度的控制，如copy-on-write技术（string 若是直接复制就是浅拷贝，当需要修改时就拷贝一份修改，这就是一种代理操作），有些可能对组建模块提供抽象代理层，在架构层次对对象做proxy。（很多时候代理模式的代码是由程序生成的）</p>
</li>
<li><p>Proxy并不一定要求保持接口完整的一致性，只要能够实现间接控制，有时候损及一些透明性是可以接受的。</p>
</li>
</ul>
<h1 id="P16-适配器"><a href="#P16-适配器" class="headerlink" title="P16. 适配器"></a>P16. 适配器</h1><ul>
<li><p>属于接口隔离模式</p>
</li>
<li><p>在软件系统中，由于应用环境的变化，常常需要将“一些现存的对象”放在新的环境中应用，但是新环境要求的接口是这些现存对象所不满足的。</p>
</li>
<li><p>如何应对这种“迁移的变化”？如何既能利用现有对象的良好实现，同时又能满足新的应用环境所要求的接口？</p>
</li>
<li><p>模式定义:将一个类的接口转换成客户希望的另一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//目标接口（新接口）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ITarget</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遗留接口（老接口）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IAdaptee</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> data)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">bar</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遗留类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OldClass</span>:</span> <span class="keyword">public</span> IAdaptee&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象适配器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span>:</span> <span class="keyword">public</span> ITarget&#123; <span class="comment">//继承</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    IAdaptee* pAdaptee;<span class="comment">//组合</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Adapter(IAdaptee* pAdaptee)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;pAdaptee=pAdaptee;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> data=pAdaptee-&gt;bar();</span><br><span class="line">        pAdaptee-&gt;foo(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类适配器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span>:</span> <span class="keyword">public</span> ITarget,</span><br><span class="line">               <span class="keyword">protected</span> OldClass&#123; <span class="comment">//多继承,不推荐这样就绑定到oldclass 失去灵活性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IAdaptee* pAdaptee=<span class="keyword">new</span> OldClass();</span><br><span class="line">    ITarget* pTarget=<span class="keyword">new</span> Adapter(pAdaptee);</span><br><span class="line">    pTarget-&gt;process();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Adapter要点总结"><a href="#Adapter要点总结" class="headerlink" title="Adapter要点总结"></a>Adapter要点总结</h2><ul>
<li><p>Adapter模式主要应用于“希望复用一些现存的类，但是接口又与复用环境要求不一致的情况”，在遗留代码复用、类库迁移等方面非常有用。（如stack 和 queue 都是 内含了一个deque）</p>
</li>
<li><p>GoF 23 定义了两种Adapter模式的实现结构：对象适配器和类适配器。但类适配器采用“多继承”的实现方式，一般不推荐使用。对象适配器采用“对象组合”的方式，更符合松耦合精神。</p>
</li>
<li><p>Adapter模式可以实现的非常灵活，不必拘泥于GoF23中定义的两种结构。例如，完全可以将Adapter模式中的“现存对象”作为新的接口方法参数，来达到适配的目的。</p>
</li>
</ul>
<h1 id="P17-中介者模式"><a href="#P17-中介者模式" class="headerlink" title="P17. 中介者模式"></a>P17. 中介者模式</h1><ul>
<li><p>在软件构建过程中，经常会出现多个对象互相关联交互的情况，对象之间常常会维持一种复杂的引用关系，如果遇到一些需求的更改，这种直接的引用关系将面临不断的变化。</p>
</li>
<li><p>在这种情况下，我们可以使用一个“中介对象”来管理对象间的关联关系，避免相互交互的对象之间的紧耦合引用关系，从而更好的抵御变化。</p>
</li>
<li><p>模式变化:用一个中介对象来封装（封装变化）一系列的对象交互。中介者使各对象不需要显式的相互引用（编译时依赖→运行时依赖），从而使其耦合松散（管理变化），而且可以独立地改变它们之间的交互。</p>
</li>
</ul>
<h2 id="Mediator要点总结"><a href="#Mediator要点总结" class="headerlink" title="Mediator要点总结"></a>Mediator要点总结</h2><ul>
<li>将多个对象间复杂的关联关系解耦，Mediator模式将多个对象间的控制逻辑进行集中管理，变“多个对象互相关联”为“多个对象和一个中介者关联”，简化了系统的维护，抵御了可能的变化<br>。</li>
<li><p>随着控制逻辑的复杂化，Mediator具体对象的实现可能相当复杂。这时候可以对Mediator对象进行分界处理。</p>
</li>
<li><p>Facade模式是解耦系统间（单向）的对象关联关系; Mediator模式是解耦系统内各个对象之间（双向）的关联关系。</p>
</li>
</ul>
<h1 id="P19-备忘录"><a href="#P19-备忘录" class="headerlink" title="P19. 备忘录"></a>P19. 备忘录</h1><ul>
<li><p>属于状态变化模式</p>
</li>
<li><p>在软件构建过程中，某些对象的状态在转换过程中，可能由于某种需要，要求程序能够回溯到对象之前处于的某个点时的状态。如果使用一些共有接口来让其他对象得到对象的装填，便会暴露对象的细节实现</p>
</li>
<li><p>模式定义: 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先保存的状态。</p>
</li>
</ul>
<h2 id="Memento-要点总结"><a href="#Memento-要点总结" class="headerlink" title="Memento 要点总结"></a>Memento 要点总结</h2><ul>
<li>备忘录（Memento）存储原发器（Originator）对象的内部状态，在需要时恢复原发器状态。</li>
<li>Memento模式的核心是信息隐藏，即Originator需要向外接隐藏信息，保持其封装性。但同时又需要将状态保持到外界（Memento）。（类似于对对象的深拷贝）</li>
<li>由于现代语言运行时（C#、Java等）都具有相当的对象序列化支持，因此往往采用效率较高、又较容易正确实现的序列化方案来实现Memento模式。（对于有层层指针的类型一般使用序列化的方式，当年受制于变成语言的发展，现代编程语言实现备忘录模式已经有多种方法）</li>
</ul>
<h1 id="P20-组合模式"><a href="#P20-组合模式" class="headerlink" title="P20. 组合模式"></a>P20. 组合模式</h1><ul>
<li><p>属于数据结构模式</p>
</li>
<li><p>软件在某些情况下，客户代码过多依赖于对象容器复杂的内部实现结构，对象容器内部实现结构（而非抽象接口）的变化将引起客户代码的频繁变化，带来了代码的维护性、扩展性等弊端</p>
</li>
<li><p>如何和将“客户代码与复杂的对象容器结构”解耦？让对象容器自己来实现自身的复杂结构，从而使得客户代码就像处理简单对象一样来处理复杂的对象容器？</p>
</li>
<li><p>​ 将对象组合成<strong>树形结构</strong>以表示“部分-整体”的层次结构。Composite使得用户对单个兑现和组合对象的使用具有一致性（稳定）</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Component()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Composite</span> :</span> <span class="keyword">public</span> Component&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">list</span>&lt;Component*&gt; elements;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Composite(<span class="keyword">const</span> <span class="built_in">string</span> &amp; s) : name(s) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Component* element)</span> </span>&#123;</span><br><span class="line">        elements.push_back(element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component* element)</span></span>&#123;</span><br><span class="line">        elements.remove(element);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//1. process current node</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2. process leaf nodes</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;e : elements)</span><br><span class="line">            e-&gt;process(); <span class="comment">//多态调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//叶子节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> :</span> <span class="keyword">public</span> Component&#123;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Leaf(<span class="built_in">string</span> s) : name(s) &#123;&#125;</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//process current node</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Invoke</span><span class="params">(Component &amp; c)</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    c.process();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Composite <span class="title">root</span><span class="params">(<span class="string">&quot;root&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Composite <span class="title">treeNode1</span><span class="params">(<span class="string">&quot;treeNode1&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Composite <span class="title">treeNode2</span><span class="params">(<span class="string">&quot;treeNode2&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Composite <span class="title">treeNode3</span><span class="params">(<span class="string">&quot;treeNode3&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Composite <span class="title">treeNode4</span><span class="params">(<span class="string">&quot;treeNode4&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Leaf <span class="title">leat1</span><span class="params">(<span class="string">&quot;left1&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Leaf <span class="title">leat2</span><span class="params">(<span class="string">&quot;left2&quot;</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    root.add(&amp;treeNode1);</span><br><span class="line">    treeNode1.add(&amp;treeNode2);</span><br><span class="line">    treeNode2.add(&amp;leaf1);</span><br><span class="line">    </span><br><span class="line">    root.add(&amp;treeNode3);</span><br><span class="line">    treeNode3.add(&amp;treeNode4);</span><br><span class="line">    treeNode4.add(&amp;leaf2);</span><br><span class="line">    </span><br><span class="line">    process(root);<span class="comment">//处理根、树、叶都是同样的接口，使用多态的递归调用</span></span><br><span class="line">    process(leaf2);</span><br><span class="line">    process(treeNode3);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Composite要点总结"><a href="#Composite要点总结" class="headerlink" title="Composite要点总结"></a>Composite要点总结</h2><ul>
<li><p>Composite模式采用属性结构来实现普遍存在的对象容器，从而将“一对多”的关系转换为“一对一”的关系，使得客户代码可以一直地（复用）处理对象和对象容器，无需关心处理的是单个还是组合的对象容器。</p>
</li>
<li><p>将“客户代码与复杂的对象容器结构”解耦是Composite的核心思想，解耦之后，客户代码将与纯粹的抽象接口——而非对象容器的内部实现结构——发生依赖，从而更能“应对变化”。</p>
</li>
<li><p>Composite模式在具体视线中，可以让父对象中的子对象反向追溯；如果父对象有频繁的遍历需求，可使用缓存技巧来改善效率。</p>
</li>
</ul>
<h1 id="P21-迭代器"><a href="#P21-迭代器" class="headerlink" title="P21. 迭代器"></a>P21. 迭代器</h1><ul>
<li><p>属于数据结构模式</p>
</li>
<li><p>在软件构建过程中，集合对象内部结构常常变化各异。但对于这些集合对象，我们希望在不暴露其内部结构的同时，可以让外部客户代码透明访问其中包含的元素；同时这种“透明遍历”也为“同一种算法在多种集合对象上进行操作”提供了可能。</p>
</li>
<li><p>使用面向对象技术奖这种遍历机制抽象为“迭代器对象”为“应对变化中的集合对象”提供了一种优雅的方式。</p>
</li>
<li><p>模式定义: 提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露（稳定）该对象的内部表示。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Iterator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">isDone</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> T&amp; <span class="title">current</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCollection</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Iterator&lt;T&gt; <span class="title">GetIterator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollectionIterator</span> :</span> <span class="keyword">public</span> Iterator&lt;T&gt;&#123;</span><br><span class="line">    MyCollection&lt;T&gt; mc;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    CollectionIterator(<span class="keyword">const</span> MyCollection&lt;T&gt; &amp; c): mc(c)&#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">first</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isDone</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T&amp; <span class="title">current</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyAlgorithm</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyCollection&lt;<span class="keyword">int</span>&gt; mc;</span><br><span class="line">    </span><br><span class="line">    Iterator&lt;<span class="keyword">int</span>&gt; iter= mc.GetIterator();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (iter.first(); !iter.isDone(); iter.next())&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iter.current() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Iterator-模式总结"><a href="#Iterator-模式总结" class="headerlink" title="Iterator 模式总结"></a>Iterator 模式总结</h2><ul>
<li><p>迭代抽象：访问一个聚合对象的内容而无需暴露它的内部表示。</p>
</li>
<li><p>迭代多态：为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作。</p>
</li>
<li><p>迭代器的健壮性考虑：遍历的同时更改迭代器所在的集合结构，会导致问题。（许多迭代器要求是只读的）</p>
</li>
<li><p>上述为面向对象的迭代器，现在推荐使用泛型编程的迭代器（编译时确定，而不是运行时的调用），没有虚函数的调用的开销</p>
</li>
</ul>
<h1 id="P22-职责链"><a href="#P22-职责链" class="headerlink" title="P22. 职责链"></a>P22. 职责链</h1><ul>
<li><p>属于数据结构模式</p>
</li>
<li><p>在软件构建过程中，一个请求可能被多个对象处理，但是每个请求运行时只能有一个接受者，如果显式指定，将必不可少地带来请求发送者与接受者的紧耦合。</p>
</li>
<li><p>如何使请求的发送者不需要指定具体的接受者？让请求的接受者自己在运行时决定来处理请求，从而使二者解耦。</p>
</li>
<li><p>模式定义：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止</p>
</li>
</ul>
<h2 id="chain-of-Responsibility-要点总结"><a href="#chain-of-Responsibility-要点总结" class="headerlink" title="chain of Responsibility 要点总结"></a>chain of Responsibility 要点总结</h2><ul>
<li><p>COR模式的应用场合在于“一个请求可能有多个接受者，但是最后真正的接受者只有一个”，这时候请求发送者与接受者的耦合有可能出现“变化脆弱”的症状，职责链的目的就是将二者解耦，从而更好地应对变化。</p>
</li>
<li><p>应用了COR模式后，对象的职责分派将更具灵活性。我们可以在运行时动态添加/修改请求的处理职责。</p>
</li>
<li><p>如果请求传递到职责链的末尾仍得不到处理，应该有一个合理的缺省机制。这也是每个接受对象的责任，而不是发出请求的对象的责任。</p>
</li>
<li><p>随着数据结构的发展，现在这个模式更像是一种数据结构（不怎么流行）</p>
</li>
</ul>
<h1 id="P23-命令模式"><a href="#P23-命令模式" class="headerlink" title="P23. 命令模式"></a>P23. 命令模式</h1><ul>
<li><p>属于行为变化模式</p>
</li>
<li><p>在软件构建过程中，“行为请求者”与“行为实现者“通常呈现一种”紧耦合“。但某些场合——比如需要对行为进行”记录、撤销/重做（undo/redo）、事务”等处理，这种无法抵御变化的紧耦合是不合适的。</p>
</li>
<li><p>在这种情况下，如何将“行为请求者”与“行为实现者”解耦？将一个组行为抽象为对象，可以实现二者之间的松耦合。</p>
</li>
<li><p>模式定义：将一个请求（行为） ，从而使你可用不用的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Command</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand1</span> :</span> <span class="keyword">public</span> Command</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> arg;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ConcreteCommand1(<span class="keyword">const</span> <span class="built_in">string</span> &amp; a) : arg(a) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;#1 process...&quot;</span>&lt;&lt;arg&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand2</span> :</span> <span class="keyword">public</span> Command</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> arg;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ConcreteCommand2(<span class="keyword">const</span> <span class="built_in">string</span> &amp; a) : arg(a) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;#2 process...&quot;</span>&lt;&lt;arg&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MacroCommand</span> :</span> <span class="keyword">public</span> Command</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Command*&gt; commands;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addCommand</span><span class="params">(Command *c)</span> </span>&#123; commands.push_back(c); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : commands)</span><br><span class="line">        &#123;</span><br><span class="line">            c-&gt;execute();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">ConcreteCommand1 <span class="title">command1</span><span class="params">(receiver, <span class="string">&quot;Arg ###&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">ConcreteCommand2 <span class="title">command2</span><span class="params">(receiver, <span class="string">&quot;Arg $$$&quot;</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    MacroCommand macro;</span><br><span class="line">    macro.addCommand(&amp;command1);</span><br><span class="line">    macro.addCommand(&amp;command2);</span><br><span class="line">    </span><br><span class="line">    macro.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Command模式-要点总结"><a href="#Command模式-要点总结" class="headerlink" title="Command模式 要点总结"></a>Command模式 要点总结</h2><ul>
<li><p>Command模式的根本目的在于将“行为请求者”与“行为实现者”解耦，在面向对象语言中，常见的实现手段是<strong>将行为抽象为对象</strong>。</p>
</li>
<li><p>实现Command接口的具体命令对象ConcreteCommand有时候根据需要可能会保存一些额外的状态信息。通过使用Composite模式，可以将多个“命令”封装为一个“复合命令”MacroCommand。</p>
</li>
<li><p>Command模式与C++中的函数对象有些类似。但二者定义行为接口的规范有所区别：Command以面向对象中的“接口-实现”来定义行为接口规范，更严格，但有性能损失；C++函数对象以函数签名来定义行为接口规范，更灵活，性能更高。(因此在C++中，大部分命令模式被仿函数代替)</p>
</li>
</ul>
<h1 id="P24-访问器"><a href="#P24-访问器" class="headerlink" title="P24. 访问器"></a>P24. 访问器</h1><ul>
<li>在软件构建过程中，由于需求的变化，某些类层次结构中常常需要增加新的行为（方法），如果直接在基类中做这样的更改，将会给子类带来很繁重的变更负担，甚至破坏原有设计。</li>
<li>如何在不更改类层次结构的前提下，在运行时根据需要透明地为类层次结构上的各个类动态添加新的操作，从而避免上述问题？</li>
</ul>
<p>​- 模式定义:表示一个作用于某对象结构中的各元素的操作。使得可以在不改变（稳定）各元素的类的前提下定义（扩展）作用于这些元素的新车操作（变化）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Visitor</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Element</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor&amp; visitor)</span> </span>= <span class="number">0</span>; <span class="comment">//第一次多态辨析</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~Element()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElementA</span> :</span> <span class="keyword">public</span> Element</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor &amp;visitor)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        visitor.visitElementA(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElementB</span> :</span> <span class="keyword">public</span> Element</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor &amp;visitor)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        visitor.visitElementB(*<span class="keyword">this</span>); <span class="comment">//第二次多态辨析</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Visitor</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">visitElementA</span><span class="params">(ElementA&amp; element)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">visitElementB</span><span class="params">(ElementB&amp; element)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">virtual</span> ~Visitor()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//==================================这里要求上面的东西都不变，这在现实中往往很难办到</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//扩展1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Visitor1</span> :</span> <span class="keyword">public</span> Visitor&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visitElementA</span><span class="params">(ElementA&amp; element)</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Visitor1 is processing ElementA&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visitElementB</span><span class="params">(ElementB&amp; element)</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Visitor1 is processing ElementB&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">     </span><br><span class="line"><span class="comment">//扩展2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Visitor2</span> :</span> <span class="keyword">public</span> Visitor&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visitElementA</span><span class="params">(ElementA&amp; element)</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Visitor2 is processing ElementA&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visitElementB</span><span class="params">(ElementB&amp; element)</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Visitor2 is processing ElementB&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Visitor2 visitor;</span><br><span class="line">    ElementB elementB;</span><br><span class="line">    elementB.accept(visitor);<span class="comment">// double dispatch</span></span><br><span class="line">    </span><br><span class="line">    ElementA elementA;</span><br><span class="line">    elementA.accept(visitor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Visitor-要点总结"><a href="#Visitor-要点总结" class="headerlink" title="Visitor 要点总结"></a>Visitor 要点总结</h2><ul>
<li><p>Visitor模式通过所谓双重分发（double dispatch）来实现在不更改（不添加心的操作-编译时）Element类层次结构的前提下，在运行时透明地为类层次结构上的各个类动态添加新的操作（支持变化）</p>
</li>
<li><p>所谓双重分发即Visitor模式中间包括了两个多态分发（注意其中的多态机制）：第一个为accept方法的多态辨析；第二个为visitElementX方法的多态辨析。</p>
</li>
<li><p>Visitor模式的最大缺点在于扩展类层次结构（增添新的Element子类），会导致Visitor类的改变。因此Visitor模式适用于“Element类<strong>层次结构稳定</strong>，而其中的<strong>操作却经常面临频繁改动</strong>”。</p>
</li>
</ul>
<h1 id="P25-解析器"><a href="#P25-解析器" class="headerlink" title="P25. 解析器"></a>P25. 解析器</h1><ul>
<li><p>属于领域规则模式</p>
</li>
<li><p>在软件构建过程中，如果某一特定领域的问题比较复杂，类似的结构不断重复出现，如果使用普通的编程方式来实现将面临非常频繁的变化。</p>
</li>
<li><p>在这种情况下，将特定领域的问题表达为某种语法规则下的句子，然后构建一个解释器来解释这样的句子，从而达到解决问题的目的。</p>
</li>
<li><p>模式定义： 给定一个语言，定义它的文法的一种表示，并定义一种解释器，这个解释器使用该表示来解释语言中的句子。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Expression</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">interpreter</span><span class="params">(<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; var)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Expression()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//变量表达式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VarExpression</span>:</span> <span class="keyword">public</span> Expression &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> key;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    VarExpression(<span class="keyword">const</span> <span class="keyword">char</span>&amp; key)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;key = key;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">interpreter</span><span class="params">(<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; var)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> var[key];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//符号表达式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SymbolExpression</span> :</span> <span class="keyword">public</span> Expression &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 运算符左右两个参数</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Expression* left;</span><br><span class="line">    Expression* right;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SymbolExpression( Expression* left,  Expression* right):</span><br><span class="line">        left(left),right(right)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加法运算</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddExpression</span> :</span> <span class="keyword">public</span> SymbolExpression &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    AddExpression(Expression* left, Expression* right):</span><br><span class="line">        SymbolExpression(left,right)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">interpreter</span><span class="params">(<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; var)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left-&gt;interpreter(var) + right-&gt;interpreter(var);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减法运算</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubExpression</span> :</span> <span class="keyword">public</span> SymbolExpression &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SubExpression(Expression* left, Expression* right):</span><br><span class="line">        SymbolExpression(left,right)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">interpreter</span><span class="params">(<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; var)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left-&gt;interpreter(var) - right-&gt;interpreter(var);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Expression*  <span class="title">analyse</span><span class="params">(<span class="built_in">string</span> expStr)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">stack</span>&lt;Expression*&gt; expStack;</span><br><span class="line">    Expression* left = <span class="literal">nullptr</span>;</span><br><span class="line">    Expression* right = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;expStr.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(expStr[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                <span class="comment">// 加法运算</span></span><br><span class="line">                left = expStack.top();</span><br><span class="line">                right = <span class="keyword">new</span> VarExpression(expStr[++i]);</span><br><span class="line">                expStack.push(<span class="keyword">new</span> AddExpression(left, right));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                <span class="comment">// 减法运算</span></span><br><span class="line">                left = expStack.top();</span><br><span class="line">                right = <span class="keyword">new</span> VarExpression(expStr[++i]);</span><br><span class="line">                expStack.push(<span class="keyword">new</span> SubExpression(left, right));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// 变量表达式</span></span><br><span class="line">                expStack.push(<span class="keyword">new</span> VarExpression(expStr[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    Expression* expression = expStack.top();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> expression;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">(Expression* expression)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放表达式树的节点内存...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">string</span> expStr = <span class="string">&quot;a+b-c+d-e&quot;</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; var;</span><br><span class="line">    var.insert(<span class="built_in">make_pair</span>(<span class="string">&#x27;a&#x27;</span>,<span class="number">5</span>));</span><br><span class="line">    var.insert(<span class="built_in">make_pair</span>(<span class="string">&#x27;b&#x27;</span>,<span class="number">2</span>));</span><br><span class="line">    var.insert(<span class="built_in">make_pair</span>(<span class="string">&#x27;c&#x27;</span>,<span class="number">1</span>));</span><br><span class="line">    var.insert(<span class="built_in">make_pair</span>(<span class="string">&#x27;d&#x27;</span>,<span class="number">6</span>));</span><br><span class="line">    var.insert(<span class="built_in">make_pair</span>(<span class="string">&#x27;e&#x27;</span>,<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    Expression* expression= analyse(expStr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> result=expression-&gt;interpreter(var);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;result&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    release(expression);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Interpreter-要点总结"><a href="#Interpreter-要点总结" class="headerlink" title="Interpreter 要点总结"></a>Interpreter 要点总结</h2><ul>
<li><p>Interpreter模式的应用场合是Interpreter模式应用中的难点，只有满足“业务规则频繁变化，且类似的结构不断重复出现，并且容易抽象为语法规则的问题”才适合使用此模式</p>
</li>
<li><p>使用此模式来表示文法规则，从而可以使用面向对象技巧来方便地“扩展”文法</p>
</li>
<li><p>此模式比较适合<strong>简单的文法表示</strong>，对于复杂的文法表示，此模式会产生比较大的类层次结构，需要求助于语法分析生成器这样的标准工具。</p>
</li>
</ul>
<h1 id="P26-设计模式总结"><a href="#P26-设计模式总结" class="headerlink" title="P26. 设计模式总结"></a>P26. 设计模式总结</h1><ul>
<li><p>管理变化，提高复用</p>
</li>
<li><p>两种手段：分解和抽象</p>
</li>
<li><p>从封装变化角度分类</p>
<ul>
<li>组件协作：模板方法、策略模式、观察者</li>
<li>单一职责：装饰器、桥模式</li>
<li>对象创建：工厂模式、抽象工厂、原型模式、建造者模式（不常用）</li>
<li>对象性能：单体模式、享元模式</li>
<li>接口隔离：门面模式、代理模式、中介者模式（不常用）、适配器模式</li>
<li>状态变化：备忘录模式、状态模式</li>
<li>数据结构：组合模式、迭代器模式（不常用），职责链（不常用）</li>
<li>领域问题：解析器模式（不常用）</li>
</ul>
</li>
<li><p>大部分设计模式的类结构都是A类内有一个指向B类的指针（B应该是基类，以此实现多态调用，实现松耦合）</p>
</li>
</ul>
<h2 id="什么时候不用设计模式"><a href="#什么时候不用设计模式" class="headerlink" title="什么时候不用设计模式"></a>什么时候不用设计模式</h2><ul>
<li>代码可读性很差时</li>
<li>需求理解还很浅时</li>
<li>变化没有显现时</li>
<li>不是系统的关键依赖点</li>
<li>项目没有复用价值时</li>
<li>项目将要发布时</li>
</ul>
<h2 id="经验之谈"><a href="#经验之谈" class="headerlink" title="经验之谈"></a>经验之谈</h2><ul>
<li>不要为模式而模式</li>
<li>关注抽象类 &amp; 接口</li>
<li>理清变化点和稳定点</li>
<li>审视依赖关系</li>
<li>要求Framework 和 Application 的区隔思维</li>
<li>良好的设计是演化的结果</li>
</ul>
<h2 id="设计模式成长之路"><a href="#设计模式成长之路" class="headerlink" title="设计模式成长之路"></a>设计模式成长之路</h2><p>“手中无剑，心中无剑” ： 见模式而不知<br>“手中有剑，心中无剑” ：可以识别模式，作为应用开发人员模式<br>“手中有剑，心中有剑” ： 作为框架开发人员为应用设计某些模式<br>“手中无剑，心中有剑” ： 忘掉模式，只有原则</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/11/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lclee">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog-lclee">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/11/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">C++内存管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-02-11 13:02:58" itemprop="dateCreated datePublished" datetime="2021-02-11T13:02:58+08:00">2021-02-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-02-26 18:49:51" itemprop="dateModified" datetime="2021-02-26T18:49:51+08:00">2021-02-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="P1-overview"><a href="#P1-overview" class="headerlink" title="P1. overview"></a>P1. overview</h1><ul>
<li>第一讲 primitives 基础工具</li>
<li>第二讲 malloc/free</li>
<li>第三讲 std::allocator</li>
<li>第四讲 other allocator</li>
<li>第五讲 loki::allocator</li>
</ul>
<h1 id="P2-内存分配的每一层面"><a href="#P2-内存分配的每一层面" class="headerlink" title="P2. 内存分配的每一层面"></a>P2. 内存分配的每一层面</h1><ol>
<li><p>C++ Application</p>
</li>
<li><p>C++ Library std::allocator</p>
</li>
<li><p>C++ primitives new,new[], new(),::operator new()</p>
</li>
<li><p>CRT malloc/free</p>
</li>
<li><p>OS.API  HeapAlloc, VirtualAlloc</p>
</li>
</ol>
<ul>
<li>编程一般操作1-4，若调用系统API就跟系统绑定在一起，不具备移植性</li>
</ul>
<h1 id="P3-四个层面基本用法"><a href="#P3-四个层面基本用法" class="headerlink" title="P3.四个层面基本用法"></a>P3.四个层面基本用法</h1><div class="table-container">
<table>
<thead>
<tr>
<th>分配</th>
<th>释放</th>
<th>属类</th>
<th>可否重载</th>
</tr>
</thead>
<tbody>
<tr>
<td> malloc()</td>
<td>free()</td>
<td>C函数</td>
<td>不可</td>
</tr>
<tr>
<td> new</td>
<td>delete</td>
<td>C++表达式</td>
<td>不可</td>
</tr>
<tr>
<td> ::operator new()</td>
<td>operator delete()</td>
<td>C++函数</td>
<td>可</td>
</tr>
<tr>
<td> allocator\<T>::allocate()</T></td>
<td>allocator\<T>::deallocate()</T></td>
<td>C++标准库</td>
<td>可自由设计并搭配容器</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* p1 = <span class="built_in">malloc</span>(<span class="number">512</span>);<span class="comment">//512 bytes</span></span><br><span class="line"><span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">complex</span>&lt;<span class="keyword">int</span>&gt;* p2 <span class="keyword">new</span> <span class="built_in">complex</span>&lt;<span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">delete</span> P2</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> p3 :: <span class="function"><span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="number">512</span>)</span></span>;<span class="comment">//512 bytes</span></span><br><span class="line">::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(p3)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* p4 = allocator&lt;<span class="keyword">int</span>&gt;().allocate(<span class="number">7</span>);<span class="comment">// 分配7个int</span></span><br><span class="line">allocator&lt;<span class="keyword">int</span>&gt;().deallocate((<span class="keyword">int</span>*)p4,<span class="number">7</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="P4-基本构建一-new-delete-expression-上"><a href="#P4-基本构建一-new-delete-expression-上" class="headerlink" title="P4. 基本构建一 new delete expression 上"></a>P4. 基本构建一 new delete expression 上</h1><p><code>Complex* pc = new Complex(1,2);</code> 会被编译器转为以下程序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Complex *pc;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *mem = <span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(Complex));</span><br><span class="line">    pc = <span class="keyword">static_cast</span>&lt;Complex*&gt;(mem);</span><br><span class="line">    pc-&gt;Complex::Complex(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//只有编译器可以这样直接调用ctor</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(<span class="built_in">std</span>::bad_alloc)&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>operator new() 可以被重载，实现自定义的内存管理</p>
</li>
<li><p>默认的 operator new() 中调用 <code>malloc</code> 申请内存，若申请失败会调用 <code>cllnewh</code> ，这个函数用户可以用来定义一些可以释放的变量，以便进行申请内存。</p>
</li>
<li><p>直接调用ctor 要用placement new <code>new(p) Complex(1,2);</code></p>
</li>
</ul>
<h1 id="P5-基本构建一-new-delete-expression-中"><a href="#P5-基本构建一-new-delete-expression-中" class="headerlink" title="P5. 基本构建一 new delete expression 中"></a>P5. 基本构建一 new delete expression 中</h1><ul>
<li>delete 被编译器转为 析构函数和 operator delete，operator delete内部调用free</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Complex* pc <span class="keyword">new</span> <span class="title">Complex</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> pc;</span><br></pre></td></tr></table></figure>
<p>被编译器转为下面</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pc-&gt;~Complex();</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(pc)</span></span>;<span class="comment">//内部调用free</span></span><br></pre></td></tr></table></figure>
<p>我们不能直接调用构造函数，但是可以直接调用析构函数。</p>
<h1 id="P6-基本构建一-new-delete-expression-下"><a href="#P6-基本构建一-new-delete-expression-下" class="headerlink" title="P6. 基本构建一 new delete expression 下"></a>P6. 基本构建一 new delete expression 下</h1><ul>
<li>测试 无法直接调用ctor</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A* pA = <span class="keyword">new</span> A(<span class="number">1</span>);         <span class="comment">//ctor. this=000307A8 id=1</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pA-&gt;id &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//1</span></span><br><span class="line"><span class="comment">//pA-&gt;A::A(3);                //in VC6 : ctor. this=000307A8 id=3</span></span><br><span class="line">                            <span class="comment">//in GCC : [Error] cannot call constructor &#x27;jj02::A::A&#x27; directly</span></span><br></pre></td></tr></table></figure>
<h1 id="P7-Array-new"><a href="#P7-Array-new" class="headerlink" title="P7. Array new"></a>P7. Array new</h1><ul>
<li>array new 的构造函数要有默认值，在array new 中无法赋初值</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Complex* pca = <span class="keyword">new</span> Complex[<span class="number">3</span>];<span class="comment">//构造函数要有默认值，无法借由参数给予初值</span></span><br><span class="line"><span class="keyword">delete</span>[] pca;<span class="comment">//调用三次析构函数</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>array new 需要搭配 array delete,否则只会调用一次析构函数。</p>
</li>
<li><p>对于不含指针的对象没有什么影响，对含有指针的对象会造成内存泄漏（只释放了一个对象申请的内存，二删除了整个数组，导致这个部分内存无法再被使用）</p>
</li>
<li><p>若 array new 的对象的dtor需要释放内存，则申请的内存空间中会记录对象的数目，array delete 时依次析构。</p>
</li>
</ul>
<h1 id="P8-placement-new"><a href="#P8-placement-new" class="headerlink" title="P8. placement new"></a>P8. placement new</h1><ul>
<li>placement new 定点的new，允许我们将 <code>obj</code> 构建在已经分配好的内存中,下面第二行</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* buf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="keyword">sizeof</span>(Complex)*<span class="number">3</span>];</span><br><span class="line"><span class="function">Complex* pc <span class="title">new</span><span class="params">(buf)</span><span class="title">Complex</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span>[] buf;</span><br></pre></td></tr></table></figure>
<h1 id="P9-重载"><a href="#P9-重载" class="headerlink" title="P9. 重载"></a>P9. 重载</h1><ul>
<li>一般的应用程序 <code>new</code> <code>-&gt; ``operator new()</code> <code>-&gt;</code> <code>::operator new()</code> 可以在类内重载 <code>Foo:: operator new()</code> 实现自定义的内存管理，一般很少去动用全局的 <code>::operator new()</code></li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* <span class="keyword">size_t</span>)</span><span class="comment">//第二参数为可选参数</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="P10-重载示例（上）"><a href="#P10-重载示例（上）" class="headerlink" title="P10. 重载示例（上）"></a>P10. 重载示例（上）</h1><ul>
<li>operator new 需要是静态的，出于人性化考虑可以不加</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> _id;</span><br><span class="line">  <span class="keyword">long</span> _data;</span><br><span class="line">  <span class="built_in">string</span> _str;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>  <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* deadObject, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span> size);</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span>  <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span>* deadObject, <span class="keyword">size_t</span> size);</span><br><span class="line">  </span><br><span class="line">  Foo() : _id(<span class="number">0</span>)      &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;default ctor. this=&quot;</span>  &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; id=&quot;</span> &lt;&lt; _id &lt;&lt; <span class="built_in">endl</span>;  &#125;</span><br><span class="line">  Foo(<span class="keyword">int</span> i) : _id(i) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ctor. this=&quot;</span>  &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; id=&quot;</span> &lt;&lt; _id &lt;&lt; <span class="built_in">endl</span>;  &#125;</span><br><span class="line">  <span class="comment">//virtual </span></span><br><span class="line">  ~Foo()              &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;dtor. this=&quot;</span>  &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; id=&quot;</span> &lt;&lt; _id &lt;&lt; <span class="built_in">endl</span>;  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//不加 virtual dtor, sizeof = 12, new Foo[5] =&gt; operator new[]() 的 size 參數是 64, </span></span><br><span class="line">  <span class="comment">//加了 virtual dtor, sizeof = 16, new Foo[5] =&gt; operator new[]() 的 size 參數是 84, </span></span><br><span class="line">  <span class="comment">//上述二例，多出來的 4 可能就是個 size_t 欄位用來放置 array size. </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* Foo::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo* p = (Foo*)<span class="built_in">malloc</span>(size);  </span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Foo::operator new(), size=&quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot;\t  return: &quot;</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span>;   </span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> Foo::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* pdead, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Foo::operator delete(), pdead= &quot;</span> &lt;&lt; pdead &lt;&lt; <span class="string">&quot;  size= &quot;</span> &lt;&lt; size &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> <span class="built_in">free</span>(pdead);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="P11-重载示例-（下）"><a href="#P11-重载示例-（下）" class="headerlink" title="P11. 重载示例 （下）"></a>P11. 重载示例 （下）</h1><ul>
<li><p><code>operator new()</code> 可以写出多个版本，需要声明独特的参数列，且第一参数必须为 <code>size_t</code>,调用的时候括号里直接写第二个参数即可(第二个代码块)</p>
</li>
<li><p><code>operator delete()</code> 也可以写出多个版本，但是只有相对应的 <code>operator new()</code> 构造抛出异常时，才会调用对应的 <code>delete</code></p>
</li>
<li><p>原则上 每个版本的 <code>operator new()</code> 都要有与之对应的 <code>operator delete()</code>,但是没有写也不会报错，表示放弃对ctor的异常处理。（有的平台没有写对应版本的delete 会有警告）</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Foo() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Foo::Foo()&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    Foo(<span class="keyword">int</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Foo::Foo(int)&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      <span class="comment">// throw Bad();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(1) 這個就是一般的 operator new() 的重載</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;operator new(size_t size), size= &quot;</span> &lt;&lt; size &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(2) 這個就是標準庫已經提供的 placement new() 的重載 (形式)</span></span><br><span class="line">    <span class="comment">//    (所以我也模擬 standard placement new 的動作, just return ptr)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">void</span> *start)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;operator new(size_t size, void* start), size= &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot;  start= &quot;</span> &lt;&lt; start &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(3) 這個才是嶄新的 placement new</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">long</span> extra)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;operator new(size_t size, long extra)  &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; extra &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">malloc</span>(size + extra);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(4) 這又是一個 placement new</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">long</span> extra, <span class="keyword">char</span> init)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;operator new(size_t size, long extra, char init)  &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; extra &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; init &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">malloc</span>(size + extra);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Foo *p1 = <span class="keyword">new</span> Foo;        <span class="comment">//op-new(size_t)</span></span><br><span class="line">Foo *p2 = <span class="keyword">new</span> (&amp;start) Foo;    <span class="comment">//op-new(size_t,void*)</span></span><br><span class="line">Foo *p3 = <span class="keyword">new</span> (<span class="number">100</span>) Foo;    <span class="comment">//op-new(size_t,long)</span></span><br><span class="line">Foo *p4 = <span class="keyword">new</span> (<span class="number">100</span>, <span class="string">&#x27;a&#x27;</span>) Foo; <span class="comment">//op-new(size_t,long,char)</span></span><br><span class="line"></span><br><span class="line">Foo *p5 = <span class="keyword">new</span> (<span class="number">100</span>) Foo(<span class="number">1</span>);     <span class="comment">//op-new(size_t,long)  op-del(void*,long)</span></span><br><span class="line">Foo *p6 = <span class="keyword">new</span> (<span class="number">100</span>, <span class="string">&#x27;a&#x27;</span>) Foo(<span class="number">1</span>); <span class="comment">//</span></span><br><span class="line">Foo *p7 = <span class="keyword">new</span> (&amp;start) Foo(<span class="number">1</span>);   <span class="comment">//</span></span><br><span class="line">Foo *p8 = <span class="keyword">new</span> Foo(<span class="number">1</span>);       <span class="comment">//</span></span><br></pre></td></tr></table></figure>
<h1 id="P12-per-class-allocator"><a href="#P12-per-class-allocator" class="headerlink" title="P12. per-class allocator"></a>P12. per-class allocator</h1><ul>
<li><p>当需要多次 new obj 时，可以设计接管 operator new() 一次申请一大块空间，需要时直接分配，无需每次 <code>malloc</code>。同时可以减少维护的cookie，提高内存利用率。</p>
</li>
<li><p>版本一：类内变量由指针和数据构成，首次获取一大块内存，用指针连城链表进行维护</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   Screen(<span class="keyword">int</span> x) : i(x)&#123;&#125;;</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *, <span class="keyword">size_t</span>)</span></span>; <span class="comment">//(2)</span></span><br><span class="line">   <span class="comment">//! void  operator delete(void*);      //(1) 二擇一. 若(1)(2)並存,會有很奇怪的報錯 (摸不著頭緒)</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">   Screen *next;</span><br><span class="line">   <span class="keyword">static</span> Screen *freeStore;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> screenChunk;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line"> &#125;;</span><br><span class="line"> Screen *Screen::freeStore = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">const</span> <span class="keyword">int</span> Screen::screenChunk = <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> *Screen::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">   Screen *p;</span><br><span class="line">   <span class="keyword">if</span> (!freeStore)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="comment">//linked list 是空的，所以攫取一大塊 memory</span></span><br><span class="line">     <span class="comment">//以下呼叫的是 global operator new</span></span><br><span class="line">     <span class="keyword">size_t</span> chunk = screenChunk * size;</span><br><span class="line">     freeStore = p =</span><br><span class="line">       <span class="keyword">reinterpret_cast</span>&lt;Screen *&gt;(<span class="keyword">new</span> <span class="keyword">char</span>[chunk]);</span><br><span class="line">     <span class="comment">//將分配得來的一大塊 memory 當做 linked list 般小塊小塊串接起來</span></span><br><span class="line">     <span class="keyword">for</span> (; p != &amp;freeStore[screenChunk - <span class="number">1</span>]; ++p)</span><br><span class="line">       p-&gt;next = p + <span class="number">1</span>;</span><br><span class="line">     p-&gt;next = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   p = freeStore;</span><br><span class="line">   freeStore = freeStore-&gt;next;</span><br><span class="line">   <span class="keyword">return</span> p;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//! void Screen::operator delete(void *p)    //(1)</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> Screen::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *p, <span class="keyword">size_t</span>)</span> <span class="comment">//(2)二擇一</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">   <span class="comment">//將 deleted object 收回插入 free list 前端</span></span><br><span class="line"> (<span class="keyword">static_cast</span>&lt;Screen *&gt;(p))-&gt;next = freeStore;</span><br><span class="line">   freeStore = <span class="keyword">static_cast</span>&lt;Screen *&gt;(p);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//! void Screen::operator delete(void *p)    //(1)</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> Screen::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *p, <span class="keyword">size_t</span>)</span> <span class="comment">//(2)二擇一</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">   <span class="comment">//將 deleted object 收回插入 free list 前端</span></span><br><span class="line">   (<span class="keyword">static_cast</span>&lt;Screen *&gt;(p))-&gt;next = freeStore;</span><br><span class="line">   freeStore = <span class="keyword">static_cast</span>&lt;Screen *&gt;(p);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="P13-per-class-allocator-2"><a href="#P13-per-class-allocator-2" class="headerlink" title="P13. per-class allocator 2"></a>P13. per-class allocator 2</h1><ul>
<li><p>使用 <code>struct</code> 包装所有数据（第 <code>7</code> 行），使用 <code>union</code> 将数据和指针进行联合（<code>14</code>行），这种设计成为嵌入式指针</p>
</li>
<li><p>初始化后，未使用数据用指针相连形成链表</p>
</li>
<li><p>相较于上个版本，使用 <code>union</code> 联合，除去维护用的指针（未被使用的内存用指针串联，需要分配对象的内存用户会声明指针变量，因此数据和指针不会同时存在可用 <code>union</code>节省内存空间）</p>
</li>
<li><p>第 <code>44</code> 行 判断是否发生继承</p>
</li>
<li><p>这个版本的缺陷在于 <code>operator delete()</code> 中 没有 <code>free</code>，（程序 new 100000 个 obj，用完之后delete，但是没有将内存还给操作系统）</p>
</li>
</ul>
<figure class="highlight cpp"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ref. Effective C++ 2e, item10</span></span><br><span class="line"><span class="comment">//per-class allocator</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airplane</span></span></span><br><span class="line"><span class="class">&#123;</span> <span class="comment">//支援 customized memory management</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">AirplaneRep</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> miles;</span><br><span class="line">    <span class="keyword">char</span> type;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    AirplaneRep rep; <span class="comment">//此針對 used object</span></span><br><span class="line">    Airplane *next;   <span class="comment">//此針對 free list</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">getMiles</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> rep.miles; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">char</span> <span class="title">getType</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> rep.type; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> m, <span class="keyword">char</span> t)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    rep.miles = m;</span><br><span class="line">    rep.type = t;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *deadObject, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> BLOCK_SIZE;</span><br><span class="line">  <span class="keyword">static</span> Airplane *headOfFreeList;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Airplane *Airplane::headOfFreeList;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Airplane::BLOCK_SIZE = <span class="number">512</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *Airplane::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//如果大小錯誤，轉交給 ::operator new()</span></span><br><span class="line">  <span class="keyword">if</span> (size != <span class="keyword">sizeof</span>(Airplane))</span><br><span class="line">    <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="keyword">new</span>(size);</span><br><span class="line"></span><br><span class="line">  Airplane *p = headOfFreeList;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果 p 有效，就把list頭部移往下一個元素</span></span><br><span class="line">  <span class="keyword">if</span> (p)</span><br><span class="line">    headOfFreeList = p-&gt;next;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//free list 已空。配置一塊夠大記憶體，</span></span><br><span class="line">    <span class="comment">//令足夠容納 BLOCK_SIZE 個 Airplanes</span></span><br><span class="line">    Airplane *newBlock = <span class="keyword">static_cast</span>&lt;Airplane *&gt;(::<span class="keyword">operator</span> <span class="keyword">new</span>(BLOCK_SIZE * <span class="keyword">sizeof</span>(Airplane)));</span><br><span class="line">    <span class="comment">//組成一個新的 free list：將小區塊串在一起，但跳過</span></span><br><span class="line">    <span class="comment">//#0 元素，因為要將它傳回給呼叫者。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; BLOCK_SIZE - <span class="number">1</span>; ++i)</span><br><span class="line">      newBlock[i].next = &amp;newBlock[i + <span class="number">1</span>];</span><br><span class="line">    newBlock[BLOCK_SIZE - <span class="number">1</span>].next = <span class="number">0</span>; <span class="comment">//以null結束</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 將 p 設至頭部，將 headOfFreeList 設至</span></span><br><span class="line">    <span class="comment">// 下一個可被運用的小區塊。</span></span><br><span class="line">    p = newBlock;</span><br><span class="line">    headOfFreeList = &amp;newBlock[<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// operator delete 接獲一塊記憶體。</span></span><br><span class="line"><span class="comment">// 如果它的大小正確，就把它加到 free list 的前端</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> Airplane::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *deadObject,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (deadObject == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (size != <span class="keyword">sizeof</span>(Airplane))</span><br><span class="line">  &#123;</span><br><span class="line">    ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(deadObject)</span></span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Airplane *carcass =</span><br><span class="line">    <span class="keyword">static_cast</span>&lt;Airplane *&gt;(deadObject);</span><br><span class="line"></span><br><span class="line">  carcass-&gt;next = headOfFreeList;</span><br><span class="line">  headOfFreeList = carcass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="P14-static-allocator"><a href="#P14-static-allocator" class="headerlink" title="P14. static allocator"></a>P14. static allocator</h1><ul>
<li>可以为每个需要的类写之内存管理，但是每个类都会有大量重复的代码，因此可以将这种操作独立出来写一个类</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">allocator</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">obj</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">obj</span> *<span class="title">next</span>;</span> <span class="comment">//embedded pointer</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *, <span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    obj *freeStore = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> CHUNK = <span class="number">5</span>; <span class="comment">//小一點方便觀察</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> *<span class="title">allocator::allocate</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    obj *p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!freeStore)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//linked list 是空的，所以攫取一大塊 memory</span></span><br><span class="line">      <span class="keyword">size_t</span> chunk = CHUNK * size;</span><br><span class="line">      freeStore = p = (obj *)<span class="built_in">malloc</span>(chunk);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//cout &lt;&lt; &quot;empty. malloc: &quot; &lt;&lt; chunk &lt;&lt; &quot;  &quot; &lt;&lt; p &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//將分配得來的一大塊當做 linked list 般小塊小塊串接起來</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (CHUNK - <span class="number">1</span>); ++i)</span><br><span class="line">      &#123; <span class="comment">//沒寫很漂亮, 不是重點無所謂.</span></span><br><span class="line">        p-&gt;next = (obj *)((<span class="keyword">char</span> *)p + size);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line">      p-&gt;next = <span class="literal">nullptr</span>; <span class="comment">//last</span></span><br><span class="line">    &#125;</span><br><span class="line">    p = freeStore;</span><br><span class="line">    freeStore = freeStore-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//cout &lt;&lt; &quot;p= &quot; &lt;&lt; p &lt;&lt; &quot;  freeStore= &quot; &lt;&lt; freeStore &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">allocator::deallocate</span><span class="params">(<span class="keyword">void</span> *p, <span class="keyword">size_t</span>)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">//將 deleted object 收回插入 free list 前端</span></span><br><span class="line">    ((obj *)p)-&gt;next = freeStore;</span><br><span class="line">    freeStore = (obj *)p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">allocator::check</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    obj *p = freeStore;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      p = p-&gt;next;</span><br><span class="line">      count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//--------------</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">long</span> L;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">static</span> allocator myAlloc;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Foo(<span class="keyword">long</span> l) : L(l) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> myAlloc.allocate(size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *pdead, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> myAlloc.deallocate(pdead, size);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  allocator Foo::myAlloc;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Goo</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; c;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">static</span> allocator myAlloc;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Goo(<span class="keyword">const</span> <span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; &amp;x) : c(x) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> myAlloc.allocate(size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *pdead, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> myAlloc.deallocate(pdead, size);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  allocator Goo::myAlloc;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//-------------</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">test_static_allocator_3</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n\n\ntest_static_allocator().......... \n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">      Foo *p[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sizeof(Foo)= &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(Foo) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">23</span>; ++i)</span><br><span class="line">      &#123; <span class="comment">//23,任意數, 隨意看看結果</span></span><br><span class="line">        p[i] = <span class="keyword">new</span> Foo(i);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p[i] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p[i]-&gt;L &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//Foo::myAlloc.check();</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">23</span>; ++i)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">delete</span> p[i];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//Foo::myAlloc.check();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">      Goo *p[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sizeof(Goo)= &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(Goo) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">17</span>; ++i)</span><br><span class="line">      &#123; <span class="comment">//17,任意數, 隨意看看結果</span></span><br><span class="line">        p[i] = <span class="keyword">new</span> Goo(<span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt;(i, i));</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p[i] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p[i]-&gt;c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//Goo::myAlloc.check();</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">17</span>; ++i)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">delete</span> p[i];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//Goo::myAlloc.check();</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>相较于之前的设计，这里application classes 与内存不再纠缠不清，所有与内存相关的细节都让<code>allocator</code>去操作。</p>
</li>
<li><p>这样无需为每个类单独设计内存管理，这里的内存管理是类内的一个静态变量</p>
</li>
</ul>
<h1 id="P15-macro-for-static-allocator"><a href="#P15-macro-for-static-allocator" class="headerlink" title="P15. macro for static allocator"></a>P15. macro for static allocator</h1><ul>
<li>每个类中都有很多相同的部分，因此用宏展开，代码更为简洁</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//借鏡 MFC macros.</span></span><br><span class="line"><span class="comment">// DECLARE_POOL_ALLOC -- used in class definition</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_POOL_ALLOC()                                           \</span></span><br><span class="line"><span class="keyword">public</span>:                                                                \</span><br><span class="line">  <span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123; <span class="keyword">return</span> myAlloc.allocate(size); &#125; \</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123; myAlloc.deallocate(p, <span class="number">0</span>); &#125;        \</span><br><span class="line">                                                                       \</span><br><span class="line"><span class="keyword">protected</span>:                                                             \</span><br><span class="line">  <span class="keyword">static</span> allocator myAlloc;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IMPLEMENT_POOL_ALLOC -- used in class implementation file</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPLEMENT_POOL_ALLOC(class_name) \</span></span><br><span class="line">  allocator class_name::myAlloc;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// in class definition file</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    DECLARE_POOL_ALLOC()</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">long</span> L;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Foo(<span class="keyword">long</span> l) : L(l) &#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//in class implementation file</span></span><br><span class="line">  IMPLEMENT_POOL_ALLOC(Foo)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  in class definition file</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Goo</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    DECLARE_POOL_ALLOC()</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; c;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Goo(<span class="keyword">const</span> <span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; &amp;x) : c(x) &#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//in class implementation file</span></span><br><span class="line">  IMPLEMENT_POOL_ALLOC(Goo)</span><br></pre></td></tr></table></figure>
<h1 id="P16-new-handler"><a href="#P16-new-handler" class="headerlink" title="P16. new handler"></a>P16. new handler</h1><ul>
<li>之前提到内存分配不成功时有补救措施，让使用者释放一些内存进行分配或者终止程序</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">noMoreMemory</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;out of memory&quot;</span>;</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set_new_handler(noMoreMemory);</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">    int* p = new int[100000000000000];   //well, so BIG!</span></span><br><span class="line"><span class="comment">    assert(p);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    p = new int[100000000000000000000];  //[Warning] integer constant is too large for its type</span></span><br><span class="line"><span class="comment">    assert(p);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="P17-vc6-malloc"><a href="#P17-vc6-malloc" class="headerlink" title="P17. vc6 malloc()"></a>P17. vc6 malloc()</h1><ul>
<li>debug 模式下 malloc 内存布局</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">cookie</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"> debug header</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"> user block</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"> debug tail</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"> pad</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"> cookie</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>上下cookie 记录使用的分配内存的大小和使用情况，pad 用来补齐使申请的内存块为16的倍数，获得的指针指向用户区块。</li>
</ul>
<h1 id="P18-VC6-标准分配器之实现-P19-BC5-分配器"><a href="#P18-VC6-标准分配器之实现-P19-BC5-分配器" class="headerlink" title="P18. VC6 标准分配器之实现 P19.BC5 分配器"></a>P18. VC6 标准分配器之实现 P19.BC5 分配器</h1><ul>
<li><p>VC6 中的 <code>allocator</code> 仅仅是调用 <code>::operator new()</code> 和 <code>::operator delete()</code>,没有任何特殊的设计</p>
</li>
<li><p>vc6 中的容器都是默认使用这个分配器以元素为单位完成内存分配，因此存在着大量的额外cookie开销。</p>
</li>
<li><p>BC5 的分配器行为与VC6 一致</p>
</li>
</ul>
<h1 id="P20-G2-9-标准分配器之实现"><a href="#P20-G2-9-标准分配器之实现" class="headerlink" title="P20. G2.9 标准分配器之实现"></a>P20. G2.9 标准分配器之实现</h1><ul>
<li><p>G2.9 中的<code>std::allocator</code>的行为与 VC6 和 BC5 完全一致，应该只是出于兼容的考虑</p>
</li>
<li><p>G2.9的<code>std::allocator</code>并没有在自带的STL中使用，容器的默认分配器是 <code>alloc</code>,接受的是字节大小而不是元素个数。</p>
</li>
</ul>
<h1 id="P21-G2-9-std-allo-vs-G4-9-pool-alloc"><a href="#P21-G2-9-std-allo-vs-G4-9-pool-alloc" class="headerlink" title="P21. G2.9 std::allo vs. G4.9 __pool_alloc"></a>P21. G2.9 std::allo vs. G4.9 __pool_alloc</h1><ul>
<li><p>G4.9标准库中有许多 extented allocators, 包含 __pool_alloc </p>
</li>
<li><p>在G4.9 中 <code>std::alloc</code> 改名为 <code>__pool_alloc</code></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//G4.9</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>,__gnu_cxx::__pool_alloc&lt;<span class="built_in">string</span>&gt;&gt; vec;</span><br><span class="line"></span><br><span class="line"><span class="comment">//G2.9</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>,<span class="built_in">std</span>::alloc&lt;<span class="built_in">string</span>&gt;&gt;</span><br></pre></td></tr></table></figure>
<h1 id="P22-G4-9-pool-allocator-例用"><a href="#P22-G4-9-pool-allocator-例用" class="headerlink" title="P22. G4.9 pool allocator 例用"></a>P22. G4.9 pool allocator 例用</h1><ul>
<li><p>G4.9 的标准分配器也和之前的没什么不同（应该是标准库的规定）</p>
</li>
<li><p>在创建大量的obj时，推荐使用 __pool_alloc，减少cookie，提高内存利用率</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">template&lt;typename Alloc&gt; </span></span><br><span class="line"><span class="comment">void cookie_test(Alloc&amp;&amp; alloc, size_t n)  //由於呼叫時以 temp obj (Rvalue) 傳入，所以這兒使用 &amp;&amp;. 只是隨意之下的搭配</span></span><br><span class="line"><span class="comment">                                            //使用 &amp;&amp;，那麼呼叫時就不能以 Lvalue 傳入.  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="comment">//上述, pass by Rvalue reference 是 OK 的.</span></span><br><span class="line">  <span class="comment">//但我不想那麼標新立異, 就改用 pass by value 吧</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Alloc&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">cookie_test</span><span class="params">(Alloc alloc, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">typename</span> Alloc::value_type *p1, *p2, *p3; <span class="comment">//需有 typename</span></span><br><span class="line">    p1 = alloc.allocate(n);            <span class="comment">//allocate() and deallocate() 是 non-static, 需以 object 呼叫之.</span></span><br><span class="line">    p2 = alloc.allocate(n);</span><br><span class="line">    p3 = alloc.allocate(n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p1= &quot;</span> &lt;&lt; p1 &lt;&lt; <span class="string">&#x27;\t&#x27;</span> &lt;&lt; <span class="string">&quot;p2= &quot;</span> &lt;&lt; p2 &lt;&lt; <span class="string">&#x27;\t&#x27;</span> &lt;&lt; <span class="string">&quot;p3= &quot;</span> &lt;&lt; p3 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    alloc.deallocate(p1, <span class="keyword">sizeof</span>(<span class="keyword">typename</span> Alloc::value_type)); <span class="comment">//需有 typename</span></span><br><span class="line">    alloc.deallocate(p2, <span class="keyword">sizeof</span>(<span class="keyword">typename</span> Alloc::value_type)); <span class="comment">//有些 allocator 對於 2nd argument 的值無所謂</span></span><br><span class="line">    alloc.deallocate(p3, <span class="keyword">sizeof</span>(<span class="keyword">typename</span> Alloc::value_type));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cookie_test(<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;(), <span class="number">1</span>);        <span class="comment">//相距 10h (表示帶 cookie)</span></span><br><span class="line">  cookie_test(__gnu_cxx::malloc_allocator&lt;<span class="keyword">int</span>&gt;(), <span class="number">1</span>); <span class="comment">//相距 10h (表示帶 cookie)</span></span><br><span class="line">  cookie_test(__gnu_cxx::__pool_alloc&lt;<span class="keyword">int</span>&gt;(), <span class="number">1</span>);    <span class="comment">//相距 08h (表示不帶 cookie)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="P23-std-alloc-运行模式"><a href="#P23-std-alloc-运行模式" class="headerlink" title="P23. std::alloc 运行模式"></a>P23. std::alloc 运行模式</h1><ul>
<li><p>std::alloc 包含16条链表，负责8 ~ 16*8字节的数据，大于128字节的数据则有malloc服务</p>
</li>
<li><p>每条链表每次申请2*20个单元的数据（这里的20是经验值），前20个单元用于本条链表，后20个用作储备，如第一次在32个字节的单元申请2*20个空间，当需要用到64字节数据时，可以先取用这些储备单元。</p>
</li>
<li><p>embedded pointers 嵌入式指针，使用内存块的前4个字节作为单向链表的指针</p>
</li>
</ul>
<h1 id="P24-G2-9-std-alloc-运行一瞥01-05"><a href="#P24-G2-9-std-alloc-运行一瞥01-05" class="headerlink" title="P24. G2.9 std::alloc 运行一瞥01-05"></a>P24. G2.9 std::alloc 运行一瞥01-05</h1><ul>
<li><p>申请到的内存都先放在pool中（储备区），用指针指明头尾</p>
</li>
<li><p>从pool中切割出来准备挂在list上的区块数量总是在1-20之间</p>
</li>
<li><p>多次申请内存为例</p>
<ul>
<li><p>申请32bytes内存时，由于pool为空，先向pool中注入32*20*2+RoundUp(0>&gt;4)=1280，从中切出一块给客户，剩下的19个区块挂在list#3上，余下640在pool中备用（RoundUp是追加量，每次越要越多）</p>
</li>
<li><p>申请64bytes，由于pool还有余量，故将pool分为640/64=10个区块，第一个给客户，剩下9个挂在list#7上（共申请1280，pool为0个）</p>
</li>
<li><p>申请96bytes,由于pool为空,因此注入（malloc申请）96*20*2+RoundUp(1280&gt;&gt;4),第一个给客户，19个给list#11（累计5200，pool：2000）</p>
</li>
<li><p>申请88，由于pool有余量，分割20个，第一个给客户，19个给list#10（累计5200，pool：240）</p>
</li>
</ul>
</li>
</ul>
<h1 id="P25-G2-9-std-alloc-运行一瞥06-10"><a href="#P25-G2-9-std-alloc-运行一瞥06-10" class="headerlink" title="P25. G2.9 std::alloc 运行一瞥06-10"></a>P25. G2.9 std::alloc 运行一瞥06-10</h1><ul>
<li><p>续上一节例子</p>
<ul>
<li><p>连续申请3次88，直接由list#10取出给客户（累计5200，pool：240）</p>
</li>
<li><p>申请8，由于pool有余量，分割20个，第一个给客户，19个给list#0（累计5200，pool：80）</p>
</li>
<li><p>申请104，list#12没有区块，pool余量不足一个，于是先将余下的80个给list#9（<strong>碎片处理</strong>），然后注入（malloc）104<em>20</em>2+RoundUp(5400&gt;&gt;4)，分割第一个给客户，19个给list#12（累计申请9688，pool：2408）</p>
</li>
<li><p>申请112，有余量，分割20个，第一个给客户，19个给list#13（累计申请9688，pool：168）</p>
</li>
<li><p>申请48，有余量，分割3个区块，第一个给客户，2个挂在list#5（累计9688，pool：24）</p>
</li>
</ul>
</li>
</ul>
<h1 id="P26-G2-9-std-alloc-运行一瞥11-13"><a href="#P26-G2-9-std-alloc-运行一瞥11-13" class="headerlink" title="P26. G2.9 std::alloc 运行一瞥11-13"></a>P26. G2.9 std::alloc 运行一瞥11-13</h1><ul>
<li><p>续上一节例子，观察系统的边界行为，修改源码将系统内存设置为10000，</p>
<ul>
<li><p>此时申请72，list#8为空，由于pool余量不足一个，于是先把余下24挂在list#2。但是现在已经无法申请到内存，因此需要使用大于list#8的空闲空间，因此取得list#9填会pool，再切出72给客户（累计申请9688，pool：8）</p>
</li>
<li><p>再申请72，list#8为空，pool余量不足一个，于是先把剩下的8个挂在list#0，从最接近的list#10取出一块填到pool，再切出72给客户。（累计9688，pool：16）</p>
</li>
<li><p>此时再申请120，系统已经无法满足需求，但是还有许多未使用的链表，系统还剩余312的空间。</p>
</li>
</ul>
</li>
<li><p>合并未使用的链表难度极高，留下一部分内存给别的程序</p>
</li>
</ul>
<h1 id="P27-29-G2-9-std-alloc-源码剖析"><a href="#P27-29-G2-9-std-alloc-源码剖析" class="headerlink" title="P27-29. G2.9 std::alloc 源码剖析"></a>P27-29. G2.9 std::alloc 源码剖析</h1><ul>
<li><p>第一级分配器主要来处理之前提到的set_new_handler，与内存分配关系不大</p>
</li>
<li><p>主要是对照代码讲解</p>
</li>
</ul>
<h1 id="P30-31-G2-9-std-alloc-观念大整理"><a href="#P30-31-G2-9-std-alloc-观念大整理" class="headerlink" title="P30-31. G2.9 std::alloc 观念大整理"></a>P30-31. G2.9 std::alloc 观念大整理</h1><ul>
<li><p>大部分与第29讲视频相同</p>
</li>
<li><p>deallocate 没有free，源于设计的缺陷，在一开始没有记录分配的指针，在后面loki部分会有改进</p>
</li>
</ul>
<h1 id="P32-41-vc6和vc10的malloc比较-（进入第三讲）"><a href="#P32-41-vc6和vc10的malloc比较-（进入第三讲）" class="headerlink" title="P32-41. vc6和vc10的malloc比较 （进入第三讲）"></a>P32-41. vc6和vc10的malloc比较 （进入第三讲）</h1><ul>
<li><p>vc6和vc10 main函数启动前的行为，与C++startup课程讲的相同</p>
</li>
<li><p>debug模式下内存分配会加上额外开销来记录文件行号等信息</p>
</li>
<li><p>所有malloc申请的内存都被登记在sbh之中</p>
</li>
</ul>
<h1 id="P42-44-vc6内存管理free-p"><a href="#P42-44-vc6内存管理free-p" class="headerlink" title="P42-44. vc6内存管理free(p)"></a>P42-44. vc6内存管理free(p)</h1><ul>
<li><p>先根据指针的地址判断落在哪一个header（一共16个header，每个header 管理 1M的内存）</p>
</li>
<li><p>再讲地址减去header指针 初一32得到group分组，再找出对应的链表</p>
</li>
<li><p>将1M内存分成32个group，这种一个小块小块的操作更有可能进行整块内存的回收</p>
</li>
<li><p>判断全回收：每个group头部有个计数器，每次malloc就会增加，每次free就会减少，当计数器为0时就全回收,变成最初始的8个page</p>
</li>
<li><p>全回收后并没有马上还给操作系统，有两个全回收才还给操作系统一个</p>
</li>
<li><p>虽然 <code>std::allocator</code> 、<code>CRT(malloc/free)</code> 甚至 <code>heapAlloc</code>都是类似的使用链表来来进行内存的维护，但是这并不重复，因为<code>std::allocator</code>不能预设<code>CRT(malloc/free)</code>已经进行了内存管理，<code>CRT(malloc/free)</code>也不能预设系统API<code>heapAlloc</code>内部有内存管理。</p>
</li>
<li><p>但是在vc10中 由于是windows平台，malloc的行为就是直接调用 <code>heapAlloc</code> 没有sbh管理</p>
</li>
</ul>
<h1 id="P45-上中下3个classes分析"><a href="#P45-上中下3个classes分析" class="headerlink" title="P45. 上中下3个classes分析"></a>P45. 上中下3个classes分析</h1><ul>
<li><p>loki allocator 上中下三层</p>
</li>
<li><p>底层 <strong>Chunk</strong></p>
<ul>
<li><strong>pData_</strong> : unsigned char* (指针指向一块内存)</li>
<li><strong>firstAvailableBlock_</strong> : unsigned char (第一个可用的区块编号)</li>
<li><strong>blockAvailavle_</strong>: unsigned char (剩余可用的区块数量)</li>
</ul>
</li>
<li><p>中层 <strong>FixedAllocator</strong></p>
<ul>
<li><strong>chunks_</strong> : vector\<Chunk> (动态数组存放底层)</Chunk></li>
<li><strong>allocChunk_</strong>: Chunk*</li>
<li><strong>deallocChunk_</strong>: Chunk*  (两根指针用来维护)</li>
</ul>
</li>
<li><p>上层 <strong>SmallObjAllocator</strong></p>
<ul>
<li><strong>pool_</strong>: vector\<FixedAllocator> （动态数组存放中层）</FixedAllocator></li>
<li><strong>pLastAlloc</strong>：FixedAllocator*</li>
<li><strong>plastDealloc</strong>: FixedAllocator*</li>
<li>chunkSize: size_t</li>
<li>maxObjectSize: size_t</li>
</ul>
</li>
</ul>
<h1 id="P46-loki-allocator行为图解"><a href="#P46-loki-allocator行为图解" class="headerlink" title="P46. loki_allocator行为图解"></a>P46. loki_allocator行为图解</h1><ul>
<li><p>申请一块内存分成64个块，借用每块的头部保存下一个index，</p>
</li>
<li><p>刚开始时 <code>firstAvailableBlock</code>是0，第一个内存空间的头部是1即下一个index</p>
</li>
<li><p>当客户需要内存时，先记录<code>firstAvailableBlock</code>所在区块的地址作为返回的指针，再取得当前第一个头部数据作为<code>firstAvailableBlock</code>的更新值，同时<code>blockAvailavle_</code>减一</p>
</li>
<li><p>当客户归还内存时，将<code>firstAvailableBlock</code>中的值填入释放的地址中，同时<code>firstAvailableBlock</code> 和 <code>blockAvailavle_</code> 自增</p>
</li>
</ul>
<h1 id="P47-48-class-FixedAllocator-分析（上）（下）"><a href="#P47-48-class-FixedAllocator-分析（上）（下）" class="headerlink" title="P47-48. class FixedAllocator 分析（上）（下）"></a>P47-48. class FixedAllocator 分析（上）（下）</h1><ul>
<li><p>allocChunk 和 deallocChunk 表示上一次分配/回收过的Chunk，因为往往申请或释放的内存都在临近的区域</p>
</li>
<li><p>FixedAllocator::Allocate()</p>
<ul>
<li><p>若上次分配过的allocChunk还有则直接分配</p>
</li>
<li><p>若上次分配过的allocChunk没有则从vector的第一个开始暴力查找，若能找到也就可以分配</p>
</li>
<li><p>若找到vector底部也没有找到就重新申请Chunk并存入vector中，将allocChunk指向当前vector尾部的chunk。由于有push_back操作的存在可能会引起vector的成长，因此这里还重新将deallocChunk指向vector的头部</p>
</li>
</ul>
</li>
<li><p>FixedAllocator::Deallocate()</p>
<ul>
<li>当客户归还内存指针时时从deallocChunk所在位置向上向下查找</li>
<li>找到所在Chunk后判断是否全回收，与malloc一样有一个延缓回收的机制，有2个全回收时才归还一个</li>
<li>当全回收时，总是吧chunk放在vector的尾部，同时将最后一个与当前的chunk进行交换，因此只要在全回收是检查最后一个是不是已经全回收即可</li>
</ul>
</li>
</ul>
<h1 id="P49-loki-allocator总结"><a href="#P49-loki-allocator总结" class="headerlink" title="P49. loki_allocator总结"></a>P49. loki_allocator总结</h1><ul>
<li><p>精简强悍，for循环有点暴力</p>
</li>
<li><p>用array 取代list 用 index取代poiner 手段特殊</p>
</li>
<li><p>可以很简单的判断全回收（与前面malloc一样有个计数器），进而还给操作系统</p>
</li>
<li><p>可以暂缓归还</p>
</li>
<li><p>loki_allocator的最佳客户是容器，但是其内部又含有一个容器vector。这并不冲突，因为内部的这个vector使用的是标准库的内存分配</p>
</li>
</ul>
<h1 id="P50-53-GNU-C-对allocator的描述"><a href="#P50-53-GNU-C-对allocator的描述" class="headerlink" title="P50-53. GNU C++ 对allocator的描述"></a>P50-53. GNU C++ 对allocator的描述</h1><ul>
<li><p>GNU C++ 有很多allocator。除了之前详细解释的__pool_alloc之外，还有一个bitmap_allocator 值得我们学习，其余的对于我们意义不大</p>
<ol>
<li><code>new_allocator</code>  vs2013和G4.9 的标准分配器 <code>new_allocator</code> 里面的分配与释放就是调用 operator new() 和operator delete()，并没有特殊的设计</li>
<li><code>malloc_allocator</code> 就是直接调用malloc和free</li>
<li><code>array_allocator</code> 使用静态数组来进行内存管理，因此也不需要释放。为了保持接口一致，在deallocate()函数内什么都没有做因此也没有做内存管理，用处不大</li>
<li><code>debug_allocator</code>,包装了另一个分配器调试用，引入的额外变量作用类似于cookie，而allocator本身的目的就是为了较少cookie，因此对用户来说意义不大</li>
<li><code>__pool_alloc</code> G2.9的默认分配器alloc在G4.9中的名称 使用时要<code>__gnu_cxx::__pool_alloc</code>，注意虽然进行了很好的内存管理，但是这个分配器并没有把内存还给操作系统</li>
</ol>
</li>
</ul>
<h1 id="P54-bitmap-allocator-（上）"><a href="#P54-bitmap-allocator-（上）" class="headerlink" title="P54. bitmap_allocator （上）"></a>P54. bitmap_allocator （上）</h1><ul>
<li><p>bitmap_allocator 私有继承自 free_list 虽然很奇怪，仅仅是因为里面需要一个list来维护</p>
</li>
<li><p>分配大于一个元素的使用 <code>::operator new()</code>来分配，一个元素时才由这个allocator分配（容器每次都是要一个，不会出现要多个的情况）</p>
</li>
<li><p>bitmap_allocator 内部结构</p>
<ul>
<li>block 分配给用户的内存空间，一般为8个字节</li>
<li><p>super_blocks的结构 :</p>
<ul>
<li>super block size 记录整个super_blocks的大小 第一个的大小为4+4*2+64*2=524</li>
<li>use count 记录使用了几个区块</li>
<li>2个bitmap 记录64个blocks的使用情况，bitmap的类型是unsigned int，用每个比特位表示每个block的使用情况</li>
<li>一开始为 64 个blocks</li>
</ul>
</li>
<li><p>__mini_vector 内部实现了一个小型的vector，内部存储由两根指针的单元，这两根指针指向super_block的头和尾用来管理super_blocks 。这里避免使用标准库的容器因此自己内部实现（vector内部就是三根指针，详见之前学过的课程）</p>
</li>
</ul>
</li>
<li><p>当用尽一开始的64个blocks之后，下一个super_block 的容量会加倍成为128个，因此需要4个整数来表示是否使用。因此第二个super_block的大小是 4+4*4+128*8=1044</p>
</li>
<li><p>同理用完这次分配的128个之后，下一次申请256个，容量为4+8*4+256*8 = 2084</p>
</li>
<li><p>若不曾全回收，分配规模不断倍增，若全回收，下次分配规模减半</p>
</li>
</ul>
<h1 id="P55-bitmap-allocator-（下）"><a href="#P55-bitmap-allocator-（下）" class="headerlink" title="P55. bitmap_allocator （下）"></a>P55. bitmap_allocator （下）</h1><ul>
<li><p>当 super_block#1 回收2个blocks，且尚未全回收，若接下来需要分配2个blocks，从后面的super_block取出</p>
</li>
<li><p>若后面的super_block用光时，先使用当前回收的这两个空间，再新建一个super_block</p>
</li>
<li><p>全回收时super_block使用一个名为freelist的__mini_vector维护，并排好序，当回收个数超过64个时将最大的那个super_block还给操作系统</p>
</li>
<li><p>当freelist有super_block时，不会重新创建super_block</p>
</li>
</ul>
<h1 id="P56-谈谈const"><a href="#P56-谈谈const" class="headerlink" title="P56. 谈谈const"></a>P56. 谈谈const</h1><ul>
<li><p>const 在<strong>成员函数</strong>参数列后面（小括号后面），函数本体前面（大括号前面），表示这个成员函数不改变类内变量的数据（不能用作全局函数）</p>
<ul>
<li>不修改类内数据的函数需要用在后面用const修饰，否则const对象无法调用这个函数</li>
</ul>
</li>
<li><p>当成员函数的const 和 non-const 版本同时存在时，const obj 只能调用 const 版本，non-const obj 智能调用 non-const 版本</p>
</li>
</ul>
<h1 id="P57-60-都是之前的视频"><a href="#P57-60-都是之前的视频" class="headerlink" title="P57-60 都是之前的视频"></a>P57-60 都是之前的视频</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/09/C-%E7%A8%8B%E5%BA%8F%E7%94%9F%E5%89%8D%E6%AD%BB%E5%90%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lclee">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog-lclee">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/09/C-%E7%A8%8B%E5%BA%8F%E7%94%9F%E5%89%8D%E6%AD%BB%E5%90%8E/" class="post-title-link" itemprop="url">C++ 程序生前死后</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-02-09 19:35:57" itemprop="dateCreated datePublished" datetime="2021-02-09T19:35:57+08:00">2021-02-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-02-26 18:49:51" itemprop="dateModified" datetime="2021-02-26T18:49:51+08:00">2021-02-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>解密 CRT Startup code<br>(CRT: C run time library</p>
<h1 id="1-Startup-code"><a href="#1-Startup-code" class="headerlink" title="1. Startup code"></a>1. Startup code</h1><ul>
<li>启动码函数比main()函数更早执行，其中会初始化一些静态变量，再调用main()函数，一般是由链接器完成，不推荐个人编写</li>
</ul>
<h1 id="2-heap-allocate"><a href="#2-heap-allocate" class="headerlink" title="2. heap allocate"></a>2. heap allocate</h1><ul>
<li>在启动代码中申请一大块内存，用一定的结构进行不同大小的内存管理</li>
</ul>
<h1 id="3-before-main"><a href="#3-before-main" class="headerlink" title="3. before main"></a>3. before main</h1><ul>
<li><p>在进入main 之前，还处理了命令行参数和系统的环境变量</p>
</li>
<li><p>io init 建立stdin，stdout,stderr</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/03/C-2-0-%E6%96%B0%E7%89%B9%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lclee">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog-lclee">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/03/C-2-0-%E6%96%B0%E7%89%B9%E6%80%A7/" class="post-title-link" itemprop="url">C++ 2.0 新特性</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-02-03 14:19:42" itemprop="dateCreated datePublished" datetime="2021-02-03T14:19:42+08:00">2021-02-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-02-26 18:49:51" itemprop="dateModified" datetime="2021-02-26T18:49:51+08:00">2021-02-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="P1-环境介绍"><a href="#P1-环境介绍" class="headerlink" title="P1. 环境介绍"></a>P1. 环境介绍</h1><ul>
<li><p>涵盖 c++11 和 c++14</p>
</li>
<li><p>C++ 2.0 的新特性包含语言和标准库两部分</p>
<ul>
<li><p>头文件不再使用 <code>.h</code> 后缀，例如 <code>#include &lt;vector&gt;</code></p>
</li>
<li><p>新式的 c 头文件也不再带有 <code>.h</code>, 例如 <code>#include &lt;cstdio&gt;</code>，在之前的名称前面加一个 c</p>
</li>
<li><p>旧式 c 头文件 带有 <code>.h</code>仍然可以使用，例如 <code>#include &lt;stdio.h&gt;</code></p>
</li>
<li><p>常用的数据类型都在 <code>std</code> 这里命名空间内，如<code>&lt;type_traits&gt;</code>, <code>&lt; unordered_set&gt;</code>，<code>&lt;forward_list&gt;</code> 等等</p>
</li>
</ul>
</li>
</ul>
<h1 id="P2-variadic-templates-变参模板"><a href="#P2-variadic-templates-变参模板" class="headerlink" title="P2. variadic templates 变参模板"></a>P2. variadic templates 变参模板</h1><ul>
<li><p>可以处理任意类型，任意数量的参数</p>
</li>
<li><p>本质是将参数分成第一个和后边一包（pack），每次处理第一个，在递归调用。</p>
</li>
<li><p>注意需要写边界条件。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> T&amp; firstArg, <span class="keyword">const</span> Types&amp;... args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; firstArg &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    print(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(<span class="number">123</span>, <span class="string">&quot;heool&quot;</span>,<span class="built_in">bitset</span>&lt;<span class="number">16</span>&gt;(<span class="number">377</span>),<span class="number">7.5</span>);<span class="comment">//就可以以此打印</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>...</code> 表示参数包，注意代码中 <code>...</code> 的位置</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> Types&amp;... args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;one type&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>上面这段重载版本也可以与之前的共存，具体原来后面课程再讲，我认为应该是调用较为特化的版本,先留个坑讲解之后再来补充 在P15讲解</p>
</li>
<li><p>还有两个计算hash值 和 tuple 的递归继承的范例在 <a href="/2020/12/03/STL%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/" title="STL与泛型编程">STL与泛型编程</a> <code>P40</code>  <code>hash_val</code>函数 和 <code>P41</code> <code>tuple</code> 的定义</p>
</li>
</ul>
<h1 id="P3-一些细节知识"><a href="#P3-一些细节知识" class="headerlink" title="P3. 一些细节知识"></a>P3. 一些细节知识</h1><ul>
<li><p><code>vector&lt;list&lt;int&gt; &gt;</code> 在c++11 之前两个尖括号必须分开，否则会被认为是 <code>&gt;&gt;</code> 操作符，c++11之后则不必</p>
</li>
<li><p>之前的版本一直是将 <code>NULL</code> 定义为 0，这与将指针赋值为 0 不太符合，新增关键字 <code>nullptr</code> 来代替 <code>NULL</code>。</p>
</li>
<li><p>自动类型推导 <code>auto</code>，用来处理变量名过长或者变量类型过于复杂。不可用来生命所有变量。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">auto</span> pose = v.begin();<span class="comment">//vector&lt;string&gt; ::iterator 类型太长</span></span><br><span class="line"><span class="keyword">auto</span> l = [](<span class="keyword">int</span> x) -&gt; <span class="keyword">bool</span>&#123;<span class="comment">//匿名函数的类型过于复杂，匿名函数在后面会谈到</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="P4-Uniform-Initialization-一致初始化"><a href="#P4-Uniform-Initialization-一致初始化" class="headerlink" title="P4. Uniform Initialization 一致初始化"></a>P4. Uniform Initialization 一致初始化</h1><ul>
<li>接前一讲，<code>auto</code> 可以用来简化代码</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; c;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;::iterator ite;</span><br><span class="line">ite = find(c.begin(),c.end(),target);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> = find(c.begin(),c.end(),target); <span class="comment">//省去提前生命变量</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>在之前的版本中会出现各种方法的初始化，小括号，中括号，大括号。在c++11之后，可以都使用大括号来初始化。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> valuesp[] &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; cities &#123;</span><br><span class="line">    <span class="string">&quot;Berlin&quot;</span>,<span class="string">&quot;New York&quot;</span>, <span class="string">&quot;London&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; c&#123;<span class="number">4.0</span>,<span class="number">3.0</span>&#125;<span class="comment">//相当于c(4.0,3.0) </span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>编译器看到 <code>&#123;t1,t2,t3,...tn&#125;</code>,便会做出一个 <code>initializer_list&lt;T&gt;</code>,关联到一个 <code>array&lt;T,n&gt;</code>,调用函数（如ctor）时这些元素被逐一拆解传给函数。</p>
</li>
<li><p>若函数有接受 <code>initializer_list&lt;T&gt;</code> 的特化版本，则直接传入</p>
</li>
<li><p>若函数没有接受 <code>initializer_list&lt;T&gt;</code> 的特化版本，则拆解传入</p>
</li>
<li><p>若函数仅有 <code>initializer_list&lt;T&gt;</code> 版本，则需要我们自己准备好一包来传入，之后会有更加详细的例子。</p>
</li>
<li><p>所有的容器都有接受 <code>initializer_list&lt;T&gt;</code>版本的ctor</p>
</li>
<li><p><code>complex&lt;double&gt;</code>并没有接受 <code>initializer_list&lt;T&gt;</code>的版本，<code>array&lt;double,2&gt;</code> 被拆解传给ctor</p>
</li>
</ul>
<h1 id="P5-Initializer-List-上"><a href="#P5-Initializer-List-上" class="headerlink" title="P5. Initializer List 上"></a>P5. Initializer List 上</h1><ul>
<li>以 {} 初始化的变量有初值</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;      <span class="comment">//i 未定义</span></span><br><span class="line"><span class="keyword">int</span> j&#123;&#125;;    <span class="comment">//i初始化为0</span></span><br><span class="line"><span class="keyword">int</span>* p；    <span class="comment">//未定义指针</span></span><br><span class="line"><span class="keyword">int</span>* q&#123;&#125;;   <span class="comment">//q初始化为nullptr</span></span><br></pre></td></tr></table></figure>
<ul>
<li>narrowing initializations 窄向初始化</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">x1</span><span class="params">(<span class="number">5.3</span>)</span></span>;    <span class="comment">//OK 但是为5</span></span><br><span class="line"><span class="keyword">int</span> x2 = <span class="number">5.3</span>；  <span class="comment">//OK 但是为5</span></span><br><span class="line"><span class="keyword">int</span> x3&#123;<span class="number">5.3</span>&#125;；   <span class="comment">//error: narrowing conversion</span></span><br><span class="line"><span class="keyword">char</span> c1&#123;<span class="number">7</span>&#125;;     <span class="comment">//OK 虽然7是int，但是可以转成char</span></span><br><span class="line"><span class="keyword">char</span> c2&#123;<span class="number">99999</span>&#125;; <span class="comment">//error: narrowing conversion</span></span><br></pre></td></tr></table></figure>
<h1 id="P6-Initializer-List-下"><a href="#P6-Initializer-List-下" class="headerlink" title="P6. Initializer List 下"></a>P6. Initializer List 下</h1><ul>
<li>可以用来进行初始化，也可以用来处理一串数据 a list of valve</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; val)</span></span>&#123; <span class="comment">//传入参数必须是initializer_list 或者&#123;  &#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p = val.begin(); p != val.end(); ++p)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>initializer_list 的定义如下，简单来说编译器可以调用第17行的自由构造函数，实现变量初始化。</p>
</li>
<li><p>编译器在边缘过程中先准备好一个array，把指针地址和长度传给私有的构造函数实现初始化</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">template&lt;class _E&gt;</span><br><span class="line">  class initializer_list</span><br><span class="line">  &#123;</span><br><span class="line">  public:</span><br><span class="line">    typedef _E            value_type;</span><br><span class="line">    typedef const _E&amp;     reference;</span><br><span class="line">    typedef const _E&amp;     const_reference;</span><br><span class="line">    typedef size_t        size_type;</span><br><span class="line">    typedef const _E*     iterator;</span><br><span class="line">    typedef const _E*     const_iterator;</span><br><span class="line"></span><br><span class="line">  private:</span><br><span class="line">    iterator          _M_array;</span><br><span class="line">    size_type         _M_len;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; The compiler can call a private constructor.</span><br><span class="line">    constexpr initializer_list(const_iterator __a, size_type __l)</span><br><span class="line">    : _M_array(__a), _M_len(__l) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  public:</span><br><span class="line">    constexpr initializer_list() noexcept</span><br><span class="line">    : _M_array(0), _M_len(0) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Number of elements.</span><br><span class="line">    constexpr size_type</span><br><span class="line">    size() const noexcept &#123; return _M_len; &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; First element.</span><br><span class="line">    constexpr const_iterator</span><br><span class="line">    begin() const noexcept &#123; return _M_array; &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; One past the last element.</span><br><span class="line">    constexpr const_iterator</span><br><span class="line">    end() const noexcept &#123; return begin() + size(); &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>由于initializer_list只是两个指针，对它的拷贝是危险的。</p>
</li>
<li><p><code>initializer_list</code> 在标准库中(几乎所有的容器和部分算法)广泛使用。</p>
</li>
<li><p>可以多个数值比大小</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; max(&#123;<span class="number">54</span>, <span class="number">16</span>, <span class="number">30</span>, <span class="number">50</span>，<span class="number">70</span> &#125;)&lt;&lt; <span class="built_in">endl</span>;<span class="comment">//使用initializer_list比较大小是先 #include &lt;algorithm&gt; 否则无法运行</span></span><br></pre></td></tr></table></figure>
<h1 id="P7-explicit"><a href="#P7-explicit" class="headerlink" title="P7. explicit"></a>P7. explicit</h1><ul>
<li>作用于构造函数，取消隐式转换。极少数用于模板</li>
</ul>
<figure class="highlight cpp"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> real, imag;</span><br><span class="line">    <span class="comment">/*explicit*/</span> Complex(<span class="keyword">int</span> re,<span class="keyword">int</span> im = <span class="number">0</span>):real(re),imag(im)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex&amp; x)&#123;</span><br><span class="line">        <span class="keyword">return</span> Complex(real + x.real, imag + x.imag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out,<span class="keyword">const</span> Complex &amp;c)&#123;</span><br><span class="line">                out&lt;&lt;<span class="string">&quot;(&quot;</span>&lt;&lt;c.real&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;c.imag&lt;&lt;<span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">12</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">Complex c2 = c1 + <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>当第 <code>4</code> 行没有 <code>explicit</code> 时，最会一行中的 5 会被隐式转换为 Complex 类型。</p>
</li>
<li><p>没有 <code>explicit</code> 修饰，且构造函数只有一个参数没有指定，编译器可以提供隐式转换。</p>
</li>
<li><p>当构造函数指明为 <code>explicit</code> 时，只能显式定义，否则将编译报错。</p>
</li>
</ul>
<h1 id="P8-range-based-for-statement"><a href="#P8-range-based-for-statement" class="headerlink" title="P8. range-based for statement"></a>P8. range-based for statement</h1><ul>
<li><p>简单的for循环写法 <code>for(decl:coll)&#123; statement &#125;</code></p>
</li>
<li><p>取出 <code>coll</code> 中的每一个元素赋值到 <code>decl</code> 中括号</p>
</li>
<li><p>如果要修改容器中的内容需要取引用。若没有第二行取引用，则对i的修改不会改变容器</p>
</li>
<li><p>推荐取引用，减少赋值带来的开销</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; coll&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i :coll)&#123;</span><br><span class="line">    i = i * <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ostream_iterator&lt;<span class="keyword">int</span>&gt; <span class="title">out_iter</span><span class="params">(<span class="built_in">cout</span>, <span class="string">&quot; &quot;</span>)</span></span>;<span class="comment">//#include&lt;iterator&gt;</span></span><br><span class="line">copy(coll.cbegin(), coll.cend(), out_iter);<span class="comment">//打印容器内容</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h1 id="P9-defualt-delete"><a href="#P9-defualt-delete" class="headerlink" title="P9. =defualt, =delete"></a>P9. =defualt, =delete</h1><ul>
<li><p>一个类如果应定义了ctor，那么编译器就不在提供 default ctor</p>
</li>
<li><p>如果强制加上一个 =default，就可以重新获得 defualt ctor</p>
</li>
<li><p>在 default ctor 中编译器会来处理一些继承相关的工作</p>
</li>
<li><p>=delete 就是删除这个函数</p>
</li>
<li><p>一般 = delete 和 =default 作用于 构造，拷贝构造，析构函数上</p>
</li>
</ul>
<h1 id="P10-Alias-Template"><a href="#P10-Alias-Template" class="headerlink" title="P10. Alias Template"></a>P10. Alias Template</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Vec = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T,MyAlloc&lt;T&gt;&gt;;<span class="comment">//默认使用allocator</span></span><br><span class="line"></span><br><span class="line">Vec&lt;<span class="keyword">int</span>&gt; coll;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>模板的化名明，使用typedef 和 #define 无法达到同样的效果</p>
</li>
<li><p>当使用化名之后就不能再对其使用特化或偏特化。</p>
</li>
</ul>
<h1 id="P11-template-template-parameter"><a href="#P11-template-template-parameter" class="headerlink" title="P11. template template parameter"></a>P11. template template parameter</h1><ul>
<li>模板的参数也是模板</li>
</ul>
<figure class="highlight cpp"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,</span><br><span class="line">                    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span>&gt;</span><span class="comment">//这里省略了T</span></span><br><span class="line">                        <span class="class"><span class="keyword">class</span> <span class="title">Container</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">xcls</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Container&lt;T&gt; c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    xcls()&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i:&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;)</span><br><span class="line">            c.insert(c.end(), T());</span><br><span class="line"></span><br><span class="line">        <span class="function">Container&lt;T&gt; <span class="title">c1</span><span class="params">(c)</span></span>;</span><br><span class="line">        <span class="function">Container&lt;T&gt; <span class="title">c2</span><span class="params">(<span class="built_in">std</span>::move(c))</span></span>;</span><br><span class="line">        c1.swap(c2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Vec = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T, <span class="built_in">std</span>::allocator&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line">xcls&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&gt; c1;<span class="comment">//从c++17 开始正确，c++17之前 error：expected a template of type ‘template&lt;class&gt; class Container’, got ‘template&lt;class _Tp, class _Alloc&gt; class std::vector’</span></span><br><span class="line"></span><br><span class="line">xcls&lt;<span class="built_in">string</span>, Vec&gt; c2;<span class="comment">//这样C++11 和 14才能编译通过</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>由于vector有2个参数，虽然第二个有默认值，但是在c++17之前，模板模板参数中，并不会调用默认值。</p>
</li>
<li><p>因此需要指定模板的参数，就要用到第<code>17</code>行模板的化名</p>
</li>
</ul>
<h1 id="P12-type-alias-noexcept-override"><a href="#P12-type-alias-noexcept-override" class="headerlink" title="P12. type alias, noexcept, override"></a>P12. type alias, noexcept, override</h1><ul>
<li>类型的别名。借助 <code>using</code> 关键字，类似于 <code>typedef</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//typedef void(*func)(int,int)</span></span><br><span class="line"><span class="keyword">using</span> func = <span class="keyword">void</span>(*)(<span class="keyword">int</span>,<span class="keyword">int</span>);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">example</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>&#123;&#125;;</span><br><span class="line">func fn = example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Container</span>&#123;</span></span><br><span class="line">  <span class="keyword">using</span> value_type = T;<span class="comment">//等同于 typedef T value_type;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>typedef</code> 无法明显的表示 <code>func</code> 是一种类型，这种是接受两个int参数，范围类型为void的函数，使用 <code>using</code> 则意义一目了然。</p>
</li>
<li><p>上述 using 和 typedef 的效果完全相同。</p>
</li>
<li><p>其他 using 的用法: 使用命名空间 <code>using namespace std</code> 或者仅仅使用某个函数 <code>using std::count</code></p>
</li>
</ul>
<hr>
<ul>
<li><p>noexcept 表示函数不会抛出异常。</p>
</li>
<li><p>要告诉编译器，尤其是使用vector 来存储时，移动构造和析构函数一定不能抛出异常。</p>
</li>
<li><p>因为 vector 会成长，需要大量的拷贝构造和析构，只有当移动构造和析构不抛出异常时才能被调用。</p>
</li>
</ul>
<h2 id><a href="#" class="headerlink" title></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="literal">true</span>)</span><span class="comment">//其实还可以加一个括号来填写条件，不加默认都不抛出异常</span></span></span><br></pre></td></tr></table></figure></h2><ul>
<li><p><code>override</code> 应用在虚函数上，当你想要改写虚函数时，在改写函数的括号后写明，可以帮助编译器检查错误。（编译器无法分清是想重新声明一个新的虚函数（不小心写错往往都是声明一个新的，且编译器无法检查出来）还是进行改写，因此改写时要注明override）</p>
</li>
<li><p><code>final</code>，若在类声明后面修饰，则这个类无法被继承，若声明在虚函数后面，则这个函数不能改写。</p>
</li>
</ul>
<h1 id="P13-decltype"><a href="#P13-decltype" class="headerlink" title="P13. decltype"></a>P13. decltype</h1><ul>
<li>decltype 的作用就是根据表达式推断类型</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">auto add(T1 x,T2 y) -&gt; decltype(x+y)//c++14 中可以 decltype(auto) add(T1 x,T2,y)自动推断返回的类型。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>模板函数的返回类型通过推断decltype(x+y) 来确定，这里的auto 并不是指任意类型，而是指推断出的类型。</p>
</li>
<li><p>上面的表达形式与 lambda 表达式很像，lambda 表达式会在之后的章节讲述</p>
</li>
<li><p>在模板编程中只知道对象而不知道类型时来获取类型</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="title">decltype</span><span class="params">(obj)</span>::iterator iType</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>获取 lambda 表达式的返回类型(通常 lambda 表达式 用auto声明)</li>
</ul>
<h1 id="P14-Lambdas"><a href="#P14-Lambdas" class="headerlink" title="P14. Lambdas"></a>P14. Lambdas</h1><ul>
<li>可以理解为一个匿名函数对象</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> l = [] &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;hello lambda&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br><span class="line">l();</span><br></pre></td></tr></table></figure>
<ul>
<li><p>lambda 表达式可以允许在函数体中声明另一段函数</p>
</li>
<li><p>完整的匿名函数如下，中括号内为可使用的外界参数，()内为函数参数，需要加 mutable 才能对函数体内的传入外界参数进行修改。</p>
</li>
<li><p>中括号内默认传值，若要 lambda 修改外界变量需要传引用</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> l = [id] () <span class="keyword">mutable</span> &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; id &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    ++id;<span class="comment">//没有mutable id 是read only</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">id = <span class="number">42</span>;</span><br><span class="line">l();<span class="comment">//打印还是0，若要打印42，需要取引用</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>可以将中括号内的外接参数想象成 lambda 初始化内部变量的初始值，虽然内外名称相同，但是初始化完成后就不再使用，因此若要修改外部值需要传引用。</p>
</li>
<li><p>lambda 对象并没有默认的构造函数和赋值动作，因此作为容器排序的准则可能仿函数更加合适。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set&lt;Person,decltype(cmp)&gt; coll(cmp);//由于没有默认构造函数，需要传入一个对象</span><br><span class="line"><span class="comment">//set&lt;Person,decltype(cmp)&gt; coll//大部分人会写成这种错误的写法</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用 lambda 表达式可以避免冗长的仿函数声明</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">58</span>, <span class="number">60</span>, <span class="number">47</span>, <span class="number">52</span>, <span class="number">89</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">19</span>;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">59</span>;</span><br><span class="line">vi.erase(</span><br><span class="line">    remove_if(vi.begin(), vi.end(),</span><br><span class="line">              [x, y](<span class="keyword">int</span> n) &#123; <span class="keyword">return</span> x &lt; n &amp;&amp; n &lt; y; &#125;),</span><br><span class="line">    vi.end());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : vi)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//10 4 0 60 89</span></span><br></pre></td></tr></table></figure>
<h1 id="P15-Variadic-Template-1"><a href="#P15-Variadic-Template-1" class="headerlink" title="P15. Variadic Template 1"></a>P15. Variadic Template 1</h1><ul>
<li>讲解 <code>P2</code> 提出的问题，特化的版本更有限被调用，因此下面 P2 最后提到的那一段代码永远不会被调用。</li>
</ul>
<h1 id="P16-Variadic-Template-2"><a href="#P16-Variadic-Template-2" class="headerlink" title="P16. Variadic Template 2"></a>P16. Variadic Template 2</h1><ul>
<li>重写 <code>printf</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printg</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (*s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*s == <span class="string">&#x27;%&#x27;</span> &amp;&amp; *(++s)!= <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">            <span class="keyword">throw</span> runtime_error(<span class="string">&quot;invalid format&quot;</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *s++;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printg</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s,T value,Args... args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (*s)&#123;        </span><br><span class="line">        <span class="keyword">if</span> (*s == <span class="string">&#x27;%&#x27;</span> &amp;&amp; *(++s)!= <span class="string">&#x27;%&#x27;</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; value&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        printg(++s, args...);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *s++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> logic_error(<span class="string">&quot;extra arguement provided&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">test03::printg(<span class="string">&quot;%d%s%p%f\n&quot;</span>, <span class="number">15</span>, <span class="string">&quot;this is Ace&quot;</span>, pi, <span class="number">3.14159</span>);<span class="comment">//15 this is Ace 0x55b565107e70 3.14159 </span></span><br></pre></td></tr></table></figure>
<h1 id="P17-Variadic-Template-3"><a href="#P17-Variadic-Template-3" class="headerlink" title="P17. Variadic Template 3"></a>P17. Variadic Template 3</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">   _GLIBCXX14_CONSTEXPR</span><br><span class="line">   <span class="keyword">inline</span> _Tp</span><br><span class="line">   max(<span class="built_in">initializer_list</span>&lt;_Tp&gt; __l)</span><br><span class="line">   &#123; <span class="keyword">return</span> *<span class="built_in">std</span>::max_element(__l.begin(), __l.end()); &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用initializer_list来比较一串数组，但是<code>max(&#123;1,2,3,4,5&#125;)</code> 仍然有大括号</li>
</ul>
<h1 id="P18-Variadic-Template-4"><a href="#P18-Variadic-Template-4" class="headerlink" title="P18. Variadic Template 4"></a>P18. Variadic Template 4</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxi</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxi</span><span class="params">(<span class="keyword">int</span> n, Args... args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> max(n, maxi(args...));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">maxi(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);<span class="comment">//6</span></span><br></pre></td></tr></table></figure>
<ul>
<li>递归调用自己，一层一层比大小。</li>
</ul>
<h1 id="P19-Variadic-Template-5"><a href="#P19-Variadic-Template-5" class="headerlink" title="P19. Variadic Template 5"></a>P19. Variadic Template 5</h1><ul>
<li>实现 <code>cout&lt;&lt;make_tuple(7.5,string(&quot;hello&quot;),bitset&lt;16&gt;(377),42)</code> 输出<code>[7.5,hello,0000000101111001,42]</code>，前后有方括号中间有逗号。</li>
</ul>
<figure class="highlight cpp"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">template</span> &lt;<span class="keyword">int</span> IDX, <span class="keyword">int</span> MAX, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PRINT_TUPLE</span> &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span> <span class="params">(ostream&amp; os, <span class="keyword">const</span> tuple&lt;Args...&gt;&amp; t)</span></span>&#123;</span><br><span class="line">            os &lt;&lt; get&lt;IDX&gt;(t) &lt;&lt; (IDX + <span class="number">1</span> == MAX ? <span class="string">&quot;&quot;</span>: <span class="string">&quot;,&quot;</span>);</span><br><span class="line">            PRINT_TUPLE&lt;IDX+<span class="number">1</span>, MAX, Args...&gt;::print(os, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">int</span> MAX, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PRINT_TUPLE</span>&lt;</span>MAX, MAX, Args...&gt; &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span> <span class="params">(ostream&amp; os, <span class="keyword">const</span> tuple&lt;Args...&gt;&amp; t)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ... Args&gt;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; os, <span class="keyword">const</span> tuple&lt;Args...&gt;&amp; t) &#123;</span><br><span class="line">        os &lt;&lt; <span class="string">&quot;[&quot;</span>;</span><br><span class="line">        PRINT_TUPLE&lt;<span class="number">0</span>, <span class="keyword">sizeof</span>...(Args), Args...&gt;::print(os, t);</span><br><span class="line">        <span class="keyword">return</span> os &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>模板中不仅能定义类型，若指定类型还能定义变量，如第 <code>1</code> 行的 <code>IDX</code> 和 <code>MAX</code></p>
</li>
<li><p>通过每次创建实现变量<code>IDX</code>增加来实现对位置的记录。</p>
</li>
<li><p>这里复习一下自定义类的输出(17行)，对于类内私有变量需要用友元函数重载操作符</p>
</li>
</ul>
<h1 id="P20-Variadic-Template-6"><a href="#P20-Variadic-Template-6" class="headerlink" title="P20. Variadic Template 6"></a>P20. Variadic Template 6</h1><ul>
<li><p>tuple的递归继承在上一门课程STL中已经学过</p>
</li>
<li><p>注意tuple在内存在中的结构是现有尾部数据再有头部数据。</p>
</li>
</ul>
<h1 id="P21-Variadic-Template-7"><a href="#P21-Variadic-Template-7" class="headerlink" title="P21. Variadic Template 7"></a>P21. Variadic Template 7</h1><ul>
<li>递归复合实现tuple</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ... Values&gt; <span class="class"><span class="keyword">class</span> <span class="title">mytuple2</span>;</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">class</span> <span class="title">mytuple2</span>&lt;</span>&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span> ... Tail&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mytuple2</span>&lt;</span>Head, Tail...&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> composited = mytuple2&lt;Tail...&gt;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    mytuple2() &#123;&#125;</span><br><span class="line">    mytuple2(Head v, Tail... vtail) : m_head(v), m_tail(vtail...) &#123;&#125;</span><br><span class="line">    <span class="function">Head <span class="title">head</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> m_head;&#125;</span><br><span class="line">    <span class="function">composited&amp; <span class="title">tail</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> m_tail;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Head m_head;</span><br><span class="line">    composited m_tail;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="P22-源码分布-P23-Rvalue-reference"><a href="#P22-源码分布-P23-Rvalue-reference" class="headerlink" title="P22. 源码分布 P23. Rvalue reference"></a>P22. 源码分布 P23. Rvalue reference</h1><ul>
<li><p>源码分布，在之前的课程已经介绍</p>
</li>
<li><p>右值引用，避免一些不必要的拷贝，当等号右侧是右值时，左值可以直接偷取右值数据。</p>
</li>
<li><p>左值 - 变量可以被赋值，右值-临时对象，不能被赋值</p>
</li>
<li><p>适用场景：容器中放入临时对象，这样可以避免拷贝构造带来的开销</p>
</li>
<li><p>若一直这个变量之后不会再用 可以使用<code>std::move</code>将左值变成右值。</p>
</li>
</ul>
<h1 id="P24-perfect-forwarding"><a href="#P24-perfect-forwarding" class="headerlink" title="P24. perfect forwarding"></a>P24. perfect forwarding</h1><ul>
<li>转发就是通过一个函数将参数继续转交给另一个函数进行处理，原参数可能是右值，可能是左值，如果还能继续保持参数的原有特征，那么它就是完美的。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>&amp; i)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;process(int&amp;):&quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>&amp;&amp; i)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;process(int&amp;&amp;):&quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myforward</span><span class="params">(<span class="keyword">int</span>&amp;&amp; i)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;myforward(int&amp;&amp;):&quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    process(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    process(a); <span class="comment">//a被视为左值 process(int&amp;):0</span></span><br><span class="line">    process(<span class="number">1</span>); <span class="comment">//1被视为右值 process(int&amp;&amp;):1</span></span><br><span class="line">    process(move(a)); <span class="comment">//强制将a由左值改为右值 process(int&amp;&amp;):0</span></span><br><span class="line">    myforward(<span class="number">2</span>);  <span class="comment">//右值经过forward函数转交给process函数，却称为了一个左值，</span></span><br><span class="line">    <span class="comment">//原因是该右值有了名字  所以是 process(int&amp;):2</span></span><br><span class="line">    myforward(move(a));  <span class="comment">// 同上，在转发的时候右值变成了左值  process(int&amp;):0</span></span><br><span class="line">    <span class="comment">// forward(a) // 错误用法，右值引用不接受左值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>上面的例子就是不完美转发，而c++中提供了一个<code>std::forward()</code>模板函数解决这个问题.</li>
</ul>
<h1 id="P25-more-aware-class-有移动意识的类-P26-测试"><a href="#P25-more-aware-class-有移动意识的类-P26-测试" class="headerlink" title="P25. more aware class 有移动意识的类 P26. 测试"></a>P25. more aware class 有移动意识的类 P26. 测试</h1><ul>
<li>移动构造 (<code>34</code> 行)和移动赋值(<code>53</code>行)要把原来的指针赋值为nullptr</li>
</ul>
<figure class="highlight cpp"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> CCtor; <span class="comment">//统计调用拷贝构造函数的次数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> MCtor; <span class="comment">//统计调用移动构造函数的次数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> CAsgn; <span class="comment">//统计调用拷贝赋值函数的次数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> MAsgn; <span class="comment">//统计调用移动赋值函数的次数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">   MyString(<span class="keyword">const</span> <span class="keyword">char</span>* cstr=<span class="number">0</span>)&#123;</span><br><span class="line">       <span class="keyword">if</span> (cstr) &#123;</span><br><span class="line">          m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(cstr)+<span class="number">1</span>];</span><br><span class="line">          <span class="built_in">strcpy</span>(m_data, cstr);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">          m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">          *m_data = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 拷贝构造函数</span></span><br><span class="line">   MyString(<span class="keyword">const</span> MyString&amp; str) &#123;</span><br><span class="line">       CCtor ++;</span><br><span class="line">       m_data = <span class="keyword">new</span> <span class="keyword">char</span>[ <span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span> ];</span><br><span class="line">       <span class="built_in">strcpy</span>(m_data, str.m_data);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 移动构造函数</span></span><br><span class="line">   MyString(MyString&amp;&amp; str) <span class="keyword">noexcept</span></span><br><span class="line">       :m_data(str.m_data) &#123;</span><br><span class="line">       MCtor ++;</span><br><span class="line">       str.m_data = <span class="literal">nullptr</span>; <span class="comment">//不再指向之前的资源了</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 拷贝赋值函数 =号重载</span></span><br><span class="line">   MyString&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyString&amp; str)&#123;</span><br><span class="line">       CAsgn ++;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) <span class="comment">// 避免自我赋值!!</span></span><br><span class="line">          <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">delete</span>[] m_data;</span><br><span class="line">       m_data = <span class="keyword">new</span> <span class="keyword">char</span>[ <span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span> ];</span><br><span class="line">       <span class="built_in">strcpy</span>(m_data, str.m_data);</span><br><span class="line">       <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 移动赋值函数 =号重载</span></span><br><span class="line">   MyString&amp; <span class="keyword">operator</span>=(MyString&amp;&amp; str) <span class="keyword">noexcept</span>&#123;</span><br><span class="line">       MAsgn ++;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) <span class="comment">// 避免自我赋值!!</span></span><br><span class="line">          <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">delete</span>[] m_data;</span><br><span class="line">       m_data = str.m_data;</span><br><span class="line">       str.m_data = <span class="literal">nullptr</span>; <span class="comment">//不再指向之前的资源了</span></span><br><span class="line">       <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ~MyString() &#123;</span><br><span class="line">       <span class="keyword">delete</span>[] m_data;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">char</span>* <span class="title">get_c_str</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_data; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">char</span>* m_data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">size_t</span> MyString::CCtor = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> MyString::MCtor = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> MyString::CAsgn = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> MyString::MAsgn = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;MyString&gt; vecStr;</span><br><span class="line">    vecStr.reserve(<span class="number">1000</span>); <span class="comment">//先分配好1000个空间</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">        vecStr.push_back(MyString(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;CCtor = &quot;</span> &lt;&lt; MyString::CCtor &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MCtor = &quot;</span> &lt;&lt; MyString::MCtor &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;CAsgn = &quot;</span> &lt;&lt; MyString::CAsgn &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MAsgn = &quot;</span> &lt;&lt; MyString::MAsgn &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 结果</span></span><br><span class="line"><span class="comment">CCtor = 0</span></span><br><span class="line"><span class="comment">MCtor = 1000</span></span><br><span class="line"><span class="comment">CAsgn = 0</span></span><br><span class="line"><span class="comment">MAsgn = 0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>对于会成长的容器，move的性能提升巨大，对于节点类型容器，只要略微提升</li>
</ul>
<h1 id="后面的小结"><a href="#后面的小结" class="headerlink" title="后面的小结"></a>后面的小结</h1><ul>
<li><p>array hashtable 与之前有重复</p>
</li>
<li><p>元编程：对类型进行编程 如类型萃取</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/03/STL%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lclee">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog-lclee">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/03/STL%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">STL与泛型编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-03 08:48:24" itemprop="dateCreated datePublished" datetime="2020-12-03T08:48:24+08:00">2020-12-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-02-26 18:49:51" itemprop="dateModified" datetime="2021-02-26T18:49:51+08:00">2021-02-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!-- markdownlint-disable MD025 -->
<h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av48068999?p=1&amp;t=18">https://www.bilibili.com/video/av48068999?p=1&amp;t=18</a></p>
<h1 id="P1-认识heades、版本、重要资源"><a href="#P1-认识heades、版本、重要资源" class="headerlink" title="P1.认识heades、版本、重要资源"></a>P1.认识heades、版本、重要资源</h1><p><code>Generic Programming</code>(泛型编程,GP)就是使用<code>template</code>(模板)为主要工具来编写程序，STL是泛型编程最成功的作品<br>查询网站 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/">cppReference</a>, <a target="_blank" rel="noopener" href="https://cplusplus.com">CPlusPlus</a>, <a target="_blank" rel="noopener" href="https://gcc.gnu.org">gcc.gnu</a></p>
<h1 id="P2-STL体系结构基础介绍"><a href="#P2-STL体系结构基础介绍" class="headerlink" title="P2.STL体系结构基础介绍"></a>P2.STL体系结构基础介绍</h1><h2 id="STL-六大部件-Component"><a href="#STL-六大部件-Component" class="headerlink" title="STL 六大部件(Component)"></a>STL 六大部件(Component)</h2><p><strong>1.容器  （Containers）</strong><br><strong>2.分配  （Allocators）</strong><br><strong>3.算法  （Algorithms）</strong><br><strong>4.迭代器（Iterators）</strong><br><strong>5.适配器（Adapters）</strong><br><strong>6.仿函数（functors）</strong><br>下面的代码片段展示了这六大部件</p>
<figure class="highlight cpp"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ia[<span class="number">6</span>] = &#123;<span class="number">27</span>, <span class="number">210</span>, <span class="number">12</span>, <span class="number">47</span>, <span class="number">109</span>, <span class="number">83</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>, allocator&lt;<span class="keyword">int</span>&gt;&gt; vi(ia,ia+<span class="number">6</span>); <span class="comment">//vector-容器，allocator-分配器</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; count_if(vi.begin(),vi.end(),   <span class="comment">//begin,end - 迭代器，count_if-算法</span></span><br><span class="line">                        not1(bind2nd(less&lt;<span class="keyword">int</span>&gt;(),<span class="number">40</span>)));<span class="comment">//not1,bind2nd - 算法适配器，less - 仿函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>11行：用数组数据创建容器</li>
<li>12行：输出数组中所有符合条件的数</li>
<li>13行：<code>bind2nd(less&lt;int&gt;(),40)</code> 意思是<code>return (num_in &lt; 40)</code>将小于号的第二参数绑定为20，加上之前的<code>not1</code>取反，意为统计所有大于40的数。</li>
</ul>
<hr>
<ul>
<li><code>复杂度，Complexity，Big-oh</code> :不同的算法，不同的数据结构有不同的复杂度，要根据实际情况选择</li>
<li><p>前闭后开区间：容器都是前闭后开区间，<code>vector.end()</code>不是容器内的元素，是最后一个的下一个，不能进行<code>*(c.end())</code>操作。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通常用法</span></span><br><span class="line">Container&lt;T&gt; c;</span><br><span class="line">···</span><br><span class="line">Container&lt;t&gt;::iterator ite = c.begin()</span><br><span class="line"><span class="keyword">for</span>(; ite != c.end(); ++ite)&#123;···&#125;`</span><br></pre></td></tr></table></figure></li>
<li><p>更推荐range-base for (C++11) 语法糖 方便<code>for</code>循环 语法如下</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(decl:coll)<span class="comment">//decl-声明，coll-容器，集合。将容器中的元素一个个取出来 coll：collection</span></span><br><span class="line">&#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  如下面的例子</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i :&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;)<span class="comment">// &#123;···&#125; 为c++11中新增的容器类型</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vec</span><br><span class="line">···<span class="comment">//给容器添加一些值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> elem:vec)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; elem &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//传值 pass by value</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; elem:vec)</span><br><span class="line">&#123;</span><br><span class="line">    elem *= <span class="number">3</span>; <span class="comment">//传引用 pass by reference 修改容器内部值</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h1 id="P3-容器之分类与各种测试（一）"><a href="#P3-容器之分类与各种测试（一）" class="headerlink" title="P3.容器之分类与各种测试（一）"></a>P3.容器之分类与各种测试（一）</h1></li>
<li><p>Sequence Containers - 序列式容器 : <strong>Array</strong> (fixed number), Vector，Deque，List，<strong>Forward-List</strong></p>
<ul>
<li>array是把语言的数组包装成class</li>
<li>List双向链表:内部有向前、向后两根指针；Forward-List单项链表:内部只有一个指针。单向链表占用空间更少</li>
</ul>
</li>
<li>Associative Containers - 关联式容器：Set/MultiSet，Map/MultiMap，<ul>
<li>内部是用红黑树实现，自平衡，避免某一侧过长</li>
<li>set 只有value，map有key和value</li>
<li>MultiMap 和 MultiSet 里面内容可以重复</li>
</ul>
</li>
<li><strong>Unordered Containers</strong> - 不定序容器(底层是HashTable)：Unordered Set/MultiSet，Unordered Map/MultiMap<ul>
<li>hashtable 常见做法 Separate Chaining，里面放链表</li>
</ul>
</li>
<li>(加粗的是C++11新增特性)</li>
</ul>
<h2 id="测试-Array"><a href="#测试-Array" class="headerlink" title="测试 Array"></a>测试 Array</h2><ol>
<li>创建一个长度为<code>ASIZE</code>的数组，随机放入0-65535之间数值，输出所需时间，数组大小，首尾数据，和数据地址。对应<code>3 ~ 14 行</code></li>
<li>输入一个想要查找的数。查找前先对数组做快速排序(qsort),再输出上一步输出的那些信息。对应<code>16 ~ 28 行</code></li>
<li>对排序好的数组进行二分查找，输出消耗时间和结果。对应<code>30-37行</code></li>
</ol>
<figure class="highlight cpp"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_array</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\ntest_array()......... \n&quot;</span>;</span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="keyword">long</span>, ASIZE&gt; c;<span class="comment">//const long ASIZE = 1000000;</span></span><br><span class="line">    <span class="keyword">clock_t</span> timeStart = clock();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; ASIZE; ++i) &#123;</span><br><span class="line">        c[i] = rand() % <span class="number">65535</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;milli-seconds:&quot;</span> &lt;&lt; (clock() - timeStart) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;array.size()= &quot;</span> &lt;&lt; c.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;array.front()= &quot;</span> &lt;&lt; c.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;array.back()= &quot;</span> &lt;&lt; c.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;array.data()= &quot;</span> &lt;&lt; c.data() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> target = get_a_target_long();<span class="comment">//输入一个数</span></span><br><span class="line">    timeStart = clock();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;-------------------before qsort: --------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    qsort(c.data(), ASIZE, <span class="keyword">sizeof</span>(<span class="keyword">long</span>), compareLongs);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;qsort(), milli-seconds: &quot;</span> &lt;&lt; (clock() - timeStart) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;---------------------after qsort:------------------ &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;array.size()= &quot;</span> &lt;&lt; c.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;array.front()= &quot;</span> &lt;&lt; c.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;array.back()= &quot;</span> &lt;&lt; c.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;array.data()= &quot;</span> &lt;&lt; c.data() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    timeStart = clock();</span><br><span class="line">    <span class="keyword">long</span>* pItem = (<span class="keyword">long</span>*)bsearch(&amp;target, (c.data()), ASIZE, <span class="keyword">sizeof</span>(<span class="keyword">long</span>), compareLongs);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;bsearch(), milli-seconds: &quot;</span> &lt;&lt; (clock() - timeStart) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pItem != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;found, &quot;</span> &lt;&lt; *pItem &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;not found!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="P4-容器之分类与各种测试-二"><a href="#P4-容器之分类与各种测试-二" class="headerlink" title="P4.容器之分类与各种测试(二)"></a>P4.容器之分类与各种测试(二)</h1><h2 id="使用容器vector"><a href="#使用容器vector" class="headerlink" title="使用容器vector"></a>使用容器vector</h2><ul>
<li>使用.push_back()从后端放入数据</li>
<li>vector 空间总是2倍增长，如放入入5个元素时，vector会先拓展成8个，再放入第五个。因此容量总是≥元素个数</li>
<li>当空间装不下要容纳的数据的时会自动拓展，并将原来的数据拷贝到新的空间，然后释放旧的空间</li>
<li>vector.size() - 元素个数， vector.capacity() - 容量</li>
<li><code>12-19行</code>使用<code>try-catch</code>因为可能内存分配失败。</li>
<li><code>31-40行</code>使用<code>::find()</code>直接遍历查找；<code>43-53行</code>使用sort先排序再二分查找</li>
<li>排序通常很耗时间，有时直接查找更快。</li>
</ul>
<figure class="highlight cpp"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> jj02</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_vector</span><span class="params">(<span class="keyword">long</span>&amp; totalCount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\ntest_vector()......... \n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; c;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">clock_t</span> timeStart = clock();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; totalCount; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">&quot;%d&quot;</span>, rand() % <span class="number">65535</span>);</span><br><span class="line">        c.push_back(<span class="built_in">string</span>(buf));</span><br><span class="line">        &#125; <span class="keyword">catch</span>(<span class="built_in">std</span>::exception&amp; e) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;i=&quot;</span> &lt;&lt; i &lt;&lt; e.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 曾经最高 i=58389486 then std::bad_alloc</span></span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;milli-seconds:&quot;</span> &lt;&lt; (clock() - timeStart) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;vector.size()= &quot;</span> &lt;&lt; c.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;vector.front()= &quot;</span> &lt;&lt; c.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;vector.back()= &quot;</span> &lt;&lt; c.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;vector.data()= &quot;</span> &lt;&lt; c.data() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;vector.capacity()= &quot;</span> &lt;&lt; c.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> target = get_a_target_string();</span><br><span class="line">    &#123;</span><br><span class="line">    timeStart = clock();</span><br><span class="line">    <span class="keyword">auto</span> pItem = ::find(c.begin(), c.end(), target);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;::find(), mill-seconds: &quot;</span> &lt;&lt; (clock()-timeStart) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pItem != c.end())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;found, &quot;</span> &lt;&lt; *pItem &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;not found! &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">    timeStart = clock();</span><br><span class="line">    </span><br><span class="line">    sort(c.begin(), c.end());</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">string</span>* pItem = (<span class="built_in">string</span>*)bsearch(&amp;target, (c.data()), c.size(), <span class="keyword">sizeof</span>(<span class="built_in">string</span>), compareStrings);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sort()+bsearch(), milli-seconds: &quot;</span> &lt;&lt; (clock() - timeStart) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pItem != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;found, &quot;</span> &lt;&lt; *pItem &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;not found!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="P5-容器之分类与各种测试-三"><a href="#P5-容器之分类与各种测试-三" class="headerlink" title="P5.容器之分类与各种测试(三)"></a>P5.容器之分类与各种测试(三)</h1><h2 id="使用容器-list"><a href="#使用容器-list" class="headerlink" title="使用容器 list"></a>使用容器 list</h2><ul>
<li>list有最大容量，可以调用<code>list.max_size()</code>得到（不同的电脑不同）</li>
<li>list自带成员函数sort()（class内自带的<code>sort</code>通常比全局的<code>sort</code>效率高）</li>
<li>具体测试程序与vector类似</li>
</ul>
<h2 id="使用容器-forward-list"><a href="#使用容器-forward-list" class="headerlink" title="使用容器 forward_list"></a>使用容器 forward_list</h2><ul>
<li>forward_list 只允许前端放入 .push_front(),查看前端 forward_list.front()</li>
<li>不提供查询大小和末位数据。(没有forward_list.back(), forward_list.size())</li>
<li>forward_list含有sort()</li>
<li>gnu中还有 <code>slist</code> 用法与其相同(gnu 很早之前在拓展库中加入slist，C++11才加入forward_list)</li>
</ul>
<h2 id="使用容器-deque"><a href="#使用容器-deque" class="headerlink" title="使用容器 deque"></a>使用容器 deque</h2><ul>
<li>deque 可以向两边扩充，但是在底层是分段(buffer)连续的，通过操作符重载来判断是否到达 buffer 的边界并进入到下一个 buffer。</li>
<li>每次扩充一个 buffer (不同于vector每次翻倍，list每次增加一个)</li>
<li>deque 没有sort函数，需要调用 <code>::sort()</code></li>
<li>deque 可以双向进出</li>
<li>容器 <code>stack</code> 和 <code>queue</code> 也是调用 <code>deque</code>实现的，因此也有人将<code>stack</code> 和 <code>queue</code> 成为 <code>Container Adapters</code> 容器适配器</li>
<li><code>stack</code> 先进后出 和 <code>queue</code> 先进先出 的特性，因此不提供 <code>iterator</code>，也无法查找和排序。</li>
</ul>
<h1 id="P6-容器之分类与各种测试-四"><a href="#P6-容器之分类与各种测试-四" class="headerlink" title="P6.容器之分类与各种测试(四)"></a>P6.容器之分类与各种测试(四)</h1><h2 id="使用容器-multiSet"><a href="#使用容器-multiSet" class="headerlink" title="使用容器 multiSet"></a>使用容器 multiSet</h2><ul>
<li>调用 <code>insert()</code>放入数据，红黑树会找到其合适的位置。</li>
<li>数据在放入的时候已经做好排序,插入的时候慢一些</li>
<li>类内部的find()函数远远快于全局的::find()</li>
</ul>
<h2 id="使用容器multiMap"><a href="#使用容器multiMap" class="headerlink" title="使用容器multiMap"></a>使用容器multiMap</h2><ul>
<li><code>multimap&lt;long,string&gt; c;</code> 初始化 key 和 value 的类型</li>
<li><code>c.insert(pair&lt;long,string&gt;(i,buf))</code>, 要插入<code>pair</code>类型数据</li>
<li>multimap 不可使用[] 做 insertion</li>
</ul>
<h2 id="使用容器-unordered-multimap"><a href="#使用容器-unordered-multimap" class="headerlink" title="使用容器 unordered_multimap"></a>使用容器 unordered_multimap</h2><ul>
<li>在以前的<code>gnu c</code>中提供的名称叫做<code>hash_multimap</code>（底层由散列表实现）</li>
<li>bucket 一定比 element 多。一旦元素数量达到 bucket 数量时，就会重新申请大一倍的空间，将元素重新打散，放到篮子里</li>
<li>不一定每一个bucket里都有元素，有的bucket有多个，有的为空。（但是 bucket 中存放的链不能太长）</li>
</ul>
<h2 id="使用容器set，map"><a href="#使用容器set，map" class="headerlink" title="使用容器set，map"></a>使用容器set，map</h2><ul>
<li>底层由红黑树实现</li>
<li>放入key不能重复</li>
<li>对set来说，key和value相同</li>
<li>map 可以使用 <code>c[i] = string(buf)</code> 进行插入，内部会将<code>i，buf</code>组成一个 pair 类型数据</li>
</ul>
<h2 id="同样还有-unordered-set-和-unordered-map"><a href="#同样还有-unordered-set-和-unordered-map" class="headerlink" title="同样还有 unordered_set 和 unordered_map"></a>同样还有 unordered_set 和 unordered_map</h2><ul>
<li>底层由hash table实现，特性与set和map相同</li>
</ul>
<h1 id="P7-分配器之测试"><a href="#P7-分配器之测试" class="headerlink" title="P7.分配器之测试"></a>P7.分配器之测试</h1><ul>
<li>容器背后需要 allocator 来支持对内存的使用，容器有默认的分配器，通常我们不需要关心。具体的内存管理在另一门课详细介绍</li>
<li>allocator 负责内存的申请与释放，不推荐个人使用。可以直接使用 <code>new</code> 和 <code>delete</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc = <span class="built_in">std</span>::allocator&lt;_Tp&gt;&gt;</span><br><span class="line">    class <span class="built_in">vector</span>:protected_Vector_base&lt;_Tp, _Alloc&gt;</span><br></pre></td></tr></table></figure>
<h1 id="P8-源码分布-vc-gcc"><a href="#P8-源码分布-vc-gcc" class="headerlink" title="P8.源码分布(vc,gcc)"></a>P8.源码分布(vc,gcc)</h1><ul>
<li>vc 的源码文件在<code>\include</code>, gnu c++ 在 <code>\4.9.2\include</code></li>
</ul>
<h1 id="P9-OOP-面向对象编程-vs-GP-泛型编程"><a href="#P9-OOP-面向对象编程-vs-GP-泛型编程" class="headerlink" title="P9.OOP(面向对象编程) vs. GP(泛型编程)"></a>P9.OOP(面向对象编程) vs. GP(泛型编程)</h1><ul>
<li><p><strong>OOP</strong> 企图将 <code>datas</code> 和 <code>methods</code> 关联在一起，例如 <code>list.sort()</code></p>
</li>
<li><p><strong>GP</strong> 却是将 <code>datas</code> 与 <code>methods</code> 分开来,  <code>sort(vec.begin(), vec.end())</code> 而不是 <code>vector.sort()</code></p>
<ul>
<li>采用 GP 的优点： <code>Containers</code> 和 <code>Algorithms</code> 团队可以各自工作，通过 <code>Iterators</code> 沟通</li>
</ul>
</li>
<li><p>为什么 <code>list</code> 不能用 <code>::sort</code> ? 全局函数<code>::sort</code> 对迭代器的类型有一定的要求，如实现指针+长度的地址跳转，而链表是通过指针相连，在内存中的地址并不连续，无法满足使用 <code>::sort</code> 的条件因此需要使用class内部自带的 <code>sort()</code> 。</p>
</li>
<li><p>所有 <code>Algorithms</code>，器内最终涉及元素本身的操作，无非就是比大小。</p>
</li>
</ul>
<h1 id="P10-技术基础：操作符重载-and-模板（泛化，全特化，偏特化）"><a href="#P10-技术基础：操作符重载-and-模板（泛化，全特化，偏特化）" class="headerlink" title="P10.技术基础：操作符重载 and 模板（泛化，全特化，偏特化）"></a>P10.技术基础：操作符重载 and 模板（泛化，全特化，偏特化）</h1><ul>
<li><p>不是所有的操作符都能重载，需要重载之前最好先去查一下reference。（像一般的加减乘除大小，都是可以重载的，对于特殊的符号要去查）</p>
</li>
<li><p>函数模板</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">stone</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      stone(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> we) : _w(w), _h(h), _weight(we) &#123;&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> stone&amp; rhs) <span class="keyword">const</span></span><br><span class="line">      &#123; <span class="keyword">return</span> _weight &lt; rhs._weight; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">int</span> _w, _h, _weight; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> T&amp; <span class="title">min</span><span class="params">(<span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> b &lt; a : b , a; &#125;</span><br><span class="line"></span><br><span class="line">stone r1(2,3,6), r2(3,3,9), r3；</span><br><span class="line">r3 = min(r1, r2);</span><br></pre></td></tr></table></figure></li>
<li><p>当调用 <code>min(r1, r2)</code> 时，编译器会对 <code>function template</code> 进行实参推导 ( argument deduction )，结果可知 <code>T</code> 的类型为 <code>stone</code>，于是调用 <code>stone::operator&lt;()</code></p>
</li>
<li><p>空心的 <code>template&lt;&gt;</code> 就是模板特化，具体特化的例子详见C++笔记</p>
</li>
<li><p>偏特化（部分特化）特化就是将<code>template&lt;···&gt;</code>尖括号中的参数指定，减少泛化的参数。（个数和范围的特化） 具体特化的例子详见C++笔记</p>
</li>
</ul>
<h1 id="P11-分配器"><a href="#P11-分配器" class="headerlink" title="P11.分配器"></a>P11.分配器</h1><ul>
<li><p><code>operator new()</code> 底层都是调用 <code>malloc()</code> 来实现</p>
</li>
<li><p><code>malloc()</code> 分配的内从往往比我们需要的多，还有一些对齐，管理的额外开销(当我们存入的元素很小时，开销可能比元素更占空间)</p>
</li>
<li><p>分配器的底层都是调用 <code>operator new()</code></p>
</li>
<li><p>vc6，gnu c2.9 bc++ 标准库中的 <code>allocator</code> 没有任何独特设计，就是调用 <code>malloc()， free（）</code>来分配和释放内存。</p>
</li>
<li><p>分配器释放内存时，不仅仅要传递指针，还要传递大小，因此不适合我们去使用它，但是却有利于容器来使用（后面讲解）</p>
</li>
<li><p>由于标准库中的 <code>allocator</code> 会带来巨大的额外开销，gnu c2.9中并没有采用它来实现容器，而是使用了自己定义的分配器 <code>alloc</code></p>
</li>
<li><p>由于容器中的元素大小都是一样的，因此不必为每一个元素都添加开销（也就是说不是每个元素都要去调用 <code>malloc</code> 申请内存），gnu c2.9 中的 <code>alloc</code> 向系统申请整块大内存，在分割成不同大小，给容器使用，来减小额外开销。（内部具体特性在内存管理课程讲解）</p>
</li>
<li><p>处于某种原因在gnu c4.9中没有使用高效的alloc作为容器的默认分配器，但是我们仍然可以使用它，它被改名为<code>__pool_alloc</code>, 例如<code>vector&lt;string,__gnu_cxx::__pool_alloc&lt;string&gt;&gt; vec;</code></p>
</li>
</ul>
<h1 id="P12-容器之间的实现关系与分类-1"><a href="#P12-容器之间的实现关系与分类-1" class="headerlink" title="P12.容器之间的实现关系与分类(1)"></a>P12.容器之间的实现关系与分类(1)</h1><ul>
<li>简单回顾容器详见P3。</li>
<li>在不同版本下容器的大小sizeof()不同</li>
</ul>
<h1 id="P13-深度探索list-1-上"><a href="#P13-深度探索list-1-上" class="headerlink" title="P13.深度探索list (1) 上"></a>P13.深度探索list (1) 上</h1><ul>
<li><p><code>operator++()</code> 是 <code>prefix form</code> 前置型 例如 ++i， <code>operator++(int)</code> 是 <code>postfix form</code> 后置类型，例如i++</p>
</li>
<li><p>list’s iterator gnu gcc 2.9版本</p>
  <figure class="highlight cpp"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">list_node</span>&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">void</span>* void_pointer;</span><br><span class="line">    void_pointer prev;</span><br><span class="line">    void_pointer next;</span><br><span class="line">    T data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Ref</span>, <span class="keyword">class</span> <span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">list_iterator</span>&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> __list_iterator&lt;T, Ref, Ptr&gt; self;</span><br><span class="line">    <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;<span class="comment">//(1)</span></span><br><span class="line">    <span class="keyword">typedef</span> T value_type;                                <span class="comment">//(2)</span></span><br><span class="line">    <span class="keyword">typedef</span> Ptr pointer;                                 <span class="comment">//(3)</span></span><br><span class="line">    <span class="keyword">typedef</span> Ref reference;                               <span class="comment">//(4)</span></span><br><span class="line">    <span class="keyword">typedef</span> __list_node&lt;T&gt;* link_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;                   <span class="comment">//(5)</span></span><br><span class="line"></span><br><span class="line">    link_type node;</span><br><span class="line"></span><br><span class="line">    reference <span class="keyword">operator</span>*() <span class="keyword">const</span>&#123;<span class="keyword">return</span> (*node).data;&#125;</span><br><span class="line">    pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span>&#123;<span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*());&#125;</span><br><span class="line">    self&amp; <span class="keyword">operator</span>++() &#123;node = (link_type)((*node).next); <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">    self <span class="keyword">operator</span>++(<span class="keyword">int</span>)&#123;self tmp = *<span class="keyword">this</span>; ++*<span class="keyword">this</span>, <span class="keyword">return</span> tmp;&#125;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>几乎所有的容器迭代器要进行(1)-(5)的 <code>typedef</code></p>
</li>
<li><p><code>25</code>行 <code>self temp = *this</code> <em>不是操作符重载，这里是变量声明，解释为构造函数的参数;以及后面的 `++</em>this<code>也不是，</code>*this<code>是重载操作符</code>operator++()`的参数</p>
</li>
<li><p>前置++和后置++ 返回类型不同是因为要与 int 的操作保持一致。int 不允许 <code>(i++)++</code> 但可以 <code>++(++i)</code></p>
</li>
<li><p>重载 <code>operator*()</code> 是为了取出数据 <code>21</code>行</p>
</li>
</ul>
<h1 id="P14-深度探索list-1-下"><a href="#P14-深度探索list-1-下" class="headerlink" title="P14.深度探索list (1) 下"></a>P14.深度探索list (1) 下</h1><ul>
<li>在 gcc4.9 中做了一些改进，如第<code>__list_iterator</code>行只需传入一个模板参数，__list_node 中的指针类型也不在时void，而是指向自己本身这种类型。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">List_iterator</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> _Tp* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp&amp; reference;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">List_node_base</span> &#123;</span></span><br><span class="line">    _List_node_base* _M_next;</span><br><span class="line">    _List_node_base* _M_prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">List_node</span>:</span><span class="keyword">public</span> _List_node_base</span><br><span class="line">&#123;</span><br><span class="line">    _Tp _M_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>双向链表内部其实是环状的，由不能访问节点数据end()连接两头形成环状结构</li>
</ul>
<h1 id="P15-迭代器的设计原则和-Iterator-Traits的作用与设计"><a href="#P15-迭代器的设计原则和-Iterator-Traits的作用与设计" class="headerlink" title="P15.迭代器的设计原则和 Iterator Traits的作用与设计"></a>P15.迭代器的设计原则和 Iterator Traits的作用与设计</h1><ul>
<li><p>迭代器是沟通算法与容器的桥梁，Iterator 必须提供5种 <code>associated types</code>才能使算法正确工作，(就是P13标出那5种)</p>
</li>
<li><p>如果传入的不是 iterator，而是一个 native pointer (可以理解为一个退化的迭代器)，因此需要插入一个中间层 <code>Iterator Traits</code> 利用偏特化来分离class iterator 和 non-class iterator。</p>
  <figure class="highlight cpp"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>&#123;</span> <span class="comment">//traits 是特征的意思</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个 partial specialization</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>&lt;</span>T*&gt;&#123;</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>&lt;</span><span class="keyword">const</span> T*&gt;&#123;</span><br><span class="line">    <span class="keyword">typedef</span> T value_type; <span class="comment">//注意是T而不是const T</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>注意第14行是<code>T</code>而不是<code>const T</code>，原因是在算法中这些类型要用来声明变量，若为<code>const</code>就无法进行后续的处理</li>
</ul>
</li>
<li><p>于是当需要知道<code>I</code>的value type 时便可以向下放这么写,当I是<code>class iterator</code>时，调用上方<code>1-4</code>行；若是pointer to T，则调用<code>7-10</code>行；若是pointer to const T，则调用<code>12-15</code>行</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> I,···&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">algorithm</span><span class="params">(···)</span></span>&#123;</span><br><span class="line">    <span class="keyword">typename</span> iterator_traits&lt;I&gt;::value_type v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>上面举例一个特性，其他的5个也是相同的操作。指针类型偏特化时，一般是随机读取型tag <code>typedef random_access_iterator_tag iterator_category</code></p>
</li>
<li><p>除了 iterator traits 还有其他各式各类的traits，如 type traits，char traits， allocator traits ···</p>
</li>
</ul>
<h1 id="P16-vector深度探索-1"><a href="#P16-vector深度探索-1" class="headerlink" title="P16.vector深度探索(1)"></a>P16.vector深度探索(1)</h1><ul>
<li><p>vector 的扩充不是原地扩充，而是申请一块更大的内存，再把原来的数据复制过去，实现扩充。</p>
</li>
<li><p>vector 由三个指针来维护，<code>start</code>， <code>finish</code>，<code>end_of_storage</code>。因此 <code>size</code> = <code>finish</code> - <code>start</code>， <code>capacity</code> = <code>end_of_storage</code> - <code>start</code>。</p>
</li>
<li><p>当调用<code>push_back</code>时，若<code>finish</code>==<code>end_of_storage</code>，则调用<code>insert_aux()</code>插入辅助函数。<code>insert_aux()</code>会重新申请内存，拷贝原有数据，同时还要拷贝当前数据之后的数据。（<code>insert_aux()</code>还会被<code>insert()</code>函数调用，vector中间插入后扩充，还要复制插入点之后的元素），再释放原来的vector，重新调整<code>start</code>， <code>finish</code>，<code>end_of_storage</code>三根指针指向新的位置。</p>
</li>
</ul>
<h2 id="vector’s-iterator"><a href="#vector’s-iterator" class="headerlink" title="vector’s iterator"></a>vector’s iterator</h2><ul>
<li>由于vector是连续内存空间，因此迭代器无需设计的一个<code>class</code>，使用一个指针即可。（上一章讲的链表在内存中不连续）</li>
</ul>
<figure class="highlight cpp"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//G2.9</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> value_type* iterator;<span class="comment">//T*</span></span><br><span class="line">···</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">···</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator ite = vec.begin();</span><br><span class="line">iterator_traits&lt;ite&gt;::iterator_category</span><br></pre></td></tr></table></figure>
<ul>
<li><p>上面最后行就是通过萃取机 <code>iterator_traits</code> 获取指针类型的5中特征。（P15中的指针类型萃取example）</p>
</li>
<li><p>在G4.9中 vector的实现非常复杂，但是功能完全一致，多了很多类的继承和复合</p>
</li>
</ul>
<h1 id="P17-array，forward-list深度探索-1"><a href="#P17-array，forward-list深度探索-1" class="headerlink" title="P17. array，forward_list深度探索(1)"></a>P17. array，forward_list深度探索(1)</h1><h2 id="容器array"><a href="#容器array" class="headerlink" title="容器array"></a>容器array</h2><ul>
<li>数组是C就已经提供的数据结构，将其封装成容器，是为了方便算法的调用。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TR1  c++技术报告1，在c++98 和 C++11 之间的版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="built_in">std</span>::<span class="keyword">size_t</span> _Nm&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">array</span>&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> _Tp         value_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp*        pointer;</span><br><span class="line">    <span class="keyword">typedef</span> value_type* iterator;<span class="comment">//是native pointer G2.9也是如此</span></span><br><span class="line"></span><br><span class="line">    value_type _M_instance[_Nm ? _Nm :<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> iterator(&amp; _M_instance[<span class="number">0</span>]);&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> iterator(&amp; _M_instance[_Nm]);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>与普通的数组一样 array没有ctor 和dtor.</p>
</li>
<li><p>G4.9版本的array有复杂的继承关系，但实质没变。之前介绍过双向链表list，forwa_list 不在多说。</p>
</li>
</ul>
<h1 id="P18-deque、queue-和-stack深度探索-上"><a href="#P18-deque、queue-和-stack深度探索-上" class="headerlink" title="P18.deque、queue 和 stack深度探索(上)"></a>P18.deque、queue 和 stack深度探索(上)</h1><ul>
<li><p>deque 表现为一个双向可拓展的结构，其实在底层使用vector保存各个缓冲区的信息（这个vector相当于一个控制中心），各个缓冲区在内存中其实是不连续的，通过vector中保存的信息实现不同缓冲区的切换，对用户来说就像是连续空间一样。</p>
</li>
<li><p>比较优秀的一点是deque的insert()在插入时会判断插入位置离哪一端更近，从而减少移动元素带来的开销</p>
</li>
</ul>
<h1 id="P19-deque、queue-和-stack深度探索-下）"><a href="#P19-deque、queue-和-stack深度探索-下）" class="headerlink" title="P19.deque、queue 和 stack深度探索(下）"></a>P19.deque、queue 和 stack深度探索(下）</h1><ul>
<li>deque 模拟连续空间都是 deque iterators 的功劳。 iterator中有4个成员：<code>cur</code>-当前元素，<code>first</code>-缓冲区开始地址，<code>last</code>-缓冲区结尾地址，<code>node</code>-vector中的下一个节点</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">difference_type <span class="keyword">operator</span>-(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> difference_type(buffer_size())*(node-x.node<span class="number">-1</span>)+(cur-first)+(x.last-x.cur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>计算两个元素像差的地址：像差缓冲区数量*缓冲区大小+起始buffer中元素数量+结束buffer中元素数量。</p>
</li>
<li><p>后置自增/减会调用前置自增/减。</p>
</li>
<li><p>当控制中心vector需要扩充时，原来的数据复制到新的中间位置，为两头留下增长余量。</p>
</li>
<li><p>queue 和 stack 内含了一个deque，减少了某些功能实现的</p>
</li>
<li><p>queue 和 stack 都可以选择list 和deque作为底层结构，默认deque。</p>
</li>
<li><p>queue 和 stack 不允许遍历，也不提供迭代器。</p>
</li>
<li><p>stack 可以选择 vector 作为底层，queue则不能。</p>
</li>
<li><p>queue 和 stack 都不能选择set或map做底层</p>
</li>
</ul>
<h1 id="P20-RB-tree深度探索"><a href="#P20-RB-tree深度探索" class="headerlink" title="P20.RB-tree深度探索"></a>P20.RB-tree深度探索</h1><ul>
<li><p>Red-Black tree(红黑树) 是高度平衡二分搜索树，排列规则有利于 search 和 insert，并且保持平衡，不会使任何一个节点太深。</p>
</li>
<li><p>不应该使用 rb_tree 的 iterator 改变元素值（因为元素有严谨的排序），但是在变成层面并未禁止此事。这是为了后续的map考量，map 中允许修改元素的 data，只有元素的 key 才是不可修改的。</p>
</li>
<li><p>rb_tree 提供两种插入操作： <code>insert_unique()</code> 和 <code>insert_equal()</code>, 前者表示插入的key独一无二，后者表示插入的key可重复，</p>
</li>
<li><p>红黑树中的 value 是包含 key 和 data 的整体。</p>
</li>
<li><p>G2.9 - G4.9 容器的实现都变得复杂，包含了多个类的继承与复合。虽然复杂不利于学习但是遵循了一个面向对象的原则 <code>handle and body</code> 桥接模式。抽象部分与实现部分分离。</p>
</li>
</ul>
<h1 id="P21-set-multiset-深度探索"><a href="#P21-set-multiset-深度探索" class="headerlink" title="P21.set multiset 深度探索"></a>P21.set multiset 深度探索</h1><ul>
<li><p>set/multiset 以 rb_tree 为底层结构，因此有元素自动排序的特性。set/multiset 元素的 value 和 key 合一；value 就是 key</p>
</li>
<li><p>set/multiset 提供遍历操作，按照正常规则 ++ite 遍历可以获得排序状态</p>
</li>
<li><p>set/multiset 无法通过 iterator 修改元素值（不同于rb_tree）</p>
</li>
<li><p>set 的 key 必须是独一无二的，底层调用的是红黑树的 <code>insert_unique()</code>; multiset 的key 可以重复，底层调用的是红黑树的 <code>insert_equal()</code></p>
</li>
<li><p>set 内的 iterator 是 <code>const_iterator</code> 类型，防止用户通过迭代器修改set的内容。</p>
</li>
<li><p>set所有的操作都是调用底层的红黑树完成，从这个意义上看，set也能称之为 Container Adapter</p>
</li>
</ul>
<h1 id="P22-map-multimap-深度探索"><a href="#P22-map-multimap-深度探索" class="headerlink" title="P22.map,multimap 深度探索"></a>P22.map,multimap 深度探索</h1><ul>
<li><p>map 底层也是由红黑树实现，<code>typedef pair&lt;const Key, T&gt; value_type</code> 来实现只允许改 data，不允许改 Key</p>
</li>
<li><p>map 独特的 <code>operator[](const key_type&amp; __k)</code>, 与python中的字典相同，若key存在则返回data，若不存在则创建（multimap 不允许用[]）。</p>
</li>
</ul>
<h1 id="P23-hashtable-深度探索-上"><a href="#P23-hashtable-深度探索-上" class="headerlink" title="P23.hashtable 深度探索(上)"></a>P23.hashtable 深度探索(上)</h1><ul>
<li><p>obj 通过<code>散列函数-hash function</code> 计算出<code>编号-hash code</code>，再对 hashtable 的长度求余数，放到 hashtable bucket中。若出现重复则使用链表串联。</p>
</li>
<li><p><code>Separate Chaining</code> 虽然 list 是线性搜索空间，如果list足够小，搜索速度任然很快。</p>
</li>
<li><p>hashtable 的长度通常为质数，在gnu c中默认值一般为53.</p>
</li>
<li><p>当 obj 个数大于hashtable的长度时，hashtable 将扩充到两倍容量相近的那个质数的大小，最接近 53*2 的质数为97（stl里有质数表，直接查表就即可），因此hashtable扩充到 97，在对所有元素重新打散 rehashing</p>
</li>
<li><p>与 deque 一样，<code>hashtable</code>内部的控制中心是 vector 类型的 buckets， <code>iterator</code> 在进行 <code>++</code>的操作，指向链表的末位时，能回到控制中心，再指向下一个元素。</p>
</li>
</ul>
<h1 id="P23-hashtable-深度探索-下"><a href="#P23-hashtable-深度探索-下" class="headerlink" title="P23.hashtable 深度探索(下)"></a>P23.hashtable 深度探索(下)</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">hashtable&lt;<span class="keyword">const</span> <span class="keyword">char</span>*,</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>*,</span><br><span class="line">        hash&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;,</span><br><span class="line">        identity&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;,</span><br><span class="line">        eqstr</span><br><span class="line">        alloc&gt;</span><br><span class="line">ht(<span class="number">50</span>,hash&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(),eqstr());</span><br><span class="line">ht.insert_unique(<span class="string">&quot;kiwi&quot;</span>);</span><br><span class="line">ht.insert_unique(<span class="string">&quot;plum&quot;</span>)</span><br><span class="line">ht.insert_unique(<span class="string">&quot;apple&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eqstr</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s1,<span class="keyword">const</span> <span class="keyword">char</span>* s2)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">strcmp</span>(s1,s2)==<span class="number">0</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>比较 <code>c-string</code> 是否相等可用<code>strcmp</code>，但返回值是<code>-1,0,1</code>，不是bool，需要重新包装。</p>
</li>
<li><p>默认的类型都有特化版本的 hash 函数。对于自定义的类型要自己设计 hash-function（使hash足够乱，足够随机）。注意标准库没有提供 <code>hash&lt;std::string&gt;</code></p>
</li>
</ul>
<h1 id="P25-这节课的视频跟之前重复了"><a href="#P25-这节课的视频跟之前重复了" class="headerlink" title="P25.这节课的视频跟之前重复了"></a>P25.这节课的视频跟之前重复了</h1><h1 id="P26-unordered-容器概念"><a href="#P26-unordered-容器概念" class="headerlink" title="P26.unordered 容器概念"></a>P26.unordered 容器概念</h1><ul>
<li><p>之前所有 hash 开头的数据结构在c++11中 都以 unordered_ 开头。</p>
</li>
<li><p>可以调用 <code>.bucket_size(i)</code> 查看第 <code>i</code> 个 bucket 中的元素数量。</p>
</li>
</ul>
<p>到此为止第二讲容器的探讨全局完成</p>
<hr>
<h1 id="P27-算法的形式"><a href="#P27-算法的形式" class="headerlink" title="P27.算法的形式"></a>P27.算法的形式</h1><ul>
<li><p>算法 - function template， 目的是为了处理容器的内容</p>
</li>
<li><p>算法无法看到容器的所有内容，需要通过迭代器来进行访问。</p>
</li>
</ul>
<h1 id="P28-迭代器的分类"><a href="#P28-迭代器的分类" class="headerlink" title="P28.迭代器的分类"></a>P28.迭代器的分类</h1><ul>
<li><p>五种 iterator category,表示迭代器的移动方式。除了output外，其他四个自下而上继承</p>
<ul>
<li>input_iterator_tag, output_iterator_tag</li>
<li>forward_iterator_tag</li>
<li>bidirectional_iterator_tag</li>
<li>random_access_iterator_tag</li>
</ul>
</li>
<li><p>input_iterator_tag, output_iterator_tag 对应 istream_iterator，ostream_iterator 后面的课程会深入讲解</p>
</li>
<li><p>可以通过 <code>typeid(ite).name()</code> 来查看迭代器的类型，但是输出还会附加一些编译过程的其他信息，取决于编译器的实现。</p>
</li>
</ul>
<h1 id="P29-迭代器分类对算法的影响"><a href="#P29-迭代器分类对算法的影响" class="headerlink" title="P29.迭代器分类对算法的影响"></a>P29.迭代器分类对算法的影响</h1><ul>
<li><p>如需要求两个指针之间的距离，对于可随机访问的迭代器来说就是两个地址相减，若不是可随机访问的，则需要一直<code>++</code>使两个指针地址相同来计算距离。</p>
</li>
<li><p>又例如前进<code>advance()</code>这个函数，若是可随机访问，则直接地址+偏移量，否则就要一个一个跳转</p>
</li>
<li><p>迭代器种类的继承关系使得在不同函数重载时，便于确定是哪一种类型。（有的函数只有<code>random_access</code>和<code>input</code>类型的两种版本，那么forward和bidirectional也就会归为<code>input</code>这一类。</p>
</li>
<li><p>function template 没有所谓的特化，用的都是重载的手法。例如常用的copy，若是const char* 这种类型则调用 <code>memmove()</code>-(速度极快)，若是普通的迭代器，且构造函数不重要，那么也调用<code>memmove()</code>，否则就要一个一个创建。</p>
</li>
<li><p>算法源码中对 <code>iterator_category</code>的暗示: 原则上算法可以接受任意类型的迭代器，但是算法参数的声明可能会暗示我们要输入的类型</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>&gt;</span> </span><br><span class="line">sort(RandomAccessIterator first,RandomAccessIterator last)</span><br></pre></td></tr></table></figure>
<h1 id="P30-算法源码剖析"><a href="#P30-算法源码剖析" class="headerlink" title="P30.算法源码剖析"></a>P30.算法源码剖析</h1></li>
<li><p>标准库中的算法前两个参数通常是容器的两个迭代器（指针-退化的迭代器）</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>,<span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function">T <span class="title">accumulate</span><span class="params">(InputIterator first, InputIterator last, T init)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(; first != last; ++first)</span><br><span class="line">        init = init + *first;<span class="comment">//将元素值累加到 init 上</span></span><br><span class="line">    <span class="keyword">return</span> init；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class InputIterator,class T,class BinaryOperation)</span><br><span class="line">T accumulate(InputIterator first, InputIterator last, T init, BinaryOperation binary_op)<span class="comment">//binary_op 接受两个参数的函数</span></span><br><span class="line">    <span class="keyword">for</span>(; first != last; ++first)</span><br><span class="line">        init = binary_op(init + *first);<span class="comment">//将元素值累加到 init 上</span></span><br><span class="line">    <span class="keyword">return</span> init；</span><br></pre></td></tr></table></figure>
<ul>
<li>以上是标准库的一个算法，第二个重载版本可以调用自定义的函数进行累计算操作。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myfunc</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> x+<span class="number">2</span>*y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myclass</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> x+<span class="number">3</span>*y;&#125;</span><br><span class="line">&#125;myobj;<span class="comment">//仿函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> init = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> num[] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; accumulate(nums,nums+<span class="number">3</span>,init);<span class="comment">//160</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; accumulate(nums,nums+<span class="number">3</span>,init,minus&lt;<span class="keyword">int</span>&gt;());<span class="comment">//40</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; accumulate(nums,nums+<span class="number">3</span>,init,myfunc)；<span class="comment">//220</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; accumulate(nums,nums+<span class="number">3</span>,init,myobj);<span class="comment">//280 </span></span><br></pre></td></tr></table></figure>
<ul>
<li>binary_search 之前要验证是否已经排好序。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">binary_search</span><span class="params">(ForwardIterator first, ForwardIterator last, <span class="keyword">const</span> T&amp; val)</span></span>&#123;</span><br><span class="line">    first = <span class="built_in">std</span>::lower_bound(first, last, val);</span><br><span class="line">    <span class="keyword">return</span>(first!=last &amp;&amp; !(val&lt;*first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>lower_bound 返回的是找到元素的最小的位置（里面可能有重复，找最大的位置为upper_bound）</p>
</li>
<li><p>需要判断目标位置不是end，目标值也不小于首元素</p>
</li>
<li><p>其实应该先判断不小于首元素在继续二分查找</p>
</li>
</ul>
<h1 id="P31-仿函数和函数对象"><a href="#P31-仿函数和函数对象" class="headerlink" title="P31.仿函数和函数对象"></a>P31.仿函数和函数对象</h1><ul>
<li>functors 是在平时编程中最有可能需要自己编写的部分</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">plus</span>:</span><span class="keyword">public</span> binary_funcation&lt;T,T,T&gt;&#123;</span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; x,<span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x + y;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>因为需要把加减乘除等这些操作传给算法，因此需要将其变成函数。</p>
</li>
<li><p>上一讲 struct 没有继承 因此无法融入到stl的体系中（当前的函数可以调用，但是标准库的其他函数不一定能调用，需要一些继承关系），我们自己写的仿函数往往没有继承。</p>
</li>
<li><p>STL规定每个 Adaptable Function 都应挑选适当的继承。(函数接受几个参数，以及参数种类),这种继承没有带来额外的开销（占用数据空间），但是有利于适配。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Arg</span>, <span class="keyword">class</span> <span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">unary_function</span>&#123;</span><span class="comment">//一个参数</span></span><br><span class="line">    <span class="keyword">typedef</span> Arg argument_type;</span><br><span class="line">    <span class="keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Arg1</span>,<span class="keyword">class</span> <span class="title">Arg2</span>, <span class="keyword">class</span> <span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binary_function</span>&#123;</span><span class="comment">//两个参数 </span></span><br><span class="line">    <span class="keyword">typedef</span> Arg1 first_argument_type;</span><br><span class="line">    <span class="keyword">typedef</span> Arg2 second_argument_type;</span><br><span class="line">    <span class="keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>仿函数就是重载小括号 <code>()</code>, 其实是一个对象，但是像是一个函数。</li>
</ul>
<h1 id="P32-存在多种Adapters"><a href="#P32-存在多种Adapters" class="headerlink" title="P32.存在多种Adapters"></a>P32.存在多种Adapters</h1><ul>
<li><p>对现有的函数或数据结构进行简单的修饰，如三个参数变为两个（在特定条件下固定一个参数），修改函数名称等等。</p>
</li>
<li><p>有两种实现方式：继承 和 复合</p>
</li>
<li><p>容器适配器 stack 和 queue 内含一个 deque，底层功能都是由 deque 实现。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Sequence</span>=</span><span class="built_in">deque</span>&lt;T&gt;&gt;<span class="comment">//底层容器默认使用双向队列</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">stack</span>&#123;</span></span><br><span class="line">···</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::value_type value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::size_type size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::reference reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::const_reference const_reference;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Sequence c;<span class="comment">//底层容器</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> c.empty();&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> c.size();&#125;</span><br><span class="line">    <span class="function">reference <span class="title">top</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> c.back();&#125;</span><br><span class="line">    <span class="function">const_refernece <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> c.back();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> value_type&amp; x)</span></span>&#123;c.push_back(x);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;c.pop_back();&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="P33-函数适配器：bind2nd"><a href="#P33-函数适配器：bind2nd" class="headerlink" title="P33.函数适配器：bind2nd"></a>P33.函数适配器：bind2nd</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">6</span>] = &#123;<span class="number">27</span>, <span class="number">210</span>, <span class="number">12</span>, <span class="number">47</span>, <span class="number">109</span>, <span class="number">83</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>, allocator&lt;<span class="keyword">int</span>&gt;&gt; vi(ia,ia+<span class="number">6</span>); <span class="comment">//vector-容器，allocator-分配器</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; count_if(vi.begin(),vi.end(),   <span class="comment">//begin,end - 迭代器，count_if-算法</span></span><br><span class="line">                    not1(bind2nd(less&lt;<span class="keyword">int</span>&gt;(),<span class="number">40</span>)));<span class="comment">//not1,bind2nd - 算法适配器，less - 仿函数</span></span><br></pre></td></tr></table></figure>
<ul>
<li>找到vector中所有不小于40的数，现在来介绍 <code>bind2nd</code></li>
</ul>
<hr>
<ul>
<li>辅助函数，让使用者可以更加方便使用 <code>binder2nd&lt;Op&gt;</code>,因为函数模板可以进行实参推到，编译器会自动推导出 <code>Op</code> 的类型。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Operation</span>, <span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> binder2nd&lt;Operation&gt; <span class="title">bind2nd</span><span class="params">(<span class="keyword">const</span> Operation&amp; op, <span class="keyword">const</span> T&amp; x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Operation::second_argument_type arg2_type;<span class="comment">//从为声明对象的类中访问子对象类型 需要加 typename</span></span><br><span class="line">    <span class="keyword">return</span> binder2nd&lt;Operation&gt;(op,arg2_type(x)); <span class="comment">//类型（参数），构造函数 创建对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>模板类，一般难以直接写出 <code>Operation</code> 的类型，因此采用辅助函数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Operation</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">bind2nd</span>:</span> <span class="keyword">public</span> unary_function&lt;<span class="keyword">typename</span> Operation::first_argument_type,<span class="keyword">typename</span> Operation::second_argument_type&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    Operation op;<span class="comment">// 内部成员，记录函数和第二实参</span></span><br><span class="line">    <span class="keyword">typename</span> Operation::second_argument_type value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    binder2nd(<span class="keyword">const</span> Operation&amp; x,<span class="keyword">const</span> <span class="keyword">typename</span> Operation::second_argument_type&amp; y)</span><br><span class="line">    :op(x),value(y)&#123;&#125;<span class="comment">//记录操作函数和实参</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">typename</span> Operation::result_type <span class="comment">//这个类中有很多这样的类型，是为了保持适配后的类型与源操作一致</span></span><br><span class="line">    <span class="keyword">operator</span>()(<span class="keyword">const</span> <span class="keyword">typename</span> Operation::first_argument_type&amp; x) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> op(x,value);<span class="comment">//调用函数并固定第二实参</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>在绑定第二参数后，仍有一个参数，应当继承 <code>unary_function</code>,以便还要被适配，以兼容STL体系</p>
</li>
<li><p><code>bind2nd(less&lt;int&gt;(), 40))</code>生成一个仿函数对象，记录操作和实参。由于重载小括号可以在 <code>count_if</code> 算法中调用</p>
</li>
<li><p>上式中 <code>less&lt;int&gt;()</code> 为创建对象的构造函数而非操作符重载</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="keyword">class</span> <span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::difference_type</span><br><span class="line">count_if(InputIterator first,InputIterator,last,Predicate pred)&#123;</span><br><span class="line">    <span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::difference_type n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;first != last; ++first)</span><br><span class="line">       <span class="keyword">if</span>(pred(*first))<span class="comment">//这里调用 重载小括号，绑定第二参数</span></span><br><span class="line">           ++n;</span><br><span class="line">   <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>现在 <code>bind2nd</code>、<code>binder2nd</code> 已经过时，现在由 <code>bind</code> 取代。</li>
</ul>
<h1 id="P34-函数适配器-not1"><a href="#P34-函数适配器-not1" class="headerlink" title="P34. 函数适配器 not1"></a>P34. 函数适配器 not1</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//辅助函数，便于使用</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> unary_nagete&lt;Predicate&gt; <span class="title">not1</span><span class="params">(<span class="keyword">const</span> Predicate&amp; pred)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unary_negate&lt;Predicate&gt;(pred);<span class="comment">//创建对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unary_negate</span>:</span> <span class="keyword">public</span> unary_function&lt;<span class="keyword">typename</span> Predicate::argument_type,<span class="keyword">bool</span>&gt;&#123;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        Predicate pred;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">unary_negate</span><span class="params">(<span class="keyword">const</span> Predicate&amp; x)</span>:<span class="title">pred</span><span class="params">(x)</span></span>&#123;&#125;<span class="comment">//构造函数</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">typename</span> Predicate::argument_type&amp; x)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> !pred(x);<span class="comment">//结果取否</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>由于 <code>bind2nd</code> 继承 <code>unary_function</code>, <code>not1</code> 可以继续适配.</li>
</ul>
<h1 id="P35-新型适配器-bind-c-11"><a href="#P35-新型适配器-bind-c-11" class="headerlink" title="P35.新型适配器 bind c++11"></a>P35.新型适配器 bind c++11</h1><ul>
<li><p>std::bind 可绑定：</p>
<ol>
<li><p>functions</p>
</li>
<li><p>function objects</p>
</li>
<li><p>member functions, _1必须是某个object地址(_1是占位符)</p>
</li>
<li><p>data members, _1必须是某个object地址</p>
</li>
</ol>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用仿函数也是同理 std::divides&lt;double&gt; my_divide;</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">my_divide</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">double</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> x/y ;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyPair</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> a,b;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">multiply</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> a*b; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::placeholders;<span class="comment">// adds visibility of _1, _2 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定函数</span></span><br><span class="line"><span class="keyword">auto</span> fn_five = bind(my_divide,<span class="number">10</span>,<span class="number">2</span>); <span class="comment">//返回10/5</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; fn_five() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;           <span class="comment">//5   </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> fn_half = bind(my_divide, _1, <span class="number">2</span>); <span class="comment">//返回x/2</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; fn_hale(<span class="number">10</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;           <span class="comment">//5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> fn_invert = bind(my_divide,_2,_1);<span class="comment">//返回y/x</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; fn_invert(<span class="number">10</span>,<span class="number">2</span>)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;          <span class="comment">//0.2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> fn_rounding = bind&lt;<span class="keyword">int</span>&gt;(my_divide,_1,_2); <span class="comment">//返回int(x/y)</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; fn_rounding(<span class="number">10</span>,<span class="number">3</span>)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;               <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定成员</span></span><br><span class="line">MyPair ten_two &#123;<span class="number">10</span>,<span class="number">2</span>&#125;; <span class="comment">// C++11 新加入的初始化方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数都含有隐藏的 this指针</span></span><br><span class="line"><span class="keyword">auto</span> bound_menfn = bind(&amp;MyPair::multiply,_1); <span class="comment">//return x.multiply()</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bound_menfn(ten_two) &lt;&lt;<span class="string">&#x27;\n&#x27;</span>;           <span class="comment">//20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> bound_memdata = bind(&amp;MyPair::a, ten_two); <span class="comment">//return ten_two.a</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;bound_memdata() &lt;&lt;<span class="string">&#x27;\n&#x27;</span>;                  <span class="comment">//20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> bound_memdata2 = bind(&amp;MyPair::a, _1);     <span class="comment">//return x.a</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bound_memdata2(ten_two) &lt;&lt;<span class="string">&#x27;\n&#x27;</span>;         <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新实现两章的内容</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">15</span>,<span class="number">37</span>,<span class="number">94</span>,<span class="number">50</span>,<span class="number">73</span>,<span class="number">58</span>,<span class="number">28</span>,<span class="number">98</span>&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; count_if(v.cbegin(),v.cend(),not1(bind2nd(less&lt;<span class="keyword">int</span>&gt;(),<span class="number">50</span>))) &lt;&lt;<span class="built_in">endl</span>;<span class="comment">//之前的用法仍旧兼容</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> fn_= bind(less&lt;<span class="keyword">int</span>&gt;(),_1,<span class="number">50</span>)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; count_if(v.cbegin(),v.cend(),fn_) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h1 id="P36-迭代器适配器-reverse-iterator"><a href="#P36-迭代器适配器-reverse-iterator" class="headerlink" title="P36.迭代器适配器 reverse_iterator"></a>P36.迭代器适配器 reverse_iterator</h1><ul>
<li>逆向取迭代器</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">reverse_iterator</span>&#123;</span></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        Iterator current;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//逆向迭代器5种相关的类型 与正向相对应</span></span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::iterator_category iterator_category;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::value_type value_type;</span><br><span class="line">        ···</span><br><span class="line">        <span class="keyword">typedef</span> Iterator iterator_type;             <span class="comment">//表示正向迭代器</span></span><br><span class="line">        <span class="keyword">typedef</span> reverse_iterator&lt;Iterator&gt; self;    <span class="comment">//表示逆向迭代器</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">reverse_iterator</span><span class="params">(iterator_type x)</span>:<span class="title">current</span><span class="params">(x)</span></span>&#123;&#125;</span><br><span class="line">                 reverse_iterator(<span class="keyword">const</span> self&amp; x):current(x.current)&#123;&#125;</span><br><span class="line">        <span class="function">iterator_type <span class="title">base</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> current;&#125;<span class="comment">//取出对应正向迭代器</span></span><br><span class="line">        reference <span class="keyword">operator</span>*() <span class="keyword">const</span>&#123;Iterator tmp = current; <span class="keyword">return</span> *--tmp;&#125;<span class="comment">//逆向迭代器退一位取值</span></span><br><span class="line">        pointer <span class="keyword">operator</span>-&gt;()<span class="keyword">const</span> &#123;<span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*());&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//前进改后退，后退改前进</span></span><br><span class="line">        self&amp; <span class="keyword">operator</span>++() &#123;--current;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">        self&amp; <span class="keyword">operator</span>--() &#123;++current;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">        self <span class="keyword">operator</span>+(difference_type n) <span class="keyword">const</span> &#123;<span class="keyword">return</span> self(current - n)&#125;</span><br><span class="line">        self <span class="keyword">operator</span>-(difference_type n) <span class="keyword">const</span> &#123;<span class="keyword">return</span> self(current + n)&#125;</span><br><span class="line">        <span class="comment">//头变尾 尾变头</span></span><br><span class="line">        reverse_iterator rbegin() &#123; <span class="keyword">return</span> reverse_iterator(end());&#125;</span><br><span class="line">        <span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> reverse_iterator(begin());&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="P37-迭代器适配器-inserter"><a href="#P37-迭代器适配器-inserter" class="headerlink" title="P37.迭代器适配器 inserter"></a>P37.迭代器适配器 inserter</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> myints[] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>,<span class="number">70</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">myvec</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line">copy(myints,myints+<span class="number">7</span>,myvec.begin());</span><br></pre></td></tr></table></figure>
<ul>
<li>首先看一段从数组拷贝到 <code>vector</code> 的程序，其中 <code>copy</code> 的主要代码如下所示</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>,<span class="keyword">class</span> <span class="title">OutputIterator</span>&gt;</span></span><br><span class="line"><span class="function">OutputIterator <span class="title">copy</span><span class="params">(InputIterator first, InputIterator last, OutputIterator result)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(first!=last)&#123;</span><br><span class="line">        *result = *first;</span><br><span class="line">        ++result;++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>可以看出是循环赋值，并没有检查边界。因此在 <code>vector</code> 中要留好足够的空间。</p>
</li>
<li><p>下面是一段插入的程序片段</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; foo, bar;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>, i &lt;=<span class="number">5</span>, i++)</span><br><span class="line">    &#123;foo.push_back(i);bar.push_back(i*<span class="number">10</span>);&#125;</span><br><span class="line"><span class="comment">// 初始化，foo 为1-5， bar 为10-50</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it foo.begin();</span><br><span class="line">advance(it,<span class="number">3</span>) <span class="comment">// list为不连续空间，使用advance 一个一个跳转</span></span><br><span class="line"></span><br><span class="line">copy(bar.begin(), bar.end(),inserter(foo,it))</span><br><span class="line"><span class="comment">//1,2,3,10,20,30,40,50,4,5</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>在 <code>copy</code> 中是一个一个赋值动作，并没有重新申请空间。inserter 使用重载等号的方法实现在 <code>copy</code> 中扩容。</p>
</li>
<li><p>在inserter 中 等号被重载为容器的插入操作,(容器默认提供了插入操作，会自动申请空间)</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Container</span>, <span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> inserter_iterator&#123;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        Container* container;</span><br><span class="line">        <span class="keyword">typename</span> Container::iterator iter;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        inserter_iterator(Container&amp; x, <span class="keyword">typename</span> Container::iterator i)</span><br><span class="line">            :container(&amp;x),iter(i)&#123;&#125;</span><br><span class="line">        </span><br><span class="line">        inserter_iterator&lt;Container&gt;&amp;</span><br><span class="line">        <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">typename</span> Container::value_type&amp; value)&#123;</span><br><span class="line">            iter = container-&gt;insert(iter,value);<span class="comment">//这一步是关键，变移动为插入。这里的返回值指向新插入的元素</span></span><br><span class="line">            ++iter;<span class="comment">//同时 iter 紧跟目标移动，指向下一个位置</span></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>inserter_iterator 的辅助函数 实现类型推导</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Container</span>, <span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> inserter_iterator&lt;Container&gt;</span><br><span class="line">insert(Container&amp; x, Iterator i)&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Container::iterator iter;</span><br><span class="line">    <span class="keyword">return</span> inserter_iterator&lt;Container&gt;(x,iter(i))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="P38-X适配器-ostream-iterator"><a href="#P38-X适配器-ostream-iterator" class="headerlink" title="P38. X适配器 ostream_iterator"></a>P38. X适配器 ostream_iterator</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>; i &lt; <span class="number">10</span>; ++i) myvector.push_back(i*<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">ostream_iterator&lt;<span class="keyword">int</span>&gt; <span class="title">out_it</span><span class="params">(<span class="built_in">cout</span>,<span class="string">&quot;,&quot;</span>)</span> <span class="comment">//构造 类型为cout， 分隔符为，</span></span></span><br><span class="line"><span class="function"><span class="title">copy</span><span class="params">(myvector.begin(),myvector.end(),out_it)</span></span>;</span><br><span class="line"><span class="comment">//打印出 10,20，30,40,50,60,70,80,90</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>通过操作符重载，在不改变 <code>copy</code> 程序(见上一章)的情况下，实现对输出的适配(对硬件也就是屏幕输出的绑定)。</p>
</li>
<li><p><code>copy</code> 中的赋值操作变成输出字符，迭代器自增不变</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">charT</span> =</span> <span class="keyword">char</span>, <span class="class"><span class="keyword">class</span> <span class="title">traits</span> =</span> char_traits&lt;chatT&gt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ostream_iterator</span>:</span></span><br><span class="line"><span class="keyword">public</span> iterator&lt;output_iterator_tag,<span class="keyword">void</span>,<span class="keyword">void</span>,<span class="keyword">void</span>,<span class="keyword">void</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">basic_ostream&lt;chatT,traits&gt;* out_stream;</span><br><span class="line"><span class="keyword">const</span> chatT* delim;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> charT char_type;</span><br><span class="line">    <span class="keyword">typedef</span> traits traits_type;</span><br><span class="line">    <span class="keyword">typedef</span> basic_ostream&lt;charT,traits&gt; ostream_type;</span><br><span class="line">    ostream_iterator(ostream_type&amp; s):out_stream(&amp;s),delim(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    ostream_iterator(ostream_type&amp; s, <span class="keyword">const</span> charT* delimiter)</span><br><span class="line">        :out_stream(&amp;s),delim(delimiter)&#123;&#125;</span><br><span class="line">    ostream_iterator(<span class="keyword">const</span> ostream_iterator&lt;T,charT,traits&gt;&amp; x)</span><br><span class="line">        :out_stream(x.out_stream),delim(x.delim)&#123;&#125;</span><br><span class="line">    ~ostream_iterator()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    ostream_iterator&lt;T,charT,traits&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> T&amp; value)&#123;</span><br><span class="line">        *out_stream &lt;&lt; value;          <span class="comment">//重载等号为输出</span></span><br><span class="line">        <span class="keyword">if</span>(delim != <span class="number">0</span>) *out_stream &lt;&lt; delim;<span class="comment">//若有分隔符，一起输出</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ostream_iterator&lt;T,charT,traits&gt;&amp; <span class="keyword">operator</span>*()&#123;<span class="keyword">return</span> *<span class="keyword">this</span>&#125;<span class="comment">//对地址的操作全部返回自身</span></span><br><span class="line">    ostream_iterator&lt;T,charT,traits&gt;&amp; <span class="keyword">operator</span>++()&#123;<span class="keyword">return</span> *<span class="keyword">this</span>&#125;</span><br><span class="line">    ostream_iterator&lt;T,charT,traits&gt;&amp; <span class="keyword">operator</span>++(<span class="keyword">int</span>)&#123;<span class="keyword">return</span> *<span class="keyword">this</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="P39-X适配器-i-stream-iterator"><a href="#P39-X适配器-i-stream-iterator" class="headerlink" title="P39. X适配器 i stream_iterator"></a>P39. X适配器 i stream_iterator</h1><ul>
<li>对输入的绑定，相当于绑定键盘</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> value1,value2;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;please insert two values:&quot;</span>;</span><br><span class="line">istream_iterator&lt;<span class="keyword">double</span>&gt; eos;<span class="comment">//end of stream_iterator, 没有参数作为结束标志位</span></span><br><span class="line"><span class="function">istream_iterator&lt;<span class="keyword">double</span>&gt; <span class="title">iit</span><span class="params">(<span class="built_in">cin</span>)</span> <span class="comment">//stdin iterator 创建迭代器时已经要求输入了，相当于cin&gt;&gt; value;详见下方的定义</span></span></span><br><span class="line"><span class="function"><span class="title">if</span><span class="params">(iit!=eos)</span> value1 </span>= *iit;<span class="comment">//相当于return value</span></span><br><span class="line"></span><br><span class="line">++iit;<span class="comment">//自增相当于读取下一个</span></span><br><span class="line"><span class="keyword">if</span>(iit!=eos) value2 = *iit;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="keyword">class</span> <span class="title">charT</span>=</span> <span class="keyword">char</span>,<span class="class"><span class="keyword">class</span> <span class="title">traits</span> =</span> char_traits&lt;charT&gt;,<span class="class"><span class="keyword">class</span> <span class="title">Distance</span>=</span><span class="keyword">ptrdiff_t</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">istream_iterator</span></span></span><br><span class="line"><span class="class">    :</span><span class="keyword">public</span> iterator&lt;input_iterator_tag,T,Distance,<span class="keyword">const</span> T*,<span class="keyword">const</span> T&amp;&gt;</span><br><span class="line">&#123;</span><br><span class="line">basic_istream&lt;chatT,traits&gt;* in_stream;</span><br><span class="line">T value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> charT char_type;</span><br><span class="line">    <span class="keyword">typedef</span> traits traits_type;</span><br><span class="line">    <span class="keyword">typedef</span> basic_istream&lt;charT,traits&gt; istream_type;</span><br><span class="line"></span><br><span class="line">    istream_iterator():in_stream(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    istream_iterator(istream_iterator&amp; s):in_stream(&amp;s)&#123;++*<span class="keyword">this</span>&#125;<span class="comment">//值得注意的是：一旦创建立即读取，见下面操作符重载 18行</span></span><br><span class="line">    istream_iterator(<span class="keyword">const</span> istream_iterator&lt;T,charT,traits,Distance&gt;&amp; x):in_stream(x.in_stream),value(x.value)&#123;&#125;</span><br><span class="line">    ~istream_iterator()&#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;<span class="keyword">return</span> value;&#125;</span><br><span class="line">    <span class="keyword">const</span> T&amp; <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123;<span class="keyword">return</span> &amp;value;&#125;</span><br><span class="line">    istream_iterator&lt;T,charT,traits,Distance&gt;&amp; <span class="keyword">operator</span>++()&#123;</span><br><span class="line">        <span class="keyword">if</span>(in_stream&amp;&amp;!(*in_stream&gt;&gt;value)) in_stream=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    istream_iterator&lt;T,charT,traits,Distance&gt;&amp; <span class="keyword">operator</span>++(<span class="keyword">int</span>)&#123;<span class="comment">//后++</span></span><br><span class="line">        istream_iterator&lt;T,charT,traits,Distance&gt; tmp = *<span class="keyword">this</span>;</span><br><span class="line">        ++*<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">istream_iterator&lt;<span class="keyword">int</span>&gt;iit(<span class="built_in">cin</span>),eos;</span><br><span class="line"></span><br><span class="line">copy(iit,eos,inserter(c,c.begin()))</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 <code>copy</code> 将输入存储在vector中</li>
</ul>
<h1 id="P40-一个万用的-hash-function"><a href="#P40-一个万用的-hash-function" class="headerlink" title="P40.一个万用的 hash function"></a>P40.一个万用的 hash function</h1><ul>
<li><p>计算一个自定义类型的hash（由常用的类型组成），假设 Custom 类 含有 <code>string fname,lname;long no;</code></p>
</li>
<li><p>常见的类型标准库自带 hash function</p>
</li>
<li><p>自定义hash function 有三种方法</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一：创建可调用类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerHash</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Customer&amp; c)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">unordered_set</span>&lt;Customer, CustomerHash&gt; custest;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//方式二：创建哈希函数</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">customer_hash_func</span><span class="params">(<span class="keyword">const</span> Customer&amp; c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">unordered_set</span>&lt;Customer, <span class="keyword">size_t</span>(*)(<span class="keyword">const</span> Customer&amp;)&gt; custest(<span class="number">20</span>, customer_hash_func); </span><br><span class="line"><span class="comment">//注意这里调用了构造函数的不同版本,size_t(*)(const Customer&amp;) 是hash function 的类型</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//方式三：创建默认值hash&lt;T&gt;的特化版本</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;</span>Customer&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span></span><br><span class="line">    <span class="keyword">operator</span>()(<span class="keyword">const</span> Customer&amp; c) <span class="keyword">const</span> <span class="keyword">noexcept</span></span><br><span class="line">    &#123; <span class="keyword">return</span> ...... &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">unordered_set</span>&lt;Customer&gt; custest;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>一共有三种方法创建自定义hash function</p>
<ol>
<li>创建可调用类型</li>
<li>创建哈希函数，但是创建对象时需要声明函数类型和函数地址，有一定难度</li>
<li>nordered_set 默认值<code>hash&lt;T&gt;</code>，我们只需创建自定义类型的<code>hash&lt;T&gt;</code>的特化版本即可</li>
</ol>
</li>
<li><p>标准库提供了 <code>hash_combine</code>(下面21行)，这个函数并没有什么数学推导，其中<code>0x9e3779b9</code>为黄金分割率。</p>
</li>
<li><p>使用 variadic templates 变参模板（C++11），类似于递归每次计算第一个参数直到结束。</p>
</li>
<li><p>用户调用第2行，实际调用的版本是滴9行，将参数逐个拆解计算，于第16行读取完所有参数终止计算。由于是传递引用，每次计算参数都在修改 <code>seed</code>，最后 <code>seed</code> 就是我们的哈希值。</p>
</li>
</ul>
<figure class="highlight cpp"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">size_t</span> <span class="title">hash_val</span><span class="params">(<span class="keyword">const</span> Types&amp;... args)</span></span>&#123;        <span class="comment">//提供给使用者的重载版本</span></span><br><span class="line">    <span class="keyword">size_t</span> seed = <span class="number">0</span>;</span><br><span class="line">    hash_val(seed, args...);                         <span class="comment">//实际调用的版本</span></span><br><span class="line">    <span class="keyword">return</span> seed;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">hash_val</span><span class="params">(<span class="keyword">size_t</span>&amp; seed,                   <span class="comment">//实际调用函数的主体</span></span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">const</span> T&amp; val, <span class="keyword">const</span> Types&amp;... args)</span></span>&#123;</span><br><span class="line">    hash_combine(seed, val);</span><br><span class="line">    hash_val(seed, args...);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">hash_val</span><span class="params">(<span class="keyword">size_t</span>&amp; seed, <span class="keyword">const</span> T&amp; val)</span></span>&#123;    <span class="comment">//实际调用函数的边界条件</span></span><br><span class="line">    hash_combine(seed, val);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">hash_combine</span><span class="params">(<span class="keyword">size_t</span>&amp; seed, <span class="keyword">const</span> T&amp; val)</span></span>&#123;</span><br><span class="line">    seed ^= <span class="built_in">std</span>::hash&lt;T&gt;()(val) + <span class="number">0x9e3779b9</span></span><br><span class="line">            + (seed&lt;&lt;<span class="number">6</span>) + (seed&gt;&gt;<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//下面是对于 class Customer 的实际使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerHash</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Customer&amp; c)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hash_val(c.fname, c.lname, c.no);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="P41-tuple-用例"><a href="#P41-tuple-用例" class="headerlink" title="P41.tuple 用例"></a>P41.tuple 用例</h1><ul>
<li><code>tuple</code> 可以将任意多个类型作为一组作为一种新的类型来声明变量。不同于 <code>vector</code> 和 <code>list</code> 创建对象时要固定变量的类型  </li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;<span class="built_in">string</span>,<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt;&gt; t;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;sizeof =&quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(t)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//32 不是28 4+4+4+(8+8)=28 应该要跟最大的元素对齐,所以应是16的倍数</span></span><br><span class="line"></span><br><span class="line">tuple&lt;<span class="keyword">int</span>,<span class="keyword">float</span>,<span class="built_in">string</span>&gt;t1(<span class="number">41</span>,<span class="number">6.3</span>,<span class="string">&quot;nico&quot;</span>)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;t1: &quot;</span>&lt;&lt; get&lt;<span class="number">0</span>&gt;(t1) &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; get&lt;<span class="number">1</span>&gt;(t1)&lt;&lt; <span class="string">&quot; &quot;</span>&lt;&lt;get&lt;<span class="number">2</span>&gt;(t1)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//分别取出元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> t2 = make_tuple(<span class="number">22</span>,<span class="number">44</span>,<span class="string">&quot;stacy&quot;</span>);</span><br><span class="line"></span><br><span class="line">get&lt;<span class="number">1</span>&gt;(t1) = get&lt;<span class="number">1</span>&gt;(t2);<span class="comment">//成员之间可以互相赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(t1&lt;t2) <span class="comment">//之间可以互相比较</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;t1&lt;t2&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;t1&gt;=2&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">t1 = t2;<span class="comment">//可以互相赋值</span></span><br><span class="line"></span><br><span class="line">tuple&lt;int,float string&gt; t3(77,1.1,&quot;more light&quot;)</span><br><span class="line"><span class="keyword">int</span> i1;</span><br><span class="line"><span class="keyword">float</span> f1;</span><br><span class="line"><span class="built_in">string</span> s1;</span><br><span class="line">tie(i1,f1,s1) = t3; <span class="comment">//批量赋值，t3 在之后的改动并不会影响前面三个变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> tuple&lt;<span class="keyword">int</span>,<span class="keyword">float</span>,<span class="built_in">string</span>&gt; TupleType;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; tuple_size&lt;TupleType&gt;::value &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 3</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; tuple_element&lt;<span class="number">1</span>,TupleType&gt;::type f1 = <span class="number">1.0</span>; <span class="comment">//取出第第二个的类型来声明变量，也就是float f1=1.0</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>可以使用 <code>tuple</code> 和类型直接组合 创建元祖，也可以使用 <code>make_tuple</code> (内含类型推导)</p>
</li>
<li><p>如同普通类型一样可以进行大小比较，赋值</p>
</li>
<li><p>可以用 <code>get</code>获取元祖成员的数据,<code>tie</code>进行批量赋值，<code>tuple_size</code> 查询元祖成员数量，<code>tuple_element</code></p>
</li>
</ul>
<figure class="highlight cpp"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Values&gt; <span class="class"><span class="keyword">class</span> <span class="title">tuple</span>;</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">class</span> <span class="title">tuple</span>&lt;</span>&gt; &#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Tail&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tuple</span>&lt;</span>Head, Tail...&gt; :<span class="keyword">private</span> tuple&lt;Tail...&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> tuple&lt;Tail...&gt; inherited;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    tuple() &#123;&#125;</span><br><span class="line">    tuple(Head v, Tail... vtail):m_Head(v), tuple&lt;Tail...&gt;(vtail...) &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">typename</span> Head::type <span class="title">head</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_Head; &#125;</span><br><span class="line">    <span class="function">inherited&amp; <span class="title">tail</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Head m_Head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>递归继承，例如 <code>tuple&lt;int,float,string&gt;</code> 的继承顺序 <code>tuple&lt;&gt;</code> ← <code>tuple&lt;string&gt;</code> ← <code>tuple&lt;float,string&gt;</code>←<code>tuple&lt;int,float,string&gt;</code>，</p>
</li>
<li><p>递归继承终止与第二行，一个空的元祖</p>
</li>
<li><p>因此声明一个元祖，就可以将其分为头和尾，尾又可以再分成头尾，以此下去，直到最后一个元素的尾指是空的元祖。第 <code>10</code> 行 <code>tuple&lt;Tail...&gt;(vtail...)</code>重新调用构造函数，将其分成 head 和 tail</p>
</li>
<li><p>第 <code>13</code> 行 <code>return *this</code> 但是类型被转换成 <code>inherited</code> 获得的是尾部的元祖</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;int,float,string&gt; t(41,6.3,&quot;nico&quot;);</span><br><span class="line">t.head() <span class="comment">//41</span></span><br><span class="line">t.tail().head()<span class="comment">//6.3</span></span><br></pre></td></tr></table></figure>
<h1 id="P42-type-traits"><a href="#P42-type-traits" class="headerlink" title="P42.type traits"></a>P42.type traits</h1><ul>
<li><p>POD Plain Old ，c 风格的数据，如struct里没有函数</p>
</li>
<li><p>c++11 提供了一系列萃取机来获得类的特性,是不是整数，类，仿函数，是否含有指针，构造，析构函数是否重要等等</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">type_traits_output</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;is_void\t&quot;</span>&lt;&lt; is_void&lt;T&gt;::value &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;is_integral\t&quot;</span>&lt;&lt; is_integral&lt;T&gt;::value &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="P43-type-traits实现"><a href="#P43-type-traits实现" class="headerlink" title="P43.type traits实现"></a>P43.type traits实现</h1><ul>
<li>都是使用一些模板的特化和偏特化实现</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_const</span></span></span><br><span class="line"><span class="class">&#123;</span> <span class="keyword">typedef</span> _Tp type; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_const</span>&lt;</span>_Tp <span class="keyword">const</span>&gt;</span><br><span class="line">&#123; <span class="keyword">typedef</span> _Tp type; &#125;;<span class="comment">//特化版本 如果含有const，则定义为无const 版本 volatile 同理</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_cv</span></span></span><br><span class="line"><span class="class">&#123;</span> <span class="keyword">typedef</span> <span class="keyword">typename</span> </span><br><span class="line">    remove_const&lt;<span class="keyword">typename</span> remove_volatile&lt;_Tp&gt;::type&gt;::type type; &#125;; <span class="comment">//先移除无关的 const， volatile</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">is_void_helper</span> :</span> <span class="keyword">public</span> false_type &#123; &#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">is_void_helper</span>&lt;</span><span class="keyword">void</span>&gt; : <span class="keyword">public</span> true_type &#123; &#125;<span class="comment">//只有为void 才继承真</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_void</span> :</span> <span class="keyword">public</span> __is_void_helper&lt;<span class="keyword">typename</span> remove_cv&lt;_Tp&gt;::type&gt;::type</span><br><span class="line">&#123; &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>对于一些负载的类型萃取，如 is_class 则无法看到源码，推测应该是编译器帮忙完成一些类型的推导。</li>
</ul>
<h1 id="P44-cout"><a href="#P44-cout" class="headerlink" title="P44 cout"></a>P44 cout</h1><ul>
<li><p><code>cout</code> 是一个对象，类型是 <code>_IO_ostream_withassign</code> 继承自 <code>ostream</code>  继承自<code>ostream</code> 继承自 <code>ios</code></p>
</li>
<li><p>在 <code>ios</code> 中有一系列的操作符重载，覆盖了大部分默认的类型，因此内置的类型大多可以用cout输出</p>
</li>
<li><p>自定义类型要使用cout输出的话 需要类内进行操作符重载</p>
</li>
</ul>
<h1 id="P45-moveable-元素"><a href="#P45-moveable-元素" class="headerlink" title="P45.moveable 元素"></a>P45.moveable 元素</h1><ul>
<li><p>c++11 中引入move 对容器的效率有很大影响。与运行时系统的内存内存情况也有关系</p>
</li>
<li><p>move 的实现是浅拷贝，只修改指针，并把原先指针置为NULL，之后不能再使用原来的对象</p>
</li>
<li><p>move 的构造声明参数就是将拷贝构造的 &amp; 改为 &amp;&amp; hexo</p>
</li>
<li><p>具体的move 特性详见课程  c++11新特性</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/24/C++%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lclee">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog-lclee">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/24/C++%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">C++笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-24 08:50:30" itemprop="dateCreated datePublished" datetime="2020-11-24T08:50:30+08:00">2020-11-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-07 10:00:31" itemprop="dateModified" datetime="2020-12-07T10:00:31+08:00">2020-12-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="上篇"><a href="#上篇" class="headerlink" title="上篇"></a>上篇</h1><p>视频网址 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1aW411H7Xa?p=1">https://www.bilibili.com/video/BV1aW411H7Xa?p=1</a></p>
<h1 id="P3-构造函数"><a href="#P3-构造函数" class="headerlink" title="P3. 构造函数"></a>P3. 构造函数</h1><figure class="highlight cpp"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">complex</span> (<span class="keyword">double</span> r = <span class="number">0</span>, <span class="keyword">double</span> i = <span class="number">0</span>): re (r), im (i) &#123; &#125; \\使用: 初始化变量  无需再 &#123;···&#125; 内赋值</span><br><span class="line">    <span class="built_in">complex</span>&amp; <span class="keyword">operator</span> += (<span class="keyword">const</span> <span class="built_in">complex</span>&amp;); </span><br><span class="line">    <span class="built_in">complex</span>&amp; <span class="keyword">operator</span> -= (<span class="keyword">const</span> <span class="built_in">complex</span>&amp;); </span><br><span class="line">    <span class="built_in">complex</span>&amp; <span class="keyword">operator</span> *= (<span class="keyword">const</span> <span class="built_in">complex</span>&amp;); </span><br><span class="line">    <span class="built_in">complex</span>&amp; <span class="keyword">operator</span> /= (<span class="keyword">const</span> <span class="built_in">complex</span>&amp;); </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">real</span> <span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> re; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">imag</span> <span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> im; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> re, im;</span><br><span class="line">  <span class="keyword">friend</span> <span class="built_in">complex</span>&amp; __doapl (<span class="built_in">complex</span> *, <span class="keyword">const</span> <span class="built_in">complex</span>&amp;); </span><br><span class="line">  <span class="keyword">friend</span> <span class="built_in">complex</span>&amp; __doami (<span class="built_in">complex</span> *, <span class="keyword">const</span> <span class="built_in">complex</span>&amp;); </span><br><span class="line">  <span class="keyword">friend</span> <span class="built_in">complex</span>&amp; __doaml (<span class="built_in">complex</span> *, <span class="keyword">const</span> <span class="built_in">complex</span>&amp;); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="built_in">complex</span>&amp;</span><br><span class="line">__doapl (<span class="built_in">complex</span>* ths, <span class="keyword">const</span> <span class="built_in">complex</span>&amp; r)</span><br><span class="line">&#123;</span><br><span class="line">  ths-&gt;re += r.re; </span><br><span class="line">  ths-&gt;im += r.im; </span><br><span class="line">  <span class="keyword">return</span> *ths; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="built_in">complex</span>&amp;</span><br><span class="line"><span class="built_in">complex</span>::<span class="keyword">operator</span> += (<span class="keyword">const</span> <span class="built_in">complex</span>&amp; r)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __doapl (<span class="keyword">this</span>, r); </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>构造函数没有返回值</li>
<li>使用<code>初始列(initialization list)</code>初始化默认参数 (第<code>4</code>行) 更有效。 在大括号内赋值(assignment)就等于放弃了初始列这种</li>
<li>构造函数可以有多个 ,根据参数的不同进行重载(overloading),虽然函数名相同,但是编译后的函数名包含参数</li>
</ul>
<h1 id="P4-参数传递和返回值"><a href="#P4-参数传递和返回值" class="headerlink" title="P4.参数传递和返回值"></a>P4.参数传递和返回值</h1><ul>
<li>大部分构造函数在public区,例外:单例(Singleton): 构造函数(constructor) 放在 private 区 只允许创建一份</li>
</ul>
<h2 id="常量成员函数"><a href="#常量成员函数" class="headerlink" title="常量成员函数"></a>常量成员函数</h2><ul>
<li>不改变成员的函数要在函数声明圆括号()后,函数体花括号{}前,用const修饰 (第<code>9</code>,<code>10</code>行)</li>
</ul>
<h2 id="返回值传递"><a href="#返回值传递" class="headerlink" title="返回值传递"></a>返回值传递</h2><ul>
<li><p>值传递 pass by value, 引用传递 pass by reference (to const)</p>
<blockquote>
<p>值传递 所有参数的值压入函数的栈(如果数据量很大,将很耗资源)<br>引用传递 (底层是指针实现) 效率更高,但是没有指针的缺点。尽量传引用<br>当不希望传递的引用被修改，改为常量引用 (第 <code>5</code> 行)</p>
</blockquote>
</li>
<li><p>返回值 返回引用 (第 <code>5</code> 行)</p>
</li>
</ul>
<h2 id="friend-友元"><a href="#friend-友元" class="headerlink" title="friend(友元)"></a><code>friend</code>(友元)</h2><ul>
<li>友元函数可以操作私有变量(<code>14</code>行)</li>
<li>相同class的各个objects互为friends(友元) 一个obj可以操作另一个obj的私有变量</li>
</ul>
<h2 id="class-body外的各种定义"><a href="#class-body外的各种定义" class="headerlink" title="class body外的各种定义"></a>class body外的各种定义</h2><ul>
<li>返回对象的是函数内创建的变量时,要用return value (引用在函数结束后被销毁)</li>
</ul>
<h1 id="P5-操作符重载和临时变量"><a href="#P5-操作符重载和临时变量" class="headerlink" title="P5.操作符重载和临时变量"></a>P5.操作符重载和临时变量</h1><ul>
<li>区别于C语言,C++中操作符也被认为是一种函数,可以进行重载.这就可以对新的类型进行加减乘除操作,例如复数的运算.</li>
<li>所有的成员函数默认都有一个<code>this</code>指针,指向调用自己的实例.</li>
</ul>
<h2 id="operator-overloading-操作符重载-1-成员函数-this"><a href="#operator-overloading-操作符重载-1-成员函数-this" class="headerlink" title="operator overloading(操作符重载-1,成员函数) this"></a>operator overloading(操作符重载-1,成员函数) this</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="built_in">complex</span>&amp;</span><br><span class="line">__doapl (<span class="built_in">complex</span>* ths, <span class="keyword">const</span> <span class="built_in">complex</span>&amp; r)</span><br><span class="line">&#123;</span><br><span class="line">  ths-&gt;re += r.re;</span><br><span class="line">  ths-&gt;im += r.im;</span><br><span class="line">  <span class="keyword">return</span> *ths;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="built_in">complex</span>&amp;</span><br><span class="line"><span class="built_in">complex</span>::<span class="keyword">operator</span> += (<span class="keyword">const</span> <span class="built_in">complex</span>&amp; r)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __doapl (<span class="keyword">this</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>传递者</strong>无需知道<strong>接收者</strong>是以 <strong>reference</strong> 的形式接收 (<code>20-26行</code>函数<code>__doapl()</code> return *this; 但是它的声明却是引用)</li>
<li>操作符重载要考虑连续调用, 因此声明时, 返回类型不能是<code>void</code>, 如<code>c3 += c2 += c1;</code></li>
</ul>
<h2 id="operator-overloading-操作符重载-2-非成员函数-无this"><a href="#operator-overloading-操作符重载-2-非成员函数-无this" class="headerlink" title="operator overloading(操作符重载-2, 非成员函数) 无this"></a>operator overloading(操作符重载-2, 非成员函数) 无this</h2><p><code>c2 = c1 + c2</code>这种情况, 同时要考虑复数+实数, 实数+复数, 复数+虚数等情况进行重载</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">double</span></span><br><span class="line">imag (<span class="keyword">const</span> <span class="built_in">complex</span>&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> x.imag ();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">double</span></span><br><span class="line">real (<span class="keyword">const</span> <span class="built_in">complex</span>&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> x.real ();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="built_in">complex</span></span><br><span class="line"><span class="keyword">operator</span> + (<span class="keyword">const</span> <span class="built_in">complex</span>&amp; x, <span class="keyword">const</span> <span class="built_in">complex</span>&amp; y)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">complex</span> (real (x) + real (y), imag (x) + imag (y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>注意 这些函数一定要return by value 不能by reference, 因为返回的是临时变量</li>
</ul>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp;</span><br><span class="line"><span class="keyword">operator</span> &lt;&lt; (ostream&amp; os, <span class="keyword">const</span> <span class="built_in">complex</span>&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> os &lt;&lt; <span class="string">&#x27;(&#x27;</span> &lt;&lt; real (x) &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; imag (x) &lt;&lt; <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>输出函数重载, 参数os没有使用const是因为 输出字符会改变os的状态</li>
<li>虽然不在乎<code>cout</code> 的返回值, 但是考虑到连续输出的情况, 即 <code>cout&lt;&lt; c1 &lt;&lt; c2</code> 因此重载函数的返回类型应是<code>ostream&amp;</code></li>
</ul>
<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><blockquote>
<ol>
<li>数据一定放在private区,</li>
<li>参数和返回值尽量以引用来传递(根据情况要不要加const)</li>
<li>不修改数据的函数要用 <code>const</code> 修饰</li>
<li>使用 <code>initialization list</code> 设置初值</li>
</ol>
</blockquote>
<h1 id="P7三大函数-拷贝构造-拷贝赋值-析构"><a href="#P7三大函数-拷贝构造-拷贝赋值-析构" class="headerlink" title="P7三大函数 拷贝构造 拷贝赋值 析构"></a>P7三大函数 拷贝构造 拷贝赋值 析构</h1><figure class="highlight cpp"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:                                 </span><br><span class="line">   String(<span class="keyword">const</span> <span class="keyword">char</span>* cstr=<span class="number">0</span>); </span><br><span class="line">   String(<span class="keyword">const</span> String&amp; str); </span><br><span class="line">   String&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> String&amp; str); </span><br><span class="line">   ~String(); </span><br><span class="line">   <span class="function"><span class="keyword">char</span>* <span class="title">get_c_str</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_data; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">char</span>* m_data; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Classes-的两个经典分类-是否包含指针"><a href="#Classes-的两个经典分类-是否包含指针" class="headerlink" title="Classes 的两个经典分类,是否包含指针"></a>Classes 的两个经典分类,是否包含指针</h2><ul>
<li>class 内带指针,需要自己实现拷贝构造和拷贝赋值</li>
<li>拷贝构造:构造函数接受的参数类型是这个类型本身(<code>第5行</code>)</li>
<li>拷贝赋值:操作符重载来实现.接受的类型还是本身(<code>第6行</code>)</li>
<li>析构函数:<code>~</code>构造函数() 离开作用域后删除</li>
<li>class内含有指针,多半需要动态分配内存,因此需要自己析构</li>
</ul>
<h2 id="拷贝赋值函数"><a href="#拷贝赋值函数" class="headerlink" title="拷贝赋值函数"></a>拷贝赋值函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span></span><br><span class="line">String&amp; String::<span class="keyword">operator</span>=(<span class="keyword">const</span> String&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str)</span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">delete</span>[] m_data;</span><br><span class="line">   m_data = <span class="keyword">new</span> <span class="keyword">char</span>[ <span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span> ];</span><br><span class="line">   <span class="built_in">strcpy</span>(m_data, str.m_data);</span><br><span class="line">   <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>经典做法:</p>
<ol>
<li><strong>先检测自我赋值, 否则下一步清空数据将导致没有数据拷贝</strong></li>
<li><strong>再清空自己的数据</strong></li>
<li><strong>再创建需要的空间</strong></li>
<li>拷贝数据</li>
</ol>
</blockquote>
<h1 id="P8-堆、栈与内存管理"><a href="#P8-堆、栈与内存管理" class="headerlink" title="P8 堆、栈与内存管理"></a>P8 堆、栈与内存管理</h1><h2 id="stack-栈"><a href="#stack-栈" class="headerlink" title="stack 栈"></a>stack 栈</h2><p>  stack是存在于某个作用域(scope)的一块内存空间(memory space). 例如当你调用函数时, 函数本身会形成一个stack来放置他所接受的参数, 以及返回的地址. 函数本体被声明的变量都来自stack.(离开作用域自动释放)</p>
<h2 id="heap-堆"><a href="#heap-堆" class="headerlink" title="heap 堆"></a>heap 堆</h2><p>heap是有操作系统提供的一块global的内存空间, 程序可动态分配(dynamic allocated)从某种获得若干区块(block).(需要手动释放 delete)</p>
<h2 id="静态对象-static-local-object"><a href="#静态对象-static-local-object" class="headerlink" title="静态对象 static local object"></a>静态对象 static local object</h2><p>函数内用<strong>stack</strong>修饰变量, 其声明在作用域结束后仍然存在, 直到整个程序结束. 与之相同的还有全局变量(声明在所有函数之外)</p>
<hr>
<ul>
<li>new: 先分配memory, 在调用ctor, 底层为:</li>
</ul>
<blockquote>
<ol>
<li>计算class的大小</li>
<li>再调用malloc分配内存(默认返回 <code>void*</code> )</li>
<li>修改指针类型</li>
<li>传给构造函数</li>
</ol>
</blockquote>
<ul>
<li>delete: 先调用dtor, 再释放memory, 底层为:</li>
</ul>
<blockquote>
<ol>
<li>先调用析构函数, 删除该类型内部动态分配的内存</li>
<li>再调用delete删除该类型变量的指针( <code>free</code> 实现))</li>
</ol>
</blockquote>
<h2 id="动态分配所得的内存块"><a href="#动态分配所得的内存块" class="headerlink" title="动态分配所得的内存块"></a>动态分配所得的内存块</h2><ul>
<li>获得的内存的大小一般是16的倍数(不够补齐), 前后有cookie来标记内存的长度, 用cookie的最后一位表示是创建还是回收</li>
<li>array new 一定好array delete <code>String* p = new String[3];</code> 之后一定要<code>delete []p;</code>这样才会多次调用dtor 否则只释放了数组的第一个对象.</li>
</ul>
<h1 id="P10-拓展补充-类模板-函数模板等"><a href="#P10-拓展补充-类模板-函数模板等" class="headerlink" title="P10 拓展补充 类模板, 函数模板等"></a>P10 拓展补充 类模板, 函数模板等</h1><h2 id="static补充"><a href="#static补充" class="headerlink" title="static补充"></a>static补充</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> m_rate;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set_rate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; x)</span> </span>&#123; m_rate = x;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">double</span> Account::m_rate = <span class="number">8.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Account::set_rate(<span class="number">5.0</span>);<span class="comment">//通过class name调用</span></span><br><span class="line">  Account a;</span><br><span class="line">  a.set_rate(<span class="number">7.0</span>);<span class="comment">//通过 object 调用</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<ul>
<li>类内的静态函数只能处理类内静态变量</li>
<li>类内静态变量要在所有函数之外先定义</li>
</ul>
<h1 id="P11-组合和继承"><a href="#P11-组合和继承" class="headerlink" title="P11. 组合和继承"></a>P11. 组合和继承</h1><h2 id="Composition-复合-表示has-a"><a href="#Composition-复合-表示has-a" class="headerlink" title="Composition 复合, 表示has-a"></a>Composition 复合, 表示has-a</h2><ul>
<li>类内有一个别的类型</li>
<li>Adapter 适配器模式 一个类经过另一个类的稍加修改实现功能, 例如用deque双端队列实现queue队列</li>
<li>编译复合类时, 构造由内而外, 先调用内部类默认的构造函数, 在调用自身的ctor, 析构由外而内.</li>
</ul>
<h2 id="Delegation-委托-composition-by-reference"><a href="#Delegation-委托-composition-by-reference" class="headerlink" title="Delegation 委托, composition by reference"></a>Delegation 委托, composition by reference</h2><ul>
<li>两个类用指针相连, 两个类生命周期不同步</li>
<li>Pointer to Implementation    PIMPL模式<ul>
<li>有的成员指针，将指针所指向的类的内部实现数据进行隐藏,</li>
<li>降低模块的耦合</li>
<li>降低编译依赖，</li>
<li>提高编译速度接口与实现分离，提高接口的稳定性</li>
</ul>
</li>
</ul>
<h2 id="Inheritance-继承-表示is-a"><a href="#Inheritance-继承-表示is-a" class="headerlink" title="Inheritance 继承 表示is-a"></a>Inheritance 继承 表示is-a</h2><p>最常见的是public继承</p>
<p>(父类)base class 的dtor必须是virtual, 否则会出现undefined behavior</p>
<h1 id="P10-虚函数和多态"><a href="#P10-虚函数和多态" class="headerlink" title="P10. 虚函数和多态"></a>P10. 虚函数和多态</h1><h2 id="Inheritance-with-virtual-functions"><a href="#Inheritance-with-virtual-functions" class="headerlink" title="Inheritance with virtual functions"></a>Inheritance with <strong>virtual</strong> functions</h2><ul>
<li>non-virtual函数: 不希望子类 (derived class)重新定义(override, 覆写)它</li>
<li>virtual 函数: 希望子类重新定义它, 默认已有定义</li>
<li>pure virtual函数: 子类一定要重新定义, 默认没有定义</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>：</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;<span class="comment">// pure virtual</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> viod <span class="title">error</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; msg)</span></span>;<span class="comment">// impure virtual</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">objectID</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//non-virtual</span></span><br><span class="line">    ···</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span><span class="keyword">public</span> Shape&#123;···&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ellipse</span>:</span><span class="keyword">public</span> Shape&#123;···&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>设计模式-模板设计(template method)</strong>: 父类设计好大部分程序, 留下其中几个虚函数让子类实现, 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤, 而将一些步骤延迟到子类中实现</p>
<h2 id="Delegation-委托-Inheritance-继承"><a href="#Delegation-委托-Inheritance-继承" class="headerlink" title="Delegation(委托) + Inheritance(继承)"></a>Delegation(委托) + Inheritance(继承)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> m_value;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Observer*&gt;m_views;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer* osb)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      m_views.push_pack(obs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_val</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      m_value = value;</span><br><span class="line">      notify()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;m_views.size(); ++i)</span><br><span class="line">        m_views[i]-&gt;update(<span class="keyword">this</span>,m_value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Subject* sub, <span class="keyword">int</span> value)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>观察者模式: 当对象间存在一对多关系时, 则使用观察者模式(Observer Pattern). 比如, 当一个对象被修改时, 则会自动通知依赖它的对象</li>
</ul>
<h1 id="P13-委托相关设计"><a href="#P13-委托相关设计" class="headerlink" title="P13. 委托相关设计"></a>P13. 委托相关设计</h1><h2 id="设计模式-组合设计-Composite"><a href="#设计模式-组合设计-Composite" class="headerlink" title="设计模式-组合设计(Composite)"></a>设计模式-组合设计(Composite)</h2><ul>
<li>把一组相似的对象当作一个单一的对象. 组合模式依据树形结构来组合对象, 用来表示部分以及整体层次</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Component(<span class="keyword">int</span> val) &#123; value = val; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">( Component* )</span> </span>&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Primitive</span>:</span> <span class="keyword">public</span> Component</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Primitive(<span class="keyword">int</span> val): Component(val) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Composite</span>:</span> <span class="keyword">public</span> Component</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span> &lt;Component*&gt; c;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Composite(<span class="keyword">int</span> val): Component(val) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Component* elem)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      c.push_back(elem);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>
<h2 id="设计模式-原型模式"><a href="#设计模式-原型模式" class="headerlink" title="设计模式-原型模式"></a>设计模式-原型模式</h2><p>父类需要调用子类, 每一个子类都有一个 clone 方法, 通过拷贝这些原型创建新的对象</p>
<hr>
<hr>
<h1 id="下篇"><a href="#下篇" class="headerlink" title="下篇"></a>下篇</h1><p>C++ 程序设计(Ⅱ) <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av19151507?p=1&amp;t=62">https://www.bilibili.com/video/av19151507?p=1&amp;t=62</a></p>
<h2 id="P2-conversion-function-转换函数"><a href="#P2-conversion-function-转换函数" class="headerlink" title="P2.conversion function, 转换函数"></a>P2.conversion function, 转换函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Fraction(<span class="keyword">int</span> num, <span class="keyword">int</span> den=<span class="number">1</span>)</span><br><span class="line">    : m_numerator(num), m_denominator(den) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="comment">//conversion function: fraction -&gt; double</span></span><br><span class="line">      <span class="keyword">return</span> (<span class="keyword">double</span>)(m_numerator / m_denominator); </span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_numerator;   <span class="comment">//分子</span></span><br><span class="line">    <span class="keyword">int</span> m_denominator; <span class="comment">//分母</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">4</span> + f; <span class="comment">//编译器先找有没有重载 fraction + int类型,再找fraction能不能转成double</span></span><br><span class="line">                  <span class="comment">//调用operator double() 将 f 转为 0.6</span></span><br></pre></td></tr></table></figure>
<h2 id="non-explicit-one-argument-ctor"><a href="#non-explicit-one-argument-ctor" class="headerlink" title="non-explicit-one-argument ctor"></a>non-explicit-one-argument ctor</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Fraction(<span class="keyword">int</span> num, <span class="keyword">int</span> den=<span class="number">1</span>) </span><br><span class="line">      : m_numerator(num), m_denominator(den)</span><br><span class="line">        </span><br><span class="line">    Fraction <span class="keyword">operator</span>+(<span class="keyword">const</span> Fraction&amp; f) </span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//···</span></span><br><span class="line">      <span class="keyword">return</span> f; </span><br><span class="line">    &#125; </span><br><span class="line">  <span class="keyword">private</span>:   </span><br><span class="line">    <span class="keyword">int</span> m_numerator;    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">int</span> m_denominator;  <span class="comment">//</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line">Fraction d2 = f + <span class="number">4</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>分数类中 ctor den已有默认值1, 可以只需输入num的值 — one argument</li>
<li>因为den已有默认值1,         <code>Fraction d2 = f + 4;</code>中调用 non-explicit ctor 将4 转为Fraction(4, 1), 然后调用 <code>operator +</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">explicit</span> <span class="title">Fraction</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> den=<span class="number">1</span>)</span> </span></span><br><span class="line"> : m_numerator(num), m_denominator(den)&#123;  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">double</span>)m_numerator / m_denominator; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fraction <span class="keyword">operator</span>+(<span class="keyword">const</span> Fraction&amp; f) &#123;  </span><br><span class="line">   <span class="comment">//··· plus</span></span><br><span class="line">   <span class="keyword">return</span> f; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:   </span><br><span class="line">   <span class="keyword">int</span> m_numerator;    <span class="comment">//</span></span><br><span class="line">   <span class="keyword">int</span> m_denominator;  <span class="comment">//</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line">Fraction d2 = f + <span class="number">4</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>若cotr前没有explicit,         <code>Fraction d2 = f + 4;</code>存在歧义 ambiguous, 可以都变成分数, 也可以都变成double</li>
<li>ctor前有explicit, 意为没有明确写构造函数时, 不要转换(取消隐式转换). 所以<code>Fraction d2 = f + 4;</code>中f被转成double后相加, 无法再转回Fraction, 无法通过编译.</li>
</ul>
<h1 id="P4-pointer-like-classes-关于智能指针"><a href="#P4-pointer-like-classes-关于智能指针" class="headerlink" title="P4.pointer-like classes, 关于智能指针"></a>P4.pointer-like classes, 关于智能指针</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shared_ptr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    T&amp; <span class="keyword">operator</span>* () <span class="keyword">const</span></span><br><span class="line">    &#123; <span class="keyword">return</span> *px; &#125;</span><br><span class="line"></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span></span><br><span class="line">    &#123; <span class="keyword">return</span> px; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">shared_ptr</span>(T* p) : px(p) &#123; &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    T*    px;</span><br><span class="line">    <span class="keyword">long</span>* pn;</span><br><span class="line">    <span class="comment">//···</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">//···</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;Foo&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> Foo)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Foo <span class="title">f</span><span class="params">(*sp)</span></span>;<span class="comment">// * 解引用</span></span><br><span class="line"></span><br><span class="line">sp-&gt;method();<span class="comment">//  转换为 px-&gt;method(),  sp-&gt; 重载后 -&gt;会继续作用 即 (sp.operator-&gt;())-&gt;method 也就是px-&gt;method</span></span><br></pre></td></tr></table></figure>
<ul>
<li>* 称之为 解引用</li>
<li><code>operator-&gt;()</code>重载后 会继续作用 <code>-&gt;</code></li>
</ul>
<h2 id="pointer-like-classes-迭代器"><a href="#pointer-like-classes-迭代器" class="headerlink" title="pointer-like classes, 迭代器"></a>pointer-like classes, 迭代器</h2><ul>
<li>迭代器也是一种智能指针</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reference <span class="keyword">operator</span>*() cosnt &#123;<span class="keyword">return</span> (*node).data;&#125;</span><br><span class="line">pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123;<span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*());&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对迭代器解引用就是取出节点的数据</li>
<li>对迭代器访问方法, 就是先取出数据在访问方法</li>
</ul>
<h1 id="P5-function-like-classes-仿函数"><a href="#P5-function-like-classes-仿函数" class="headerlink" title="P5.function-like classes, 仿函数"></a>P5.function-like classes, 仿函数</h1><ul>
<li>仿函数都是某个类重载<code>()</code>, 使其具有函数的特性, 标准库的仿函数详见STL课程</li>
</ul>
<h1 id="P6-namespace-经验谈"><a href="#P6-namespace-经验谈" class="headerlink" title="P6.namespace, 经验谈"></a>P6.namespace, 经验谈</h1><ul>
<li>防止起名冲突, 用namespace加以区分</li>
</ul>
<h1 id="P7-and-P8-class-template-类模板-function-template-函数模板"><a href="#P7-and-P8-class-template-类模板-function-template-函数模板" class="headerlink" title="P7 and P8 .class template 类模板, function template 函数模板"></a>P7 and P8 .class template 类模板, function template 函数模板</h1><ul>
<li>复习之前课程, 没有新内容</li>
</ul>
<h1 id="P9-成员模板"><a href="#P9-成员模板" class="headerlink" title="P9. 成员模板"></a>P9. 成员模板</h1><ul>
<li>类的成员函数是模板函数.</li>
</ul>
<figure class="highlight cpp"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> jj01</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Base1</span> &#123;</span>  &#125;; </span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Derived1</span>:</span> <span class="keyword">public</span> Base1 &#123;  &#125;;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Base2</span> &#123;</span>  &#125;; </span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Derived2</span>:</span> <span class="keyword">public</span> Base2 &#123;  &#125;; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pair</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T1 first_type; </span><br><span class="line">    <span class="keyword">typedef</span> T2 second_type; </span><br><span class="line"></span><br><span class="line">    T1 first; </span><br><span class="line">    T2 second; </span><br><span class="line">    <span class="built_in">pair</span>() : first(T1()), second(T2()) &#123;&#125;</span><br><span class="line">    <span class="built_in">pair</span>(<span class="keyword">const</span> T1&amp; a, <span class="keyword">const</span> T2&amp; b) : first(a), second(b) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">U1</span>, <span class="keyword">class</span> <span class="title">U2</span>&gt;</span></span><br><span class="line">    <span class="built_in">pair</span>(<span class="keyword">const</span> <span class="built_in">pair</span>&lt;U1, U2&gt;&amp; p) : first(p.first), second(p.second) &#123;&#125;</span><br><span class="line">  &#125;; </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">test_member_template</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;test_member_template()&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">pair</span>&lt;Derived1, Derived2&gt; p; </span><br><span class="line">    pair&lt;Base1, Base2&gt; p2(pair&lt;Derived1, Derived2&gt;()); </span><br><span class="line">    pair&lt;Base1, Base2&gt; p3(p);   </span><br><span class="line">    <span class="comment">//Derived1 will be assigned to Base1; Derived2 will be assigned to Base2.</span></span><br><span class="line">    <span class="comment">//OO allow such assignments since of &quot;is-a&quot; relationship between them.  </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! pair&lt;Derived1, Derived2&gt; p4(p3); </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//error messages as below appear at the ctor statements of pair member template</span></span><br><span class="line">    <span class="comment">// [Error] no matching function for call to &#x27;Derived1::Derived1(const Base1&amp;)&#x27;</span></span><br><span class="line">    <span class="comment">// [Error] no matching function for call to &#x27;Derived2::Derived2(const Base2&amp;)&#x27;</span></span><br><span class="line"></span><br><span class="line">    Base1* ptr = <span class="keyword">new</span> Derived1; <span class="comment">//up-cast </span></span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;Base1&gt; <span class="title">sptr</span><span class="params">(<span class="keyword">new</span> Derived1)</span></span>; <span class="comment">//simulate up-cast</span></span><br><span class="line">    <span class="comment">//Note: make sure your environment support C++2.0 at first.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>通常<code>T1</code> 是<code>U1</code>的父类,<code>T2</code>是<code>U2</code>的父类.可以实现继承和多态的巧妙使用,如<code>26</code>行.反正则不行,如<code>31</code>行.</p>
</li>
<li><p>父类的指针可以指向子类 如<code>38</code>行</p>
</li>
</ul>
<h1 id="P10-specialization-模板特化"><a href="#P10-specialization-模板特化" class="headerlink" title="P10.specialization, 模板特化"></a>P10.specialization, 模板特化</h1><p>在模板类中指定某一个类型进行表述，特化版本 <code>template &lt;&gt;</code> 尖括号中由于已经指定类型就为空</p>
<figure class="highlight cpp"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&#123;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;</span><span class="keyword">char</span>&gt;&#123;</span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">char</span> x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="P11-partial-specialization-模板偏特化"><a href="#P11-partial-specialization-模板偏特化" class="headerlink" title="P11.partial specialization, 模板偏特化"></a>P11.partial specialization, 模板偏特化</h1><ul>
<li>个数的偏,指定某个参数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc=···&gt;</span><br><span class="line">class <span class="built_in">vector</span></span><br><span class="line">&#123;</span><br><span class="line">  ···</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Alloc=···&gt;</span><br><span class="line">class <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>,Alloc&gt;</span><br><span class="line">&#123;</span><br><span class="line">  ···</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在c++中,最小的单元是<code>char</code>,用来表示<code>bool</code>空间利用率不高，因此需要重新设计针对<code>bool</code>的<code>vector</code>.</p>
<ul>
<li>范围上的偏,将范围由任意类型变为指针类型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> template &lt;typename T&gt;</span><br><span class="line"> class C</span><br><span class="line"> &#123;</span><br><span class="line">   ···</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> template &lt;typename T&gt;</span><br><span class="line"> class C&lt;T*&gt;</span><br><span class="line"> &#123;</span><br><span class="line">   ···</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line">C&lt;string&gt;  obj1;&#x2F;&#x2F;调用第2行</span><br><span class="line">C&lt;string*&gt; obj2;&#x2F;&#x2F;调用第8行</span><br></pre></td></tr></table></figure>
<h1 id="P12-template-template-parameter-模板模板参数"><a href="#P12-template-template-parameter-模板模板参数" class="headerlink" title="P12.template template parameter,模板模板参数"></a>P12.template template parameter,模板模板参数</h1><ul>
<li>模板的参数也是模板</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,</span><br><span class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Container</span></span></span><br><span class="line"><span class="class">        &gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XCls</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">      Container&lt;T&gt; c;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      ···</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Lst = <span class="built_in">list</span>&lt;T,allocator&lt;T&gt;&gt;;<span class="comment">//在下一门课程讲解</span></span><br><span class="line"><span class="comment">//XCls &lt;string,list&gt; mylst1; 错误，list 接受两个参数要用上一行所示才能运行</span></span><br><span class="line">XCls&lt;<span class="built_in">string</span>,Lst&gt;; mylst2</span><br></pre></td></tr></table></figure>
<ul>
<li>私有变量 <code>mylst2.c</code>的类型就是 <code>list&lt;string&gt;</code></li>
<li>下面这个不是模板模板参数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Sequence</span> =</span> <span class="built_in">deque</span>&lt;T&gt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">stack</span>&#123;</span></span><br><span class="line">  ···</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>,<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&gt; s2;</span><br></pre></td></tr></table></figure>
<p>若前面是<code>int</code>,后面必须是<code>list&lt;int&gt;</code>,因此不是模板模板参数,</p>
<p>p13.介绍标准库, 尽量每个函数都去用一遍</p>
<h1 id="P14-三个主题"><a href="#P14-三个主题" class="headerlink" title="P14. 三个主题"></a>P14. 三个主题</h1><h2 id="variadic-template-C-11-数量不定模板参数"><a href="#variadic-template-C-11-数量不定模板参数" class="headerlink" title="variadic template (C++11) 数量不定模板参数"></a>variadic template (C++11) 数量不定模板参数</h2><ul>
<li>注意: <code>...</code>是语法的一部分,表示这是一个包(pack)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void print()&#123; &#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T, typename... Types&gt;</span><br><span class="line">void print(const T&amp; firstArg, const Types&amp;... args)</span><br><span class="line">&#123;</span><br><span class="line">  cout&lt;&lt; firstArg&lt;&lt;endl;</span><br><span class="line">  print(args...);&#x2F;&#x2F;递归调用</span><br><span class="line">&#125;</span><br><span class="line">print(7.5,&quot;hello&quot;,bitset&lt;16&gt;(377),42)</span><br><span class="line">&#x2F;&#x2F; 7.5</span><br><span class="line">&#x2F;&#x2F; hello</span><br><span class="line">&#x2F;&#x2F; 0000000101111001</span><br><span class="line">&#x2F;&#x2F; 42</span><br></pre></td></tr></table></figure>
<ul>
<li>当执行第<code>9</code>行打印，参数被分成<code>7.5</code>和后面的一包(pack)，调用第<code>4</code>行，打印第一个参数，如此递归至最后一个发现没有参数，调用第<code>1</code>行 什么也不做，停止递归。</li>
</ul>
<h2 id="auto-C-11"><a href="#auto-C-11" class="headerlink" title="auto (C++11)"></a>auto (C++11)</h2><ul>
<li>auto 语法糖 用于类型推导</li>
</ul>
<figure class="highlight cpp"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lsit&lt;<span class="built_in">string</span>&gt; c;</span><br><span class="line">···</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;::iterator ite;</span><br><span class="line">ite = find(c.begin(),c.end(),target);</span><br></pre></td></tr></table></figure>
<p>由于写出迭代器的类型比较繁琐可以使用auto进行类型推导</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ite = find(c.begin(),c.end(),target);<span class="comment">//代替上面3,4行</span></span><br></pre></td></tr></table></figure>
<h2 id="range-base-for-C-11"><a href="#range-base-for-C-11" class="headerlink" title="range-base for (C++11)"></a>range-base for (C++11)</h2><p>语法糖 方便<code>for</code>循环 语法如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(decl:coll)<span class="comment">//decl-声明，coll-容器。将容器中的元素一个个取出来</span></span><br><span class="line">&#123;</span><br><span class="line">  statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如下面的例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i :&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;)<span class="comment">// &#123;···&#125; 为c++11中新增的容器类型</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vec</span><br><span class="line">···<span class="comment">//给容器添加一些值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> elem:vec)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; elem &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//传值 pass by value</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; elem:vec)</span><br><span class="line">&#123;</span><br><span class="line">  elem *= <span class="number">3</span>; <span class="comment">//传引用 pass by reference 修改容器内部值</span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="P15-reference"><a href="#P15-reference" class="headerlink" title="P15 reference"></a>P15 reference</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>* p = &amp;x; </span><br><span class="line"><span class="keyword">int</span>&amp; r = x;<span class="comment">//r代表x，现在r，x都是0</span></span><br><span class="line"><span class="keyword">int</span> x2 = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">r = x2;<span class="comment">// r不能重新代表其他变量，这句话相当于给r代表的x赋值，即x = x2，现在r，x2都是5</span></span><br><span class="line"><span class="keyword">int</span>&amp; r2 = r;<span class="comment">//r2代表r，相当于代表x，所以r2是5</span></span><br></pre></td></tr></table></figure>
<ul>
<li>引用智能绑定一次</li>
<li><code>sizeof(r) == sizeof(x)</code></li>
<li><code>&amp;x == &amp;r</code></li>
<li><code>object</code> 和其<code>reference</code>的大小地址都相同(编译器帮助实现，其实是假象)</li>
</ul>
<h2 id="reference-的常见用途"><a href="#reference-的常见用途" class="headerlink" title="reference 的常见用途"></a>reference 的常见用途</h2><ul>
<li>reference 通常不用于声明变量，而用于参数类型(parameter type)和返回类型(return type)</li>
</ul>
<figure class="highlight cpp"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(Cls* pobj)</span></span>&#123; pobj-&gt;xxx(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(Cls  obj )</span></span>&#123;  obj-&gt;xxx(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">(Cls&amp; obj )</span></span>&#123;  obj-&gt;xxx(); &#125;</span><br><span class="line"></span><br><span class="line">··· </span><br><span class="line">Cls obj;</span><br><span class="line">func1(&amp;obj);</span><br><span class="line">func2(obj);</span><br><span class="line">func3(obj);</span><br></pre></td></tr></table></figure>
<ul>
<li>在函数内部传值和传引用调用函数的写法相同</li>
<li>在外部传入参数，传值和传引用的接口也相同</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">imag</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; im)</span> </span>&#123;···&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">imag</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>  im)</span> </span>&#123;···&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这两个函数不能共存，因为它们的函数签名相同</li>
<li>函数括号后的const 也是函数签名的一部分，函数签名不包括前面的返回类型</li>
</ul>
<h1 id="P16-复合-继承关系下的构造和析构"><a href="#P16-复合-继承关系下的构造和析构" class="headerlink" title="P16. 复合 +  继承关系下的构造和析构"></a>P16. 复合 +  继承关系下的构造和析构</h1><p>复习之前课程</p>
<h1 id="P17-关于vptr和vtbl"><a href="#P17-关于vptr和vtbl" class="headerlink" title="P17.关于vptr和vtbl"></a>P17.关于vptr和vtbl</h1><ul>
<li>带着虚函数的类会比类内生命数据加起来还要大（因为虚函数要占用一个指针）</li>
<li>类的继承：继承了成员和函数的调用权</li>
<li>虚函数的虚指针vptr指向虚表vtbl，虚表里放着要调用的虚函数的地址</li>
<li>当改写继承的虚函数就是修改了虚标里的函数指针，</li>
<li>多态中 动态绑定：1.通过指针指向某类（某个子类）；2.指针向上转型；3.调用虚函数</li>
<li>静态绑定: 调用函数直接跳转到某个地址</li>
<li>动态绑定的C描述<code>(*p-&gt;vptr[n])(p)</code></li>
</ul>
<h1 id="关于this"><a href="#关于this" class="headerlink" title="关于this"></a>关于this</h1><ul>
<li>使用动态绑定重新讲解<code>Template Method</code></li>
</ul>
<figure class="highlight cpp"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">CDocument::OnFileOpen()</span><br><span class="line">&#123;</span><br><span class="line">  ···</span><br><span class="line">  Serialize();<span class="comment">//它的定义是个虚函数，由子类实现</span></span><br><span class="line">  ···</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="title">Serialize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyDoc</span>:</span><span class="keyword">public</span> CDocument</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="title">Serialize</span><span class="params">()</span></span>&#123;···&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">  CMyDoc myDoc;</span><br><span class="line">  ···</span><br><span class="line">  myDoc.OnFileOpen();<span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>虽然子类调用的是从父类继承的函数(<code>18</code>行)，但是其中的虚函数已经在子类改写过(<code>11</code>行),就会以动态绑定的方式执行子类重新定义过的虚函数</li>
</ul>
<h1 id="P18-关于Dynamic-Binging-1"><a href="#P18-关于Dynamic-Binging-1" class="headerlink" title="P18.关于Dynamic Binging(1)"></a>P18.关于Dynamic Binging(1)</h1><h2 id="谈谈-const"><a href="#谈谈-const" class="headerlink" title="谈谈 const"></a>谈谈 const</h2><ul>
<li>const 只能加在成员函数参数括号之后，函数体花括号之前，意为没有修改类成员</li>
<li>const obj 不能调用 non-const member function</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> String <span class="title">str</span><span class="params">(<span class="string">&quot;hello world&quot;</span>)</span></span>;</span><br><span class="line">str.print()</span><br></pre></td></tr></table></figure>
<ul>
<li>若设计<code>string::print()</code> 没有指明<code>const</code> 那么<code>str.print()</code>无法通过编译。</li>
<li>当成员函数的<code>const</code>和<code>non-const</code>版本同时存在时，<code>const obj</code>,只能调用<code>const</code>版本，<code>non-const obj</code>,只能调用<code>non-const</code>版本</li>
</ul>
<h1 id="P19-关于Dynamic-Binging"><a href="#P19-关于Dynamic-Binging" class="headerlink" title="P19.关于Dynamic Binging"></a>P19.关于Dynamic Binging</h1><ul>
<li><p>继承关系:<code>A&lt;-B&lt;-C</code></p>
<figure class="highlight cpp"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">B b;</span><br><span class="line">A a =(A)b;</span><br><span class="line">a.vfunc1();<span class="comment">//静态绑定</span></span><br></pre></td></tr></table></figure>
<ul>
<li>子类强制类型转换,用对象调用虚函数,不是指针。因此调用的还是<code>A::vfunc1()</code></li>
</ul>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A* pa = <span class="keyword">new</span> B;</span><br><span class="line">pa -&gt; vfunc1();</span><br><span class="line"></span><br><span class="line">pa = &amp;b;</span><br><span class="line">pa -&gt; vfunc1();</span><br></pre></td></tr></table></figure>
</li>
<li><p>符合动态绑定的三个特征：指针指向，向上转型，虚函数</p>
</li>
</ul>
<h1 id="P20-21-22-关于new-delete及其重载"><a href="#P20-21-22-关于new-delete及其重载" class="headerlink" title="P20,21,22. 关于new,delete及其重载"></a>P20,21,22. 关于new,delete及其重载</h1><ul>
<li>可以对new 和delete 进行全局重载  <code>::operator new</code>,<code>::operator delete</code>,<code>::operator new[]</code>,<code>::operator delete[]</code> 注意影响所有函数</li>
<li>也可以仅重载member operator new/delete new[]/delete[]</li>
<li>接管 <code>new</code>和<code>delete</code>的目的是为了实现内存池</li>
<li>以下写法强制采取全局的new和delete ,忽略内部的重载。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Foo* pf = ::<span class="keyword">new</span> Foo;</span><br><span class="line">::<span class="keyword">delete</span> pf;</span><br></pre></td></tr></table></figure>
<h1 id="P23-24-重载new-delete"><a href="#P23-24-重载new-delete" class="headerlink" title="P23,24.重载new(),delete()"></a>P23,24.重载new(),delete()</h1><ul>
<li>可以重载<code>class member operator new()</code> 写出多个版本，但前提是每个版本都要声明独特的参数，其中第一个参数必须是<code>size_t</code>类型,其余参数以new所指定的所指定的<code>placement arguments</code>为初值，出现于<code>new(···)</code>, 例如<code>Foo* pf= new(300,&#39;c&#39;)Foo;</code></li>
<li>同样的也可以重载<code>delete</code> 但是<code>delete</code>只有在对应的 <code>operator new</code>的构造函数失败时才调用。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rep* p = <span class="keyword">new</span>(extra)Rep;</span><br></pre></td></tr></table></figure>
<p>标准库字符串重载了placement new，申请大于字符串长度的空间<br>|        |&lt; -  extra   -&gt;|<br>————-|———————-|<br> Rep     |   string 内容 |<br>前面的Rep用于引用计数</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/30/FFT-guide/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lclee">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog-lclee">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/30/FFT-guide/" class="post-title-link" itemprop="url">FFT-guide</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-30 18:48:05" itemprop="dateCreated datePublished" datetime="2020-07-30T18:48:05+08:00">2020-07-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-07 09:53:54" itemprop="dateModified" datetime="2020-12-07T09:53:54+08:00">2020-12-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!-- toc -->
<h1 id="FFT入门"><a href="#FFT入门" class="headerlink" title="FFT入门"></a>FFT入门</h1><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><ol>
<li>信号 $s=A\cos(\omega t + \phi)$，其中$A$为信号的幅值，$\phi$为信号的相位。傅里叶变换就是要找到  $\omega$ ~$A$， 以及$\omega$ ~$\phi$  的关系。（一般我们处理数据大多使用$\omega$ ~$A$的关系）。<img src="/2020/07/30/FFT-guide/时域频域图.jpeg" alt="时域频域图"></li>
<li><p>所有的信号都可以由若干个不同幅值、相位、频率的余弦信号叠加而成即$s=A_1\cos(\omega_1+\phi_1)+A_2\cos(\omega_2+\phi_2)+A_3\cos(\omega_3+\phi_3)+…$   如下图多个频率的余弦逼近门函数<br><img src="/2020/07/30/FFT-guide/正弦逼近方波.gif" alt="逼近方波"></p>
</li>
<li><p>傅里叶变换公式：</p>
<script type="math/tex; mode=display">\mathscr{F}(\omega)=\mathscr{F}[f(t)]=\int_{-\infty}^{+\infty}f(t)e^{-j\omega t} \mathcal{d}t</script><p>傅里叶逆变换</p>
<script type="math/tex; mode=display">\mathscr{f}(\omega)=\mathscr{F}^{-1}[f(\omega)]=\frac{1}{2\pi}\int_{-\infty}^{+\infty}\mathscr{F}(\omega)e^{j\omega t} \mathcal{d}\omega</script><p>注：$\mathscr{F}[f(t)]$称之为对 $f(t)$的傅里叶变换</p>
</li>
<li><p>这里需要简单介绍一下单位冲击函数$\delta(t)$，在图形上用一个长度为1的箭头表示如下图所示<img src="/2020/07/30/FFT-guide/deltaFunc.png" alt="Alt"><br>单位冲击函数具有如下性质</p>
<script type="math/tex; mode=display">\int_{-\infty}^{+\infty} \delta(t)dt=\int_{0^+}^{0^-}\delta(t)dt=1</script></li>
<li><p>cos的傅里叶变换为两个幅值为$\pi$冲击函数 $\delta(\omega)$</p>
<script type="math/tex; mode=display">\mathscr{F}[\cos(\omega_1t)]=\pi[\delta(\omega-\omega_1)+\delta(\omega+\omega_1)]</script><p>称$\cos(\omega_1 t) \Leftrightarrow\pi[\delta(\omega-\omega_1)+\delta(\omega+\omega_1)]$为傅里叶变换对。<br><img src="/2020/07/30/FFT-guide/cosineF.png" alt="cos的傅里叶变换"><br>在图形上是两个幅值为$\pi$频率$\omega=\pm\omega_1$的冲激函数 所以在乘上$\frac{1}{\pi}$后可以得到原来信号的幅值，由此我们找到了$\omega$ ~$A$的关系</p>
</li>
<li>实际处理的数据不同于上面的连续信号，这里要引入一个采样率$Fs$即一秒钟对信号进行多少次采样。例如对于$\cos(\omega_1 t)$ 来说，以采样率$Fs=1000$得到的信号就是一个这样的序列：[$\cos(0.001\omega_1),\cos(0.002\omega_1),\cos(0.003\omega_1),…$]。</li>
<li>由于实际处理的信号都是一个个离散的数值，我们对这些信号的处理称之为离散傅里叶变换DTF，在利用傅里叶变换的对称性优化后得到快速傅里叶变换即我们常用的FFT。(记住我们处理的是离散的数值序列就行。)</li>
</ol>
<h2 id="代码实操"><a href="#代码实操" class="headerlink" title="代码实操"></a>代码实操</h2><p>这里用到的两个库:</p>
<ul>
<li><code>numpy</code> 包含常用的数学函数，我们要用的就是与fft相关的函数。</li>
<li><code>matplotlib</code> 常用的画图库，语法与<code>MATLAB</code>类似。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">Fs = <span class="number">100</span> <span class="comment">#每秒采样率</span></span><br><span class="line"> </span><br><span class="line">t = np.linspace(<span class="number">0</span>,<span class="number">2</span>,<span class="number">2</span>*Fs) <span class="comment">#2秒钟，每秒100个点 这句话是把[0,2]分成200个等间距序列</span></span><br><span class="line">signal = np.cos(<span class="number">2</span>*np.pi*<span class="number">1</span>*t) </span><br><span class="line">plt.scatter(t,signal)<span class="comment">#plt.plot(t,signal) 画曲线用plot 画离散点用scatter</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>当我们将t和signal的作为坐标值得出下图<br><img src="/2020/07/30/FFT-guide/余弦离散点.png" alt="余弦离散点"><br>为了便于观看通常我们使用<code>plt.plot()</code>将相邻的点连接起来便会看到较为光滑的曲线。<br><img src="/2020/07/30/FFT-guide/余弦连线图.png" alt="余弦连线图"><br>采样率$Fs$越大，采集的点就会越密集。这里补充一个知识点：叫做奈奎斯特采样定理。简单的说就是我们可以采集到的频率范围是$[-\frac{Fs}{2},\frac{Fs}{2}]$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">Fs = <span class="number">1000</span> <span class="comment">#每秒采样率</span></span><br><span class="line"> </span><br><span class="line">t = np.linspace(<span class="number">0</span>,<span class="number">2</span>,<span class="number">2</span>*Fs) <span class="comment">#2秒钟，每秒1000个点</span></span><br><span class="line">signal =<span class="number">2</span> * np.cos(<span class="number">2</span>*np.pi*<span class="number">1</span>*t) + <span class="number">0.2</span>*np.sin(<span class="number">2</span>*np.pi*<span class="number">30</span>*t)</span><br><span class="line">plt.plot(t, signal)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>这段程序中先确定了变量$t = [0,0.001,0.002,…,1.999,2]$<br>这里我们生成一个幅值为 2  频率为 1Hz 的余弦与一个幅值为  0.2  频率为  30Hz  的正弦相加$Signal = 2\cos(2\pi t)+0.2\sin(2\pi\times30t)$根据t的不同取值得到得到一个与之对应的信号序列。使用<code>plt.plot(t, signal)</code>画图后可以得到下图。<br><img src="/2020/07/30/FFT-guide/低频余弦加高频正弦.png" alt="低频余弦加高频正弦"></p>
<p>接下来我们对这个信号进行傅里叶变换，具体实现如下。其中<code>np.fft.fftfreq(n, d=1/Fs)</code>是把计算的值换算到常用的以Hz为单位的坐标轴，范围就是之前提到的$[-\frac{Fs}{2},\frac{Fs}{2}]$。傅里叶变换得到的频率信号是[0, 0.1, … , 499.9, 500,-500,-499.9, …, -0.1]。<code>np.fft.fftshift(freq)</code>的作用是把频率从小到大重新排列。<code>F_disp</code>也是同理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">F = np.fft.fft(signal)</span><br><span class="line">n = signal.size</span><br><span class="line">freq =  np.fft.fftshift( np.fft.fftfreq(n, d=<span class="number">1</span>/Fs))</span><br><span class="line">F_disp =  np.fft.fftshift(F)</span><br><span class="line">plt.subplot(<span class="number">211</span>), plt.plot(freq, (<span class="number">2</span>*np.<span class="built_in">abs</span>( F_disp )/n)) </span><br><span class="line">plt.subplot(<span class="number">212</span>), plt.plot(freq, (np.angle( F_disp )/np.pi*<span class="number">180</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>在二维平面上我们使用幅值和相位来描述这个信号。(<code>np.abs(a)</code>，若a是复数，返回a的模，否则就是a的绝对值。)通过<code>plt</code>画图得到下图，代表了幅值和相位随频率的变化。<code>(2*np.abs( F_disp )/n)</code>对应的就是预备知识中的第五点，连续函数乘上$\frac{1}{\pi}$， 离散序列乘上$\frac{1}{\frac{n}{2}}$也就是$\frac{2}{n}$。($2\pi$对应$n$， $\pi$对应$\frac{n}{2}$)<br><img src="/2020/07/30/FFT-guide/fft_out.png" alt="fft结果"><br>对幅值和相位不是很敏感的同学可以绘制3D图来理解FFT的结果，这里我们设置x轴为频率，y轴为实部，z轴为虚部。<br><img src="/2020/07/30/FFT-guide/3D_fft.gif" alt="3D_FFT"><br>绘制3D图的程序如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ax = plt.axes(projection=<span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line">ax.set_zlim(-<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">ax.set_ylim(-<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">ax.set_xlim(-<span class="number">50</span>,<span class="number">50</span>)</span><br><span class="line">ax.plot3D(freq  ,<span class="number">2</span>*F_disp.imag/n, <span class="number">2</span>*F_disp.real/n)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>由于我们的采样率$Fs = 1000$,这就意味着我们的的频率范围是$[-500,500]$。为了方便观察，我们将只选取频率在[-40, 40]的范围进行观察。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">freq_band = np.logical_and(freq&gt;-<span class="number">40</span>, freq&lt;<span class="number">40</span>)</span><br><span class="line">plt.plot(freq[freq_band], (<span class="number">2</span>*np.<span class="built_in">abs</span>( F_disp[freq_band])/n)) </span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/30/FFT-guide/fft_out_band.png" alt="freq_band信号"><br>虽然点击对话框上的放大镜可以实现放大观察，但是<code>freq_band = np.logical_and(freq&gt;-40, freq&lt;40)</code>将[-40,40]之间的频率信号保留下来，为我们接下来的滤波打下基础。<br><img src="/2020/07/30/FFT-guide/bandFreq_UI.png" alt="bandFreq_UI"><br>现实处理的信号也与我们之前处理的$Singal$类似，我们希望得到的信号通常是频率较低幅值较大，对应$2\cos(2\pi t)$，夹杂的噪声通常是频率较高幅值较小,对应$0.2\sin(2\pi\times30t)$<br>接下来我们将30Hz的正弦波滤去还原一个平滑的余弦波。</p>
<ul>
<li><code>np.logical_or(freq&lt;-5, freq&gt;5)</code>选取频率小于-5和大于5的区域，</li>
<li><code>F_disp[freq_band_filter] = 0</code>将这些区域的数值置零</li>
<li>绘制频谱发现30Hz处的尖峰已经滤除<br><img src="/2020/07/30/FFT-guide/filter_freq.png" alt="filter_freq"></li>
<li>由于我们刚刚处理的是平移过的频谱，因此在傅里叶逆变换还原信号前需要使用<code>np.fft.fftshift(F_disp)</code>进行频谱平移，再使用<code>np.fft.ifft()</code>还原信号<br><img src="/2020/07/30/FFT-guide/filter_sig.png" alt="filter_sig"></li>
<li>滤除高频噪声后就能得到我们想要的低频信号。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">freq_band_filter = np.logical_or(freq&lt;-<span class="number">5</span>, freq&gt;<span class="number">5</span>)</span><br><span class="line">F_disp[freq_band_filter] = <span class="number">0</span></span><br><span class="line">plt.plot(freq[freq_band], (<span class="number">2</span>*np.<span class="built_in">abs</span>( F_disp[freq_band])/n)) </span><br><span class="line">filter_sig = np.fft.ifft(np.fft.fftshift(F_disp))</span><br><span class="line">plt.plot(t,filter_sig)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<h2 id="心电信号处理"><a href="#心电信号处理" class="headerlink" title="心电信号处理"></a>心电信号处理</h2><h3 id="数据库简介-Wrist-PPG-During-Exercise"><a href="#数据库简介-Wrist-PPG-During-Exercise" class="headerlink" title="数据库简介 Wrist PPG During Exercise"></a>数据库简介 Wrist PPG During Exercise</h3><p>数据库包含了在步行，跑步和骑自行车过程中记录的腕部 PPGs。同时使用加速度计和陀螺仪进行运动估计，为消除运动对PPG干扰提供多种选择。并记录了胸部心电图作为运动心率的参考标准。</p>
<p><a target="_blank" rel="noopener" href="https://physionet.org/content/wrist/1.0.0/">心率数据 https://physionet.org/content/wrist/1.0.0/</a></p>
<p>Delaram Jarchi and Alexander J. Casson. Description of a Database Containing Wrist PPG Signals Recorded during Physical Exercise with Both Accelerometer and Gyroscope Measures of Motion. Data 2017, 2(1), 1; doi:10.3390/data2010001</p>
<p>Goldberger, A., Amaral, L., Glass, L., Hausdorff, J., Ivanov, P. C., Mark, R., … &amp; Stanley, H. E. (2000). PhysioBank, PhysioToolkit, and PhysioNet: Components of a new research resource for complex physiologic signals. Circulation [Online]. 101 (23), pp. e215–e220.</p>
<h3 id="ECG信号处理"><a href="#ECG信号处理" class="headerlink" title="ECG信号处理"></a>ECG信号处理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> wfdb</span><br></pre></td></tr></table></figure>
<p>心率数据数据都是使用 <code>WFDB</code> 格式保存的,这里我们需要加载wfdb的库。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">path = <span class="string">&quot;.\PPG\s2_walk&quot;</span></span><br><span class="line">sampFrom = <span class="number">0</span></span><br><span class="line">sampLen = <span class="number">4000</span></span><br><span class="line">sampTo = sampFrom+sampLen</span><br><span class="line"></span><br><span class="line">record = wfdb.rdrecord(path, channels=[<span class="number">0</span>,<span class="number">1</span>],sampfrom=sampFrom, sampto=sampTo)</span><br><span class="line">annotation = wfdb.rdann(path, <span class="string">&quot;atr&quot;</span>, sampfrom=sampFrom, sampto=sampTo)</span><br><span class="line">wfdb.plot_wfdb(record=record,annotation=annotation,title=<span class="string">&quot;ecg&quot;</span>,time_units=<span class="string">&quot;seconds&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;anno aver heart rate:&quot;</span>,<span class="built_in">len</span>(annotation.sample)*Fs/sampLen*<span class="number">60</span>)</span><br></pre></td></tr></table></figure>
<p>可以得到以下图形，上半部分为ECG数据，R峰处用红点标记（红点使用数据库自带的标记标出的）。下半部分图是同一时刻对应点PPG数据 。<br><img src="/2020/07/30/FFT-guide/心率原始数据绘制.png" alt="wfdb_plot"></p>
<p>接下来读取ECG信号波形做傅里叶变换，绘制频谱</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">signals, fields = wfdb.rdsamp(path, channels=[<span class="number">0</span>,<span class="number">1</span>], sampfrom=sampFrom, sampto=sampTo)</span><br><span class="line">ecg = signals[:,<span class="number">0</span>]</span><br><span class="line">ppg = signals[:,<span class="number">1</span>]</span><br><span class="line">Fs = fields[<span class="string">&#x27;fs&#x27;</span>] <span class="comment"># 读取采样率</span></span><br><span class="line">n = ecg.size <span class="comment">#采样点个数</span></span><br><span class="line">F_sig = np.fft.fft(ecg)<span class="comment">#对ecg做傅里叶变换</span></span><br><span class="line">freq = np.fft.fftfreq(n, d=<span class="number">1</span>/Fs)<span class="comment">#折合到频域Hz</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(freq[freq&gt;<span class="number">0</span>],<span class="number">2</span>*np.<span class="built_in">abs</span>(F_sig[freq&gt;<span class="number">0</span>])/n)<span class="comment">#这里只绘制频率大于0的部分</span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/30/FFT-guide/ECG频谱.png" alt="ecg频谱"></p>
<p>可以看到频率大多集中在低频部分，观察放大R峰的图形可以发现一个尖峰的频率在15-20Hz，因此我们将频谱中频率小于15Hz的剔除，再求逆变换。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">filter_F = F_sig[:].copy()<span class="comment">#先复制一份频域数据</span></span><br><span class="line">filter_F[np.<span class="built_in">abs</span>(freq)&lt;<span class="number">15</span>] = <span class="number">0</span> <span class="comment">#高通滤波 低于15Hz 的都是0  ，观察图像可知 R峰的频率在15 - 20 Hz</span></span><br><span class="line">filter_sig = np.fft.ifft(filter_F).real <span class="comment">#傅里叶逆变换取实部</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(filter_sig)</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/30/FFT-guide/高通滤波后.png" alt="高通滤波后"><br>观察滤波后的图形可以看出R峰在图中已经十分明显。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">winSize = <span class="number">25</span> <span class="comment">#设置一个窗口大小 </span></span><br><span class="line">thre = <span class="number">5.5</span> * np.mean(np.<span class="built_in">abs</span>(filter_sig))<span class="comment">#对滤波后的数据取绝对值再求平均 乘上一个系数作为 选择R峰点的一个门限</span></span><br><span class="line">sq_sig = filter_sig.copy().reshape(<span class="built_in">int</span>(filter_sig.size/winSize),winSize)<span class="comment">#将滤波后的数据 以winSize为一排 重新排列  这里将其变换成 25 * 160的矩阵</span></span><br><span class="line">peakList = [] <span class="comment">#先设置一个R峰列表 所有的R峰数据都存进去</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(sq_sig)):<span class="comment">#对每一行数据进行处理</span></span><br><span class="line">    norm = np.<span class="built_in">abs</span>(sq_sig[i]) <span class="comment">#对每一行数据取模</span></span><br><span class="line">    aver = np.mean(norm) <span class="comment">#每一行数据的模求平均</span></span><br><span class="line">    win_max = np.<span class="built_in">max</span>(sq_sig[i])<span class="comment">#每一行数据的最大值</span></span><br><span class="line">    <span class="keyword">if</span> np.<span class="built_in">abs</span>(win_max/aver) &lt; <span class="number">2.5</span> <span class="keyword">or</span> win_max &lt; thre: </span><br><span class="line">        sq_sig[i][:] = <span class="number">0</span> <span class="comment">#如果最大值/平均值&lt;2.5 或者最大值小于门限值 则该行清零</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        localIndex = sq_sig[i].tolist().index(win_max)<span class="comment">#找到最大值在该行的索引</span></span><br><span class="line">        peakList.append(localIndex + winSize * i)<span class="comment">#求出最大值在整个信号上的索引</span></span><br><span class="line">new_sig = sq_sig.flatten() <span class="comment">#将矩阵重整为一维数据</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sortPeakList =[peakList[<span class="number">0</span>]]<span class="comment">#离得太近的最大值取较大的哪一个 存入这个列表中</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(peakList)):<span class="comment">#第一个不用处理</span></span><br><span class="line">    front = peakList[i]</span><br><span class="line">    behind = sortPeakList[-<span class="number">1</span>]<span class="comment">#列表中的最后一个值</span></span><br><span class="line">    <span class="keyword">if</span>  front- behind &lt; <span class="number">20</span>:<span class="comment">#当下一个值与整理后的的值太近时</span></span><br><span class="line">        <span class="keyword">if</span> ecg[front] &gt;ecg[behind]: <span class="comment">#删去小的 存入大的</span></span><br><span class="line">            sortPeakList.pop(-<span class="number">1</span>)</span><br><span class="line">            sortPeakList.append(front)</span><br><span class="line">    <span class="keyword">else</span>: <span class="comment">#如果距离足够远则直接存入</span></span><br><span class="line">        sortPeakList.append(front)</span><br><span class="line"><span class="comment"># print(len(sortPeakList))</span></span><br><span class="line">yPeak = [ecg[x] <span class="keyword">for</span> x <span class="keyword">in</span> sortPeakList]<span class="comment">#根据刚刚整理过的R峰横坐标从数据中找出纵坐标y       </span></span><br><span class="line">plt.figure()</span><br><span class="line">print(<span class="string">&quot;calc aver heart rate:&quot;</span>,<span class="built_in">len</span>(sortPeakList)*Fs/sampLen*<span class="number">60</span>)</span><br><span class="line">plt.subplot(<span class="number">212</span>)</span><br><span class="line">plt.plot(ecg)<span class="comment">#在ecg上画出找到的R峰</span></span><br><span class="line">plt.scatter(sortPeakList, yPeak, color=<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">211</span>)</span><br><span class="line">plt.plot(filter_sig,color=<span class="string">&quot;g&quot;</span>)<span class="comment">#绿色为15Hz高通滤波后数据</span></span><br><span class="line">plt.plot(new_sig,color = <span class="string">&quot;r&quot;</span>)<span class="comment">#红色是找R峰处理后的数据</span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/30/FFT-guide/自己标记R峰.png" alt="求出R峰"><br>可以看到自己求得的R峰与最初数据库的值几乎一致，实现了对ECG信号找R峰求心率的目的.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/06/My-py-program/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lclee">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog-lclee">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/06/My-py-program/" class="post-title-link" itemprop="url">My_py_program </a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-06 11:17:34" itemprop="dateCreated datePublished" datetime="2020-07-06T11:17:34+08:00">2020-07-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-03 08:50:52" itemprop="dateModified" datetime="2020-12-03T08:50:52+08:00">2020-12-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9D%82%E9%A1%B9/" itemprop="url" rel="index"><span itemprop="name">杂项</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="My-py-program-简介"><a href="#My-py-program-简介" class="headerlink" title="My_py_program 简介"></a>My_py_program 简介</h2><h3 id="追剧脚本"><a href="#追剧脚本" class="headerlink" title="追剧脚本"></a>追剧脚本</h3><h3 id="特效字体检查"><a href="#特效字体检查" class="headerlink" title="特效字体检查"></a>特效字体检查</h3><h3 id="linux-deploy-部署到手机"><a href="#linux-deploy-部署到手机" class="headerlink" title="linux deploy 部署到手机"></a>linux deploy 部署到手机</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/06/hexo-init/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lclee">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog-lclee">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/06/hexo-init/" class="post-title-link" itemprop="url">Hexo Init</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-06 09:55:18" itemprop="dateCreated datePublished" datetime="2020-07-06T09:55:18+08:00">2020-07-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-22 13:26:18" itemprop="dateModified" datetime="2021-01-22T13:26:18+08:00">2021-01-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9D%82%E9%A1%B9/" itemprop="url" rel="index"><span itemprop="name">杂项</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前提准备"><a href="#前提准备" class="headerlink" title="前提准备"></a>前提准备</h2><p> <a target="_blank" rel="noopener" href="https://nodejs.org/en/">Node.js</a><br> <a target="_blank" rel="noopener" href="https://git-scm.com/">Git</a></p>
<h2 id="Hexo-安装"><a href="#Hexo-安装" class="headerlink" title="Hexo 安装"></a>Hexo 安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure>
<h2 id="Hexo-初始化"><a href="#Hexo-初始化" class="headerlink" title="Hexo 初始化"></a>Hexo 初始化</h2><p>新建一个文件夹 (例如 Hexo-Blog) 进入并初始化</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir Hexo-Blog</span><br><span class="line"><span class="built_in">cd</span> Hexo-Blog</span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure>
<p>这个文件夹必须为空 否则无法初始化成功。当要删除文件夹中的<code>node_modules</code>子文件夹时要安装 <code>rimraf</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install rimraf -g</span><br><span class="line">rimraf node_modules</span><br></pre></td></tr></table></figure>
<h2 id="修改主题并应用"><a href="#修改主题并应用" class="headerlink" title="修改主题并应用"></a>修改主题并应用</h2><p>在当前文件夹 下载新主题</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
<p>修改 <code>Hexo-Blog\_config.yml</code>文件中<code>theme</code>：<code>landscape</code>改为<code>next</code></p>
<p>修改 <code>themes\next\_config.yml</code> 中 <code>scheme</code>: <code>Muse</code> 改为 <code>Gemini</code></p>
<p>在<code>themes\next\_config.yml</code> 中 <code>menu</code>取消标签和分类的注释</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tags: /tags/ || fa fa-tags</span><br><span class="line">categories: /categories/ || fa fa-th</span><br></pre></td></tr></table></figure>
<h3 id="更新Next主题"><a href="#更新Next主题" class="headerlink" title="更新Next主题"></a>更新Next主题</h3><ul>
<li>记得把<code>themes\next\_config.yml</code> 中:<code>mathjax</code>的<code>enbale</code>设置为<code>true</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g <span class="comment">#生成文件</span></span><br><span class="line">hexo s <span class="comment">#启动服务</span></span><br></pre></td></tr></table></figure>
<p><code>hexo s</code> 是开启本地预览服务，或者直接<code>hexo s -g</code>生成并预览，打开浏览器访问 <a target="_blank" rel="noopener" href="http://localhost:4000">localhost:4000</a> 即可看到内容</p>
<h2 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h2><p>复制 <code>user\.ssh\id_rsa.pub</code> 到github账户的 <code>settints</code> - <code>SSH keys</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git ##注意 这里有空格</span><br><span class="line">  repository: git@github.com:lclee0577/lclee.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>部署到github前要先安装hexo-deployer-git</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git  --save</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean </span><br><span class="line">hexo d -g</span><br></pre></td></tr></table></figure>
<h2 id="异地管理"><a href="#异地管理" class="headerlink" title="异地管理"></a>异地管理</h2><p>创建hexo分支 并设置为默认分支</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> Hexo-Blog </span><br><span class="line">git init</span><br><span class="line">git branch hexo</span><br><span class="line">git remote add origin https://github.com/lclee0577/lclee0577.github.io.git</span><br></pre></td></tr></table></figure>
<p>在 github 网页端 <code>Settings</code> - <code>Branches</code> -<code>Default branch</code> 中将默认分支设置为<code>hexo</code> 并点击<code>update</code>确认。</p>
<p>异地管理只需克隆hexo分支，安装开发依赖，再编辑即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --devDependencies</span><br></pre></td></tr></table></figure>
<h2 id="插入markdown目录"><a href="#插入markdown目录" class="headerlink" title="插入markdown目录"></a>插入markdown目录</h2><ul>
<li>无需安装hexo-toc 使用next主题会根据不同级别的标题自动生成目录</li>
<li><p>在<code>next\_config.yml</code>中设置<code>toc</code> 的 <code>enable</code> 和 <code>number</code>即可</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">toc:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Automatically add list number to toc.</span></span><br><span class="line">  <span class="attr">number:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h2 id="插入Latex"><a href="#插入Latex" class="headerlink" title="插入Latex"></a>插入Latex</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7ab21c7f0674">https://www.jianshu.com/p/7ab21c7f0674</a></p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">lclee</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lclee</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="P1. 环境介绍 涵盖 c++11 和 c++14  C++ 2.0 的新特性包含语言和标准库两部分  头文件不再使用 .h 后缀，例如 #include &lt;vector&gt;  新式的 c 头文件也不再带有 .h, 例如 #include &lt;cstdio&gt;，在之前的名称前面加一个 c  旧式 c 头文件 带有 .h仍然可以使用，例如 #include &lt;stdio.h&amp;">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ 2.0 新特性">
<meta property="og:url" content="http://yoursite.com/2021/02/03/C-2-0-%E6%96%B0%E7%89%B9%E6%80%A7/index.html">
<meta property="og:site_name" content="Blog-lclee">
<meta property="og:description" content="P1. 环境介绍 涵盖 c++11 和 c++14  C++ 2.0 的新特性包含语言和标准库两部分  头文件不再使用 .h 后缀，例如 #include &lt;vector&gt;  新式的 c 头文件也不再带有 .h, 例如 #include &lt;cstdio&gt;，在之前的名称前面加一个 c  旧式 c 头文件 带有 .h仍然可以使用，例如 #include &lt;stdio.h&amp;">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-02-03T06:19:42.000Z">
<meta property="article:modified_time" content="2021-02-26T10:49:51.354Z">
<meta property="article:author" content="lclee">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2021/02/03/C-2-0-%E6%96%B0%E7%89%B9%E6%80%A7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>C++ 2.0 新特性 | Blog-lclee</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Blog-lclee</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/03/C-2-0-%E6%96%B0%E7%89%B9%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lclee">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog-lclee">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++ 2.0 新特性
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-02-03 14:19:42" itemprop="dateCreated datePublished" datetime="2021-02-03T14:19:42+08:00">2021-02-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-02-26 18:49:51" itemprop="dateModified" datetime="2021-02-26T18:49:51+08:00">2021-02-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="P1-环境介绍"><a href="#P1-环境介绍" class="headerlink" title="P1. 环境介绍"></a>P1. 环境介绍</h1><ul>
<li><p>涵盖 c++11 和 c++14</p>
</li>
<li><p>C++ 2.0 的新特性包含语言和标准库两部分</p>
<ul>
<li><p>头文件不再使用 <code>.h</code> 后缀，例如 <code>#include &lt;vector&gt;</code></p>
</li>
<li><p>新式的 c 头文件也不再带有 <code>.h</code>, 例如 <code>#include &lt;cstdio&gt;</code>，在之前的名称前面加一个 c</p>
</li>
<li><p>旧式 c 头文件 带有 <code>.h</code>仍然可以使用，例如 <code>#include &lt;stdio.h&gt;</code></p>
</li>
<li><p>常用的数据类型都在 <code>std</code> 这里命名空间内，如<code>&lt;type_traits&gt;</code>, <code>&lt; unordered_set&gt;</code>，<code>&lt;forward_list&gt;</code> 等等</p>
</li>
</ul>
</li>
</ul>
<h1 id="P2-variadic-templates-变参模板"><a href="#P2-variadic-templates-变参模板" class="headerlink" title="P2. variadic templates 变参模板"></a>P2. variadic templates 变参模板</h1><ul>
<li><p>可以处理任意类型，任意数量的参数</p>
</li>
<li><p>本质是将参数分成第一个和后边一包（pack），每次处理第一个，在递归调用。</p>
</li>
<li><p>注意需要写边界条件。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> T&amp; firstArg, <span class="keyword">const</span> Types&amp;... args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; firstArg &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    print(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(<span class="number">123</span>, <span class="string">&quot;heool&quot;</span>,<span class="built_in">bitset</span>&lt;<span class="number">16</span>&gt;(<span class="number">377</span>),<span class="number">7.5</span>);<span class="comment">//就可以以此打印</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>...</code> 表示参数包，注意代码中 <code>...</code> 的位置</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> Types&amp;... args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;one type&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>上面这段重载版本也可以与之前的共存，具体原来后面课程再讲，我认为应该是调用较为特化的版本,先留个坑讲解之后再来补充 在P15讲解</p>
</li>
<li><p>还有两个计算hash值 和 tuple 的递归继承的范例在 <a href="/2020/12/03/STL%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/" title="STL与泛型编程">STL与泛型编程</a> <code>P40</code>  <code>hash_val</code>函数 和 <code>P41</code> <code>tuple</code> 的定义</p>
</li>
</ul>
<h1 id="P3-一些细节知识"><a href="#P3-一些细节知识" class="headerlink" title="P3. 一些细节知识"></a>P3. 一些细节知识</h1><ul>
<li><p><code>vector&lt;list&lt;int&gt; &gt;</code> 在c++11 之前两个尖括号必须分开，否则会被认为是 <code>&gt;&gt;</code> 操作符，c++11之后则不必</p>
</li>
<li><p>之前的版本一直是将 <code>NULL</code> 定义为 0，这与将指针赋值为 0 不太符合，新增关键字 <code>nullptr</code> 来代替 <code>NULL</code>。</p>
</li>
<li><p>自动类型推导 <code>auto</code>，用来处理变量名过长或者变量类型过于复杂。不可用来生命所有变量。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">auto</span> pose = v.begin();<span class="comment">//vector&lt;string&gt; ::iterator 类型太长</span></span><br><span class="line"><span class="keyword">auto</span> l = [](<span class="keyword">int</span> x) -&gt; <span class="keyword">bool</span>&#123;<span class="comment">//匿名函数的类型过于复杂，匿名函数在后面会谈到</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="P4-Uniform-Initialization-一致初始化"><a href="#P4-Uniform-Initialization-一致初始化" class="headerlink" title="P4. Uniform Initialization 一致初始化"></a>P4. Uniform Initialization 一致初始化</h1><ul>
<li>接前一讲，<code>auto</code> 可以用来简化代码</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; c;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;::iterator ite;</span><br><span class="line">ite = find(c.begin(),c.end(),target);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> = find(c.begin(),c.end(),target); <span class="comment">//省去提前生命变量</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>在之前的版本中会出现各种方法的初始化，小括号，中括号，大括号。在c++11之后，可以都使用大括号来初始化。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> valuesp[] &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; cities &#123;</span><br><span class="line">    <span class="string">&quot;Berlin&quot;</span>,<span class="string">&quot;New York&quot;</span>, <span class="string">&quot;London&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; c&#123;<span class="number">4.0</span>,<span class="number">3.0</span>&#125;<span class="comment">//相当于c(4.0,3.0) </span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>编译器看到 <code>&#123;t1,t2,t3,...tn&#125;</code>,便会做出一个 <code>initializer_list&lt;T&gt;</code>,关联到一个 <code>array&lt;T,n&gt;</code>,调用函数（如ctor）时这些元素被逐一拆解传给函数。</p>
</li>
<li><p>若函数有接受 <code>initializer_list&lt;T&gt;</code> 的特化版本，则直接传入</p>
</li>
<li><p>若函数没有接受 <code>initializer_list&lt;T&gt;</code> 的特化版本，则拆解传入</p>
</li>
<li><p>若函数仅有 <code>initializer_list&lt;T&gt;</code> 版本，则需要我们自己准备好一包来传入，之后会有更加详细的例子。</p>
</li>
<li><p>所有的容器都有接受 <code>initializer_list&lt;T&gt;</code>版本的ctor</p>
</li>
<li><p><code>complex&lt;double&gt;</code>并没有接受 <code>initializer_list&lt;T&gt;</code>的版本，<code>array&lt;double,2&gt;</code> 被拆解传给ctor</p>
</li>
</ul>
<h1 id="P5-Initializer-List-上"><a href="#P5-Initializer-List-上" class="headerlink" title="P5. Initializer List 上"></a>P5. Initializer List 上</h1><ul>
<li>以 {} 初始化的变量有初值</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;      <span class="comment">//i 未定义</span></span><br><span class="line"><span class="keyword">int</span> j&#123;&#125;;    <span class="comment">//i初始化为0</span></span><br><span class="line"><span class="keyword">int</span>* p；    <span class="comment">//未定义指针</span></span><br><span class="line"><span class="keyword">int</span>* q&#123;&#125;;   <span class="comment">//q初始化为nullptr</span></span><br></pre></td></tr></table></figure>
<ul>
<li>narrowing initializations 窄向初始化</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">x1</span><span class="params">(<span class="number">5.3</span>)</span></span>;    <span class="comment">//OK 但是为5</span></span><br><span class="line"><span class="keyword">int</span> x2 = <span class="number">5.3</span>；  <span class="comment">//OK 但是为5</span></span><br><span class="line"><span class="keyword">int</span> x3&#123;<span class="number">5.3</span>&#125;；   <span class="comment">//error: narrowing conversion</span></span><br><span class="line"><span class="keyword">char</span> c1&#123;<span class="number">7</span>&#125;;     <span class="comment">//OK 虽然7是int，但是可以转成char</span></span><br><span class="line"><span class="keyword">char</span> c2&#123;<span class="number">99999</span>&#125;; <span class="comment">//error: narrowing conversion</span></span><br></pre></td></tr></table></figure>
<h1 id="P6-Initializer-List-下"><a href="#P6-Initializer-List-下" class="headerlink" title="P6. Initializer List 下"></a>P6. Initializer List 下</h1><ul>
<li>可以用来进行初始化，也可以用来处理一串数据 a list of valve</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; val)</span></span>&#123; <span class="comment">//传入参数必须是initializer_list 或者&#123;  &#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p = val.begin(); p != val.end(); ++p)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>initializer_list 的定义如下，简单来说编译器可以调用第17行的自由构造函数，实现变量初始化。</p>
</li>
<li><p>编译器在边缘过程中先准备好一个array，把指针地址和长度传给私有的构造函数实现初始化</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">template&lt;class _E&gt;</span><br><span class="line">  class initializer_list</span><br><span class="line">  &#123;</span><br><span class="line">  public:</span><br><span class="line">    typedef _E            value_type;</span><br><span class="line">    typedef const _E&amp;     reference;</span><br><span class="line">    typedef const _E&amp;     const_reference;</span><br><span class="line">    typedef size_t        size_type;</span><br><span class="line">    typedef const _E*     iterator;</span><br><span class="line">    typedef const _E*     const_iterator;</span><br><span class="line"></span><br><span class="line">  private:</span><br><span class="line">    iterator          _M_array;</span><br><span class="line">    size_type         _M_len;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; The compiler can call a private constructor.</span><br><span class="line">    constexpr initializer_list(const_iterator __a, size_type __l)</span><br><span class="line">    : _M_array(__a), _M_len(__l) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  public:</span><br><span class="line">    constexpr initializer_list() noexcept</span><br><span class="line">    : _M_array(0), _M_len(0) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Number of elements.</span><br><span class="line">    constexpr size_type</span><br><span class="line">    size() const noexcept &#123; return _M_len; &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; First element.</span><br><span class="line">    constexpr const_iterator</span><br><span class="line">    begin() const noexcept &#123; return _M_array; &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; One past the last element.</span><br><span class="line">    constexpr const_iterator</span><br><span class="line">    end() const noexcept &#123; return begin() + size(); &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>由于initializer_list只是两个指针，对它的拷贝是危险的。</p>
</li>
<li><p><code>initializer_list</code> 在标准库中(几乎所有的容器和部分算法)广泛使用。</p>
</li>
<li><p>可以多个数值比大小</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; max(&#123;<span class="number">54</span>, <span class="number">16</span>, <span class="number">30</span>, <span class="number">50</span>，<span class="number">70</span> &#125;)&lt;&lt; <span class="built_in">endl</span>;<span class="comment">//使用initializer_list比较大小是先 #include &lt;algorithm&gt; 否则无法运行</span></span><br></pre></td></tr></table></figure>
<h1 id="P7-explicit"><a href="#P7-explicit" class="headerlink" title="P7. explicit"></a>P7. explicit</h1><ul>
<li>作用于构造函数，取消隐式转换。极少数用于模板</li>
</ul>
<figure class="highlight cpp"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> real, imag;</span><br><span class="line">    <span class="comment">/*explicit*/</span> Complex(<span class="keyword">int</span> re,<span class="keyword">int</span> im = <span class="number">0</span>):real(re),imag(im)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex&amp; x)&#123;</span><br><span class="line">        <span class="keyword">return</span> Complex(real + x.real, imag + x.imag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out,<span class="keyword">const</span> Complex &amp;c)&#123;</span><br><span class="line">                out&lt;&lt;<span class="string">&quot;(&quot;</span>&lt;&lt;c.real&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;c.imag&lt;&lt;<span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">12</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">Complex c2 = c1 + <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>当第 <code>4</code> 行没有 <code>explicit</code> 时，最会一行中的 5 会被隐式转换为 Complex 类型。</p>
</li>
<li><p>没有 <code>explicit</code> 修饰，且构造函数只有一个参数没有指定，编译器可以提供隐式转换。</p>
</li>
<li><p>当构造函数指明为 <code>explicit</code> 时，只能显式定义，否则将编译报错。</p>
</li>
</ul>
<h1 id="P8-range-based-for-statement"><a href="#P8-range-based-for-statement" class="headerlink" title="P8. range-based for statement"></a>P8. range-based for statement</h1><ul>
<li><p>简单的for循环写法 <code>for(decl:coll)&#123; statement &#125;</code></p>
</li>
<li><p>取出 <code>coll</code> 中的每一个元素赋值到 <code>decl</code> 中括号</p>
</li>
<li><p>如果要修改容器中的内容需要取引用。若没有第二行取引用，则对i的修改不会改变容器</p>
</li>
<li><p>推荐取引用，减少赋值带来的开销</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; coll&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i :coll)&#123;</span><br><span class="line">    i = i * <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ostream_iterator&lt;<span class="keyword">int</span>&gt; <span class="title">out_iter</span><span class="params">(<span class="built_in">cout</span>, <span class="string">&quot; &quot;</span>)</span></span>;<span class="comment">//#include&lt;iterator&gt;</span></span><br><span class="line">copy(coll.cbegin(), coll.cend(), out_iter);<span class="comment">//打印容器内容</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h1 id="P9-defualt-delete"><a href="#P9-defualt-delete" class="headerlink" title="P9. =defualt, =delete"></a>P9. =defualt, =delete</h1><ul>
<li><p>一个类如果应定义了ctor，那么编译器就不在提供 default ctor</p>
</li>
<li><p>如果强制加上一个 =default，就可以重新获得 defualt ctor</p>
</li>
<li><p>在 default ctor 中编译器会来处理一些继承相关的工作</p>
</li>
<li><p>=delete 就是删除这个函数</p>
</li>
<li><p>一般 = delete 和 =default 作用于 构造，拷贝构造，析构函数上</p>
</li>
</ul>
<h1 id="P10-Alias-Template"><a href="#P10-Alias-Template" class="headerlink" title="P10. Alias Template"></a>P10. Alias Template</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Vec = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T,MyAlloc&lt;T&gt;&gt;;<span class="comment">//默认使用allocator</span></span><br><span class="line"></span><br><span class="line">Vec&lt;<span class="keyword">int</span>&gt; coll;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>模板的化名明，使用typedef 和 #define 无法达到同样的效果</p>
</li>
<li><p>当使用化名之后就不能再对其使用特化或偏特化。</p>
</li>
</ul>
<h1 id="P11-template-template-parameter"><a href="#P11-template-template-parameter" class="headerlink" title="P11. template template parameter"></a>P11. template template parameter</h1><ul>
<li>模板的参数也是模板</li>
</ul>
<figure class="highlight cpp"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,</span><br><span class="line">                    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span>&gt;</span><span class="comment">//这里省略了T</span></span><br><span class="line">                        <span class="class"><span class="keyword">class</span> <span class="title">Container</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">xcls</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Container&lt;T&gt; c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    xcls()&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i:&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;)</span><br><span class="line">            c.insert(c.end(), T());</span><br><span class="line"></span><br><span class="line">        <span class="function">Container&lt;T&gt; <span class="title">c1</span><span class="params">(c)</span></span>;</span><br><span class="line">        <span class="function">Container&lt;T&gt; <span class="title">c2</span><span class="params">(<span class="built_in">std</span>::move(c))</span></span>;</span><br><span class="line">        c1.swap(c2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Vec = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T, <span class="built_in">std</span>::allocator&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line">xcls&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&gt; c1;<span class="comment">//从c++17 开始正确，c++17之前 error：expected a template of type ‘template&lt;class&gt; class Container’, got ‘template&lt;class _Tp, class _Alloc&gt; class std::vector’</span></span><br><span class="line"></span><br><span class="line">xcls&lt;<span class="built_in">string</span>, Vec&gt; c2;<span class="comment">//这样C++11 和 14才能编译通过</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>由于vector有2个参数，虽然第二个有默认值，但是在c++17之前，模板模板参数中，并不会调用默认值。</p>
</li>
<li><p>因此需要指定模板的参数，就要用到第<code>17</code>行模板的化名</p>
</li>
</ul>
<h1 id="P12-type-alias-noexcept-override"><a href="#P12-type-alias-noexcept-override" class="headerlink" title="P12. type alias, noexcept, override"></a>P12. type alias, noexcept, override</h1><ul>
<li>类型的别名。借助 <code>using</code> 关键字，类似于 <code>typedef</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//typedef void(*func)(int,int)</span></span><br><span class="line"><span class="keyword">using</span> func = <span class="keyword">void</span>(*)(<span class="keyword">int</span>,<span class="keyword">int</span>);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">example</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>&#123;&#125;;</span><br><span class="line">func fn = example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Container</span>&#123;</span></span><br><span class="line">  <span class="keyword">using</span> value_type = T;<span class="comment">//等同于 typedef T value_type;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>typedef</code> 无法明显的表示 <code>func</code> 是一种类型，这种是接受两个int参数，范围类型为void的函数，使用 <code>using</code> 则意义一目了然。</p>
</li>
<li><p>上述 using 和 typedef 的效果完全相同。</p>
</li>
<li><p>其他 using 的用法: 使用命名空间 <code>using namespace std</code> 或者仅仅使用某个函数 <code>using std::count</code></p>
</li>
</ul>
<hr>
<ul>
<li><p>noexcept 表示函数不会抛出异常。</p>
</li>
<li><p>要告诉编译器，尤其是使用vector 来存储时，移动构造和析构函数一定不能抛出异常。</p>
</li>
<li><p>因为 vector 会成长，需要大量的拷贝构造和析构，只有当移动构造和析构不抛出异常时才能被调用。</p>
</li>
</ul>
<h2 id><a href="#" class="headerlink" title></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="literal">true</span>)</span><span class="comment">//其实还可以加一个括号来填写条件，不加默认都不抛出异常</span></span></span><br></pre></td></tr></table></figure></h2><ul>
<li><p><code>override</code> 应用在虚函数上，当你想要改写虚函数时，在改写函数的括号后写明，可以帮助编译器检查错误。（编译器无法分清是想重新声明一个新的虚函数（不小心写错往往都是声明一个新的，且编译器无法检查出来）还是进行改写，因此改写时要注明override）</p>
</li>
<li><p><code>final</code>，若在类声明后面修饰，则这个类无法被继承，若声明在虚函数后面，则这个函数不能改写。</p>
</li>
</ul>
<h1 id="P13-decltype"><a href="#P13-decltype" class="headerlink" title="P13. decltype"></a>P13. decltype</h1><ul>
<li>decltype 的作用就是根据表达式推断类型</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">auto add(T1 x,T2 y) -&gt; decltype(x+y)//c++14 中可以 decltype(auto) add(T1 x,T2,y)自动推断返回的类型。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>模板函数的返回类型通过推断decltype(x+y) 来确定，这里的auto 并不是指任意类型，而是指推断出的类型。</p>
</li>
<li><p>上面的表达形式与 lambda 表达式很像，lambda 表达式会在之后的章节讲述</p>
</li>
<li><p>在模板编程中只知道对象而不知道类型时来获取类型</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="title">decltype</span><span class="params">(obj)</span>::iterator iType</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>获取 lambda 表达式的返回类型(通常 lambda 表达式 用auto声明)</li>
</ul>
<h1 id="P14-Lambdas"><a href="#P14-Lambdas" class="headerlink" title="P14. Lambdas"></a>P14. Lambdas</h1><ul>
<li>可以理解为一个匿名函数对象</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> l = [] &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;hello lambda&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br><span class="line">l();</span><br></pre></td></tr></table></figure>
<ul>
<li><p>lambda 表达式可以允许在函数体中声明另一段函数</p>
</li>
<li><p>完整的匿名函数如下，中括号内为可使用的外界参数，()内为函数参数，需要加 mutable 才能对函数体内的传入外界参数进行修改。</p>
</li>
<li><p>中括号内默认传值，若要 lambda 修改外界变量需要传引用</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> l = [id] () <span class="keyword">mutable</span> &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; id &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    ++id;<span class="comment">//没有mutable id 是read only</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">id = <span class="number">42</span>;</span><br><span class="line">l();<span class="comment">//打印还是0，若要打印42，需要取引用</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>可以将中括号内的外接参数想象成 lambda 初始化内部变量的初始值，虽然内外名称相同，但是初始化完成后就不再使用，因此若要修改外部值需要传引用。</p>
</li>
<li><p>lambda 对象并没有默认的构造函数和赋值动作，因此作为容器排序的准则可能仿函数更加合适。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set&lt;Person,decltype(cmp)&gt; coll(cmp);//由于没有默认构造函数，需要传入一个对象</span><br><span class="line"><span class="comment">//set&lt;Person,decltype(cmp)&gt; coll//大部分人会写成这种错误的写法</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用 lambda 表达式可以避免冗长的仿函数声明</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">58</span>, <span class="number">60</span>, <span class="number">47</span>, <span class="number">52</span>, <span class="number">89</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">19</span>;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">59</span>;</span><br><span class="line">vi.erase(</span><br><span class="line">    remove_if(vi.begin(), vi.end(),</span><br><span class="line">              [x, y](<span class="keyword">int</span> n) &#123; <span class="keyword">return</span> x &lt; n &amp;&amp; n &lt; y; &#125;),</span><br><span class="line">    vi.end());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : vi)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//10 4 0 60 89</span></span><br></pre></td></tr></table></figure>
<h1 id="P15-Variadic-Template-1"><a href="#P15-Variadic-Template-1" class="headerlink" title="P15. Variadic Template 1"></a>P15. Variadic Template 1</h1><ul>
<li>讲解 <code>P2</code> 提出的问题，特化的版本更有限被调用，因此下面 P2 最后提到的那一段代码永远不会被调用。</li>
</ul>
<h1 id="P16-Variadic-Template-2"><a href="#P16-Variadic-Template-2" class="headerlink" title="P16. Variadic Template 2"></a>P16. Variadic Template 2</h1><ul>
<li>重写 <code>printf</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printg</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (*s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*s == <span class="string">&#x27;%&#x27;</span> &amp;&amp; *(++s)!= <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">            <span class="keyword">throw</span> runtime_error(<span class="string">&quot;invalid format&quot;</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *s++;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printg</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s,T value,Args... args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (*s)&#123;        </span><br><span class="line">        <span class="keyword">if</span> (*s == <span class="string">&#x27;%&#x27;</span> &amp;&amp; *(++s)!= <span class="string">&#x27;%&#x27;</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; value&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        printg(++s, args...);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *s++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> logic_error(<span class="string">&quot;extra arguement provided&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">test03::printg(<span class="string">&quot;%d%s%p%f\n&quot;</span>, <span class="number">15</span>, <span class="string">&quot;this is Ace&quot;</span>, pi, <span class="number">3.14159</span>);<span class="comment">//15 this is Ace 0x55b565107e70 3.14159 </span></span><br></pre></td></tr></table></figure>
<h1 id="P17-Variadic-Template-3"><a href="#P17-Variadic-Template-3" class="headerlink" title="P17. Variadic Template 3"></a>P17. Variadic Template 3</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">   _GLIBCXX14_CONSTEXPR</span><br><span class="line">   <span class="keyword">inline</span> _Tp</span><br><span class="line">   max(<span class="built_in">initializer_list</span>&lt;_Tp&gt; __l)</span><br><span class="line">   &#123; <span class="keyword">return</span> *<span class="built_in">std</span>::max_element(__l.begin(), __l.end()); &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用initializer_list来比较一串数组，但是<code>max(&#123;1,2,3,4,5&#125;)</code> 仍然有大括号</li>
</ul>
<h1 id="P18-Variadic-Template-4"><a href="#P18-Variadic-Template-4" class="headerlink" title="P18. Variadic Template 4"></a>P18. Variadic Template 4</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxi</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxi</span><span class="params">(<span class="keyword">int</span> n, Args... args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> max(n, maxi(args...));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">maxi(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);<span class="comment">//6</span></span><br></pre></td></tr></table></figure>
<ul>
<li>递归调用自己，一层一层比大小。</li>
</ul>
<h1 id="P19-Variadic-Template-5"><a href="#P19-Variadic-Template-5" class="headerlink" title="P19. Variadic Template 5"></a>P19. Variadic Template 5</h1><ul>
<li>实现 <code>cout&lt;&lt;make_tuple(7.5,string(&quot;hello&quot;),bitset&lt;16&gt;(377),42)</code> 输出<code>[7.5,hello,0000000101111001,42]</code>，前后有方括号中间有逗号。</li>
</ul>
<figure class="highlight cpp"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">template</span> &lt;<span class="keyword">int</span> IDX, <span class="keyword">int</span> MAX, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PRINT_TUPLE</span> &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span> <span class="params">(ostream&amp; os, <span class="keyword">const</span> tuple&lt;Args...&gt;&amp; t)</span></span>&#123;</span><br><span class="line">            os &lt;&lt; get&lt;IDX&gt;(t) &lt;&lt; (IDX + <span class="number">1</span> == MAX ? <span class="string">&quot;&quot;</span>: <span class="string">&quot;,&quot;</span>);</span><br><span class="line">            PRINT_TUPLE&lt;IDX+<span class="number">1</span>, MAX, Args...&gt;::print(os, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">int</span> MAX, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PRINT_TUPLE</span>&lt;</span>MAX, MAX, Args...&gt; &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span> <span class="params">(ostream&amp; os, <span class="keyword">const</span> tuple&lt;Args...&gt;&amp; t)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ... Args&gt;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; os, <span class="keyword">const</span> tuple&lt;Args...&gt;&amp; t) &#123;</span><br><span class="line">        os &lt;&lt; <span class="string">&quot;[&quot;</span>;</span><br><span class="line">        PRINT_TUPLE&lt;<span class="number">0</span>, <span class="keyword">sizeof</span>...(Args), Args...&gt;::print(os, t);</span><br><span class="line">        <span class="keyword">return</span> os &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>模板中不仅能定义类型，若指定类型还能定义变量，如第 <code>1</code> 行的 <code>IDX</code> 和 <code>MAX</code></p>
</li>
<li><p>通过每次创建实现变量<code>IDX</code>增加来实现对位置的记录。</p>
</li>
<li><p>这里复习一下自定义类的输出(17行)，对于类内私有变量需要用友元函数重载操作符</p>
</li>
</ul>
<h1 id="P20-Variadic-Template-6"><a href="#P20-Variadic-Template-6" class="headerlink" title="P20. Variadic Template 6"></a>P20. Variadic Template 6</h1><ul>
<li><p>tuple的递归继承在上一门课程STL中已经学过</p>
</li>
<li><p>注意tuple在内存在中的结构是现有尾部数据再有头部数据。</p>
</li>
</ul>
<h1 id="P21-Variadic-Template-7"><a href="#P21-Variadic-Template-7" class="headerlink" title="P21. Variadic Template 7"></a>P21. Variadic Template 7</h1><ul>
<li>递归复合实现tuple</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ... Values&gt; <span class="class"><span class="keyword">class</span> <span class="title">mytuple2</span>;</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">class</span> <span class="title">mytuple2</span>&lt;</span>&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span> ... Tail&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mytuple2</span>&lt;</span>Head, Tail...&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> composited = mytuple2&lt;Tail...&gt;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    mytuple2() &#123;&#125;</span><br><span class="line">    mytuple2(Head v, Tail... vtail) : m_head(v), m_tail(vtail...) &#123;&#125;</span><br><span class="line">    <span class="function">Head <span class="title">head</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> m_head;&#125;</span><br><span class="line">    <span class="function">composited&amp; <span class="title">tail</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> m_tail;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Head m_head;</span><br><span class="line">    composited m_tail;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="P22-源码分布-P23-Rvalue-reference"><a href="#P22-源码分布-P23-Rvalue-reference" class="headerlink" title="P22. 源码分布 P23. Rvalue reference"></a>P22. 源码分布 P23. Rvalue reference</h1><ul>
<li><p>源码分布，在之前的课程已经介绍</p>
</li>
<li><p>右值引用，避免一些不必要的拷贝，当等号右侧是右值时，左值可以直接偷取右值数据。</p>
</li>
<li><p>左值 - 变量可以被赋值，右值-临时对象，不能被赋值</p>
</li>
<li><p>适用场景：容器中放入临时对象，这样可以避免拷贝构造带来的开销</p>
</li>
<li><p>若一直这个变量之后不会再用 可以使用<code>std::move</code>将左值变成右值。</p>
</li>
</ul>
<h1 id="P24-perfect-forwarding"><a href="#P24-perfect-forwarding" class="headerlink" title="P24. perfect forwarding"></a>P24. perfect forwarding</h1><ul>
<li>转发就是通过一个函数将参数继续转交给另一个函数进行处理，原参数可能是右值，可能是左值，如果还能继续保持参数的原有特征，那么它就是完美的。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>&amp; i)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;process(int&amp;):&quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>&amp;&amp; i)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;process(int&amp;&amp;):&quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myforward</span><span class="params">(<span class="keyword">int</span>&amp;&amp; i)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;myforward(int&amp;&amp;):&quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    process(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    process(a); <span class="comment">//a被视为左值 process(int&amp;):0</span></span><br><span class="line">    process(<span class="number">1</span>); <span class="comment">//1被视为右值 process(int&amp;&amp;):1</span></span><br><span class="line">    process(move(a)); <span class="comment">//强制将a由左值改为右值 process(int&amp;&amp;):0</span></span><br><span class="line">    myforward(<span class="number">2</span>);  <span class="comment">//右值经过forward函数转交给process函数，却称为了一个左值，</span></span><br><span class="line">    <span class="comment">//原因是该右值有了名字  所以是 process(int&amp;):2</span></span><br><span class="line">    myforward(move(a));  <span class="comment">// 同上，在转发的时候右值变成了左值  process(int&amp;):0</span></span><br><span class="line">    <span class="comment">// forward(a) // 错误用法，右值引用不接受左值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>上面的例子就是不完美转发，而c++中提供了一个<code>std::forward()</code>模板函数解决这个问题.</li>
</ul>
<h1 id="P25-more-aware-class-有移动意识的类-P26-测试"><a href="#P25-more-aware-class-有移动意识的类-P26-测试" class="headerlink" title="P25. more aware class 有移动意识的类 P26. 测试"></a>P25. more aware class 有移动意识的类 P26. 测试</h1><ul>
<li>移动构造 (<code>34</code> 行)和移动赋值(<code>53</code>行)要把原来的指针赋值为nullptr</li>
</ul>
<figure class="highlight cpp"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> CCtor; <span class="comment">//统计调用拷贝构造函数的次数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> MCtor; <span class="comment">//统计调用移动构造函数的次数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> CAsgn; <span class="comment">//统计调用拷贝赋值函数的次数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> MAsgn; <span class="comment">//统计调用移动赋值函数的次数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">   MyString(<span class="keyword">const</span> <span class="keyword">char</span>* cstr=<span class="number">0</span>)&#123;</span><br><span class="line">       <span class="keyword">if</span> (cstr) &#123;</span><br><span class="line">          m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(cstr)+<span class="number">1</span>];</span><br><span class="line">          <span class="built_in">strcpy</span>(m_data, cstr);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">          m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">          *m_data = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 拷贝构造函数</span></span><br><span class="line">   MyString(<span class="keyword">const</span> MyString&amp; str) &#123;</span><br><span class="line">       CCtor ++;</span><br><span class="line">       m_data = <span class="keyword">new</span> <span class="keyword">char</span>[ <span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span> ];</span><br><span class="line">       <span class="built_in">strcpy</span>(m_data, str.m_data);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 移动构造函数</span></span><br><span class="line">   MyString(MyString&amp;&amp; str) <span class="keyword">noexcept</span></span><br><span class="line">       :m_data(str.m_data) &#123;</span><br><span class="line">       MCtor ++;</span><br><span class="line">       str.m_data = <span class="literal">nullptr</span>; <span class="comment">//不再指向之前的资源了</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 拷贝赋值函数 =号重载</span></span><br><span class="line">   MyString&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyString&amp; str)&#123;</span><br><span class="line">       CAsgn ++;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) <span class="comment">// 避免自我赋值!!</span></span><br><span class="line">          <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">delete</span>[] m_data;</span><br><span class="line">       m_data = <span class="keyword">new</span> <span class="keyword">char</span>[ <span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span> ];</span><br><span class="line">       <span class="built_in">strcpy</span>(m_data, str.m_data);</span><br><span class="line">       <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 移动赋值函数 =号重载</span></span><br><span class="line">   MyString&amp; <span class="keyword">operator</span>=(MyString&amp;&amp; str) <span class="keyword">noexcept</span>&#123;</span><br><span class="line">       MAsgn ++;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) <span class="comment">// 避免自我赋值!!</span></span><br><span class="line">          <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">delete</span>[] m_data;</span><br><span class="line">       m_data = str.m_data;</span><br><span class="line">       str.m_data = <span class="literal">nullptr</span>; <span class="comment">//不再指向之前的资源了</span></span><br><span class="line">       <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ~MyString() &#123;</span><br><span class="line">       <span class="keyword">delete</span>[] m_data;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">char</span>* <span class="title">get_c_str</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_data; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">char</span>* m_data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">size_t</span> MyString::CCtor = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> MyString::MCtor = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> MyString::CAsgn = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> MyString::MAsgn = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;MyString&gt; vecStr;</span><br><span class="line">    vecStr.reserve(<span class="number">1000</span>); <span class="comment">//先分配好1000个空间</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">        vecStr.push_back(MyString(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;CCtor = &quot;</span> &lt;&lt; MyString::CCtor &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MCtor = &quot;</span> &lt;&lt; MyString::MCtor &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;CAsgn = &quot;</span> &lt;&lt; MyString::CAsgn &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MAsgn = &quot;</span> &lt;&lt; MyString::MAsgn &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 结果</span></span><br><span class="line"><span class="comment">CCtor = 0</span></span><br><span class="line"><span class="comment">MCtor = 1000</span></span><br><span class="line"><span class="comment">CAsgn = 0</span></span><br><span class="line"><span class="comment">MAsgn = 0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>对于会成长的容器，move的性能提升巨大，对于节点类型容器，只要略微提升</li>
</ul>
<h1 id="后面的小结"><a href="#后面的小结" class="headerlink" title="后面的小结"></a>后面的小结</h1><ul>
<li><p>array hashtable 与之前有重复</p>
</li>
<li><p>元编程：对类型进行编程 如类型萃取</p>
</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/12/03/STL%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/" rel="prev" title="STL与泛型编程">
      <i class="fa fa-chevron-left"></i> STL与泛型编程
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/02/09/C-%E7%A8%8B%E5%BA%8F%E7%94%9F%E5%89%8D%E6%AD%BB%E5%90%8E/" rel="next" title="C++ 程序生前死后">
      C++ 程序生前死后 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#P1-%E7%8E%AF%E5%A2%83%E4%BB%8B%E7%BB%8D"><span class="nav-text">P1. 环境介绍</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#P2-variadic-templates-%E5%8F%98%E5%8F%82%E6%A8%A1%E6%9D%BF"><span class="nav-text">P2. variadic templates 变参模板</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#P3-%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82%E7%9F%A5%E8%AF%86"><span class="nav-text">P3. 一些细节知识</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#P4-Uniform-Initialization-%E4%B8%80%E8%87%B4%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">P4. Uniform Initialization 一致初始化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#P5-Initializer-List-%E4%B8%8A"><span class="nav-text">P5. Initializer List 上</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#P6-Initializer-List-%E4%B8%8B"><span class="nav-text">P6. Initializer List 下</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#P7-explicit"><span class="nav-text">P7. explicit</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#P8-range-based-for-statement"><span class="nav-text">P8. range-based for statement</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#P9-defualt-delete"><span class="nav-text">P9. &#x3D;defualt, &#x3D;delete</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#P10-Alias-Template"><span class="nav-text">P10. Alias Template</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#P11-template-template-parameter"><span class="nav-text">P11. template template parameter</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#P12-type-alias-noexcept-override"><span class="nav-text">P12. type alias, noexcept, override</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-text">1
2
void foo() noexcept;
void foo() noexcept(true)&#x2F;&#x2F;其实还可以加一个括号来填写条件，不加默认都不抛出异常
</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#P13-decltype"><span class="nav-text">P13. decltype</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#P14-Lambdas"><span class="nav-text">P14. Lambdas</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#P15-Variadic-Template-1"><span class="nav-text">P15. Variadic Template 1</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#P16-Variadic-Template-2"><span class="nav-text">P16. Variadic Template 2</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#P17-Variadic-Template-3"><span class="nav-text">P17. Variadic Template 3</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#P18-Variadic-Template-4"><span class="nav-text">P18. Variadic Template 4</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#P19-Variadic-Template-5"><span class="nav-text">P19. Variadic Template 5</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#P20-Variadic-Template-6"><span class="nav-text">P20. Variadic Template 6</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#P21-Variadic-Template-7"><span class="nav-text">P21. Variadic Template 7</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#P22-%E6%BA%90%E7%A0%81%E5%88%86%E5%B8%83-P23-Rvalue-reference"><span class="nav-text">P22. 源码分布 P23. Rvalue reference</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#P24-perfect-forwarding"><span class="nav-text">P24. perfect forwarding</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#P25-more-aware-class-%E6%9C%89%E7%A7%BB%E5%8A%A8%E6%84%8F%E8%AF%86%E7%9A%84%E7%B1%BB-P26-%E6%B5%8B%E8%AF%95"><span class="nav-text">P25. more aware class 有移动意识的类 P26. 测试</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%8E%E9%9D%A2%E7%9A%84%E5%B0%8F%E7%BB%93"><span class="nav-text">后面的小结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">lclee</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lclee</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
